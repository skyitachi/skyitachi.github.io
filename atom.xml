<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>skyitachi&#39;s blog</title>
  
  
  <link href="https://skyitachi.github.io/atom.xml" rel="self"/>
  
  <link href="https://skyitachi.github.io/"/>
  <updated>2024-08-07T16:00:00.000Z</updated>
  <id>https://skyitachi.github.io/</id>
  
  <author>
    <name>skyitachi</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Lucene中的HNSW索引是如何写入的</title>
    <link href="https://skyitachi.github.io/2024/08/08/Lucene%E4%B8%AD%E7%9A%84hnsw%E7%B4%A2%E5%BC%95%E6%98%AF%E5%A6%82%E4%BD%95%E5%86%99%E5%85%A5%E7%9A%84/"/>
    <id>https://skyitachi.github.io/2024/08/08/Lucene%E4%B8%AD%E7%9A%84hnsw%E7%B4%A2%E5%BC%95%E6%98%AF%E5%A6%82%E4%BD%95%E5%86%99%E5%85%A5%E7%9A%84/</id>
    <published>2024-08-07T16:00:00.000Z</published>
    <updated>2024-08-07T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h1><ul><li>梳理IndexWriter.addDocuments 和 IndexWriter.commit的调用栈</li><li>梳理向量索引在Lucene中是如何被存储的主要调用路径，包括如何原始向量如何保存到内存和文件，HNSW索引的构建以及如何持久化的</li><li>Lucene在处理Segment Merge的过程中是如何处理HNSW索引的</li></ul><h1 id="调用栈"><a href="#调用栈" class="headerlink" title="调用栈"></a>调用栈</h1><p><img src="/../../imgs/lucene_addDocuments_and_commit.svg" alt="stack"></p><h2 id="调用栈对应的示例"><a href="#调用栈对应的示例" class="headerlink" title="调用栈对应的示例"></a>调用栈对应的示例</h2><p>对应的Lucene版本: releases&#x2F;lucene&#x2F;9.9.0</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Path</span> <span class="variable">docPath</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;data/lucene_knn_demo&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (Files.exists(docPath)) &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">absPath</span> <span class="operator">=</span> docPath.toAbsolutePath().toString();</span><br><span class="line"><span class="type">File</span> <span class="variable">directory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(absPath);</span><br><span class="line">FileUtils.deleteDirectory(directory);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">Directory</span> <span class="variable">directory</span> <span class="operator">=</span> FSDirectory.open(docPath);</span><br><span class="line"><span class="type">IndexWriterConfig</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IndexWriterConfig</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">FileOutputStream</span> <span class="variable">output</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;lucene_knn.log&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">InfoStream</span> <span class="variable">customInfoStream</span> <span class="operator">=</span>  <span class="keyword">new</span> <span class="title class_">PrintStreamInfoStream</span>(<span class="keyword">new</span> <span class="title class_">PrintStream</span>(output));</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;IW Component is enabled: &quot;</span> + customInfoStream.isEnabled(<span class="string">&quot;IW&quot;</span>));</span><br><span class="line">config.setInfoStream(customInfoStream);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">config.setUseCompoundFile(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">IndexWriter</span> <span class="variable">indexWriter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IndexWriter</span>(directory, config);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">10000</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">dim</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line">List&lt;Document&gt; docs = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line"><span class="type">Document</span> <span class="variable">doc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Document</span>();</span><br><span class="line">doc.add(<span class="keyword">new</span> <span class="title class_">KeywordField</span>(<span class="string">&quot;id&quot;</span>, Integer.toString(i), Field.Store.YES));</span><br><span class="line">doc.add(<span class="keyword">new</span> <span class="title class_">KnnFloatVectorField</span>(<span class="string">&quot;fvecs&quot;</span>, generateFVector(dim)));</span><br><span class="line">docs.add(doc);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">indexWriter.addDocuments(docs);</span><br><span class="line">indexWriter.commit();</span><br><span class="line"></span><br><span class="line">System.out.printf(<span class="string">&quot;%d vectors consumes: %d ms\n&quot;</span>, count, System.currentTimeMillis() - start);</span><br><span class="line">start = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line"><span class="comment">//        indexWriter.forceMerge(1);</span></span><br><span class="line"><span class="comment">//        System.out.printf(&quot;forceMerge consumes: %d ms\n&quot;, System.currentTimeMillis() - start);</span></span><br><span class="line"></span><br><span class="line">indexWriter.close();</span><br></pre></td></tr></table></figure><h1 id="Lucene如何在内存中存储向量的"><a href="#Lucene如何在内存中存储向量的" class="headerlink" title="Lucene如何在内存中存储向量的"></a>Lucene如何在内存中存储向量的</h1><p>向量相关的分为两个部分，一个是原始向量，一个是向量索引</p><h2 id="内存中向量的存储"><a href="#内存中向量的存储" class="headerlink" title="内存中向量的存储"></a>内存中向量的存储</h2><h3 id="原始向量"><a href="#原始向量" class="headerlink" title="原始向量"></a>原始向量</h3><p>从调用链路上看，<code>indexChain.indexVectorValue</code> 涉及到了向量相关的存储，根据向量类型的(Float32或者Byte), 本文例子中的使用Float32数组，最终会调用<code>Lucene99FlatVectorsWriter.FieldWriter.addValue</code>, 下面详细分析一下源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addValue</span><span class="params">(<span class="type">int</span> docID, T vectorValue)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"><span class="keyword">if</span> (docID == lastDocID) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(</span><br><span class="line"><span class="string">&quot;VectorValuesField \&quot;&quot;</span></span><br><span class="line">+ fieldInfo.name</span><br><span class="line">+ <span class="string">&quot;\&quot; appears more than once in this document (only one value is allowed per field)&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">assert</span> docID &gt; lastDocID;</span><br><span class="line"><span class="comment">// 首先从IndexableField里的VectorValues复制一份原始向量</span></span><br><span class="line"><span class="type">T</span> <span class="variable">copy</span> <span class="operator">=</span> copyValue(vectorValue);</span><br><span class="line">docsWithField.add(docID);</span><br><span class="line"><span class="comment">// vectors 是List&lt;T&gt; 对象，说明原始向量在内存中直接存入到一个List中</span></span><br><span class="line">vectors.add(copy);</span><br><span class="line">lastDocID = docID;</span><br><span class="line"><span class="keyword">if</span> (indexingDelegate != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="comment">// 这里就是索引相关的计算</span></span><br><span class="line">indexingDelegate.addValue(docID, copy);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><p>内存中HNSW索引的构建的入口是<code>indexingDelegate.addValue</code>, 在本文中<code>indexingDelegate</code>就是<code>Lucene99HnswVectorsWriter.FieldWriter</code>, 下面简要分析一下其源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addValue</span><span class="params">(<span class="type">int</span> docID, T vectorValue)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"><span class="keyword">if</span> (docID == lastDocID) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(</span><br><span class="line"><span class="string">&quot;VectorValuesField \&quot;&quot;</span></span><br><span class="line">+ fieldInfo.name</span><br><span class="line">+ <span class="string">&quot;\&quot; appears more than once in this document (only one value is allowed per field)&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">assert</span> docID &gt; lastDocID;</span><br><span class="line"><span class="comment">// 原始向量又被存储了一次</span></span><br><span class="line">vectors.add(vectorValue);</span><br><span class="line">docsWithField.add(docID);</span><br><span class="line"><span class="comment">// 构建索引</span></span><br><span class="line">hnswGraphBuilder.addGraphNode(node);</span><br><span class="line">node++;</span><br><span class="line">lastDocID = docID;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HNSW索引是如何在内存中表示的，Lucene使用了<code>OnHeapHnswGraph</code>表示了索引相关信息的存储（主要是节点之间的连接信息）.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 省略了其他一些字段</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">OnHeapHnswGraph</span> <span class="keyword">extends</span> <span class="title class_">HnswGraph</span> <span class="keyword">implements</span> <span class="title class_">Accountable</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> AtomicReference&lt;EntryNode&gt; entryNode; <span class="comment">// 表示了HNSW中整个索引的entryPoint</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// the internal graph representation where the first dimension is node id and second dimension is</span></span><br><span class="line">  <span class="comment">// level</span></span><br><span class="line">  <span class="comment">// e.g. graph[1][2] is all the neighbours of node 1 at level 2</span></span><br><span class="line">  <span class="comment">// 索引中节点的邻接信息</span></span><br><span class="line">  <span class="keyword">private</span> NeighborArray[][] graph;</span><br><span class="line"></span><br><span class="line">  OnHeapHnswGraph(<span class="type">int</span> M, <span class="type">int</span> numNodes) &#123;</span><br><span class="line">    <span class="built_in">this</span>.entryNode = <span class="keyword">new</span> <span class="title class_">AtomicReference</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">EntryNode</span>(-<span class="number">1</span>, <span class="number">1</span>));</span><br><span class="line">    <span class="comment">// Neighbours&#x27; size on upper levels (nsize) and level 0 (nsize0)</span></span><br><span class="line">    <span class="comment">// We allocate extra space for neighbours, but then prune them to keep allowed maximum</span></span><br><span class="line">    <span class="built_in">this</span>.nsize = M + <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">this</span>.nsize0 = (M * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">    noGrowth = numNodes != -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (noGrowth == <span class="literal">false</span>) &#123;</span><br><span class="line">      numNodes = INIT_SIZE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.graph = <span class="keyword">new</span> <span class="title class_">NeighborArray</span>[numNodes][];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="文件中向量的存储"><a href="#文件中向量的存储" class="headerlink" title="文件中向量的存储"></a>文件中向量的存储</h2><p>向量相关的索引文件涉及四种</p><ul><li><code>*.vec</code> 存储原始向量</li><li><code>*.vemf</code> 原始向量的meta文件</li><li><code>*.vex</code> 向量索引文件, Lucene中目前用的HNSW索引</li><li><code>*.vem</code> 向量索引文件的meta文件</li></ul><ol><li>向量相关的文件写入（flush）是由<code>Lucene99HnswVectorsWriter.flush</code>实现的</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">flush</span><span class="params">(<span class="type">int</span> maxDoc, Sorter.DocMap sortMap)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"><span class="comment">// 写入原始向量</span></span><br><span class="line">flatVectorWriter.flush(maxDoc, sortMap);</span><br><span class="line"><span class="keyword">for</span> (FieldWriter&lt;?&gt; field : fields) &#123;</span><br><span class="line"><span class="keyword">if</span> (sortMap == <span class="literal">null</span>) &#123;</span><br><span class="line">writeField(field);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">writeSortingField(field, sortMap);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="2"><li>原始向量的写入 <code>Lucene99FlatVectorsWriter.flush</code></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">flush</span><span class="params">(<span class="type">int</span> maxDoc, Sorter.DocMap sortMap)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"><span class="keyword">for</span> (FieldWriter&lt;?&gt; field : fields) &#123;</span><br><span class="line"><span class="keyword">if</span> (sortMap == <span class="literal">null</span>) &#123;</span><br><span class="line">writeField(field, maxDoc);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">writeSortingField(field, maxDoc, sortMap);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">writeField</span><span class="params">(FieldWriter&lt;?&gt; fieldData, <span class="type">int</span> maxDoc)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// write vector values</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">vectorDataOffset</span> <span class="operator">=</span> vectorData.alignFilePointer(Float.BYTES);</span><br><span class="line">    <span class="keyword">switch</span> (fieldData.fieldInfo.getVectorEncoding()) &#123;</span><br><span class="line">      <span class="keyword">case</span> BYTE:</span><br><span class="line">        writeByteVectors(fieldData);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> FLOAT32:</span><br><span class="line"><span class="comment">// 写入到原始向量文件里</span></span><br><span class="line">        writeFloat32Vectors(fieldData);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">long</span> <span class="variable">vectorDataLength</span> <span class="operator">=</span> vectorData.getFilePointer() - vectorDataOffset;</span><br><span class="line"></span><br><span class="line">    writeMeta(</span><br><span class="line">        fieldData.fieldInfo, maxDoc, vectorDataOffset, vectorDataLength, fieldData.docsWithField);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">writeFloat32Vectors</span><span class="params">(FieldWriter&lt;?&gt; fieldData)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span></span><br><span class="line">        ByteBuffer.allocate(fieldData.dim * Float.BYTES).order(ByteOrder.LITTLE_ENDIAN);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将之前存在内存中的vector的list写入到vectorData对应的文件里</span></span><br><span class="line">    <span class="keyword">for</span> (Object v : fieldData.vectors) &#123;</span><br><span class="line">      buffer.asFloatBuffer().put((<span class="type">float</span>[]) v);</span><br><span class="line">      vectorData.writeBytes(buffer.array(), buffer.array().length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="3"><li>向量索引相关的写入</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 每个字段对应向量索引的写入</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">writeField</span><span class="params">(FieldWriter&lt;?&gt; fieldData)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"><span class="comment">// write graph</span></span><br><span class="line"><span class="type">long</span> <span class="variable">vectorIndexOffset</span> <span class="operator">=</span> vectorIndex.getFilePointer();</span><br><span class="line"><span class="type">OnHeapHnswGraph</span> <span class="variable">graph</span> <span class="operator">=</span> fieldData.getGraph();</span><br><span class="line"><span class="type">int</span>[][] graphLevelNodeOffsets = writeGraph(graph);</span><br><span class="line"><span class="comment">// 向量索引的长度</span></span><br><span class="line"><span class="type">long</span> <span class="variable">vectorIndexLength</span> <span class="operator">=</span> vectorIndex.getFilePointer() - vectorIndexOffset;</span><br><span class="line"></span><br><span class="line"><span class="comment">// graphLevelNodeOffsets 经过编码后会写入到vectorIndexOutput中，而不是meta文件中</span></span><br><span class="line">writeMeta(</span><br><span class="line">fieldData.fieldInfo,</span><br><span class="line">vectorIndexOffset,</span><br><span class="line">vectorIndexLength,</span><br><span class="line">fieldData.docsWithField.cardinality(),</span><br><span class="line">graph,</span><br><span class="line">graphLevelNodeOffsets);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// hnsw节点连接信息的写入</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span>[][] writeGraph(OnHeapHnswGraph graph) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"><span class="keyword">if</span> (graph == <span class="literal">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line"><span class="comment">// write vectors&#x27; neighbours on each level into the vectorIndex file</span></span><br><span class="line"><span class="type">int</span> <span class="variable">countOnLevel0</span> <span class="operator">=</span> graph.size();</span><br><span class="line"><span class="type">int</span>[][] offsets = <span class="keyword">new</span> <span class="title class_">int</span>[graph.numLevels()][];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">level</span> <span class="operator">=</span> <span class="number">0</span>; level &lt; graph.numLevels(); level++) &#123;</span><br><span class="line"><span class="comment">// graph.getNodesOnLevel获取到每个level出现的node数组</span></span><br><span class="line"><span class="type">int</span>[] sortedNodes = NodesIterator.getSortedNodes(graph.getNodesOnLevel(level));</span><br><span class="line">offsets[level] = <span class="keyword">new</span> <span class="title class_">int</span>[sortedNodes.length];</span><br><span class="line"><span class="type">int</span> <span class="variable">nodeOffsetId</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> node : sortedNodes) &#123;</span><br><span class="line"><span class="comment">// 根据node大小获取该node在level层级的节点连接信息</span></span><br><span class="line"><span class="type">NeighborArray</span> <span class="variable">neighbors</span> <span class="operator">=</span> graph.getNeighbors(level, node);</span><br><span class="line"><span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> neighbors.size();</span><br><span class="line"><span class="comment">// Write size in VInt as the neighbors list is typically small</span></span><br><span class="line"><span class="type">long</span> <span class="variable">offsetStart</span> <span class="operator">=</span> vectorIndex.getFilePointer();</span><br><span class="line"><span class="comment">// 写入这个节点对应的连接数</span></span><br><span class="line">vectorIndex.writeVInt(size);</span><br><span class="line"><span class="comment">// Destructively modify; it&#x27;s ok we are discarding it after this</span></span><br><span class="line"><span class="type">int</span>[] nnodes = neighbors.node();</span><br><span class="line"><span class="comment">// 根据node大小做升序排序，方便后面做差值压缩编码</span></span><br><span class="line">Arrays.sort(nnodes, <span class="number">0</span>, size);</span><br><span class="line"><span class="comment">// Now that we have sorted, do delta encoding to minimize the required bits to store the</span></span><br><span class="line"><span class="comment">// information</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> size - <span class="number">1</span>; i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line"><span class="keyword">assert</span> nnodes[i] &lt; countOnLevel0 : <span class="string">&quot;node too large: &quot;</span> + nnodes[i] + <span class="string">&quot;&gt;=&quot;</span> + countOnLevel0;</span><br><span class="line">nnodes[i] -= nnodes[i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 顺序写入经过差值压缩后的编码，nnodes[0]是原值</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">vectorIndex.writeVInt(nnodes[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将这个节点的连接信息的长度记录到offset表中</span></span><br><span class="line">offsets[level][nodeOffsetId++] =</span><br><span class="line">Math.toIntExact(vectorIndex.getFilePointer() - offsetStart);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> offsets;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 图索引meta信息的写入</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">writeMeta</span><span class="params">(</span></span><br><span class="line"><span class="params">      FieldInfo field,</span></span><br><span class="line"><span class="params">      <span class="type">long</span> vectorIndexOffset,</span></span><br><span class="line"><span class="params">      <span class="type">long</span> vectorIndexLength,</span></span><br><span class="line"><span class="params">      <span class="type">int</span> count,</span></span><br><span class="line"><span class="params">      HnswGraph graph,</span></span><br><span class="line"><span class="params">      <span class="type">int</span>[][] graphLevelNodeOffsets)</span></span><br><span class="line">      <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    meta.writeInt(field.number);</span><br><span class="line"><span class="comment">// 向量的编码FLOAT or BYTES</span></span><br><span class="line">    meta.writeInt(field.getVectorEncoding().ordinal());</span><br><span class="line"><span class="comment">// 向量距离的计算方式</span></span><br><span class="line">    meta.writeInt(field.getVectorSimilarityFunction().ordinal());</span><br><span class="line"><span class="comment">// 向量索引的开始位置</span></span><br><span class="line">    meta.writeVLong(vectorIndexOffset);</span><br><span class="line"><span class="comment">// 向量索引的总长度</span></span><br><span class="line">    meta.writeVLong(vectorIndexLength);</span><br><span class="line"><span class="comment">// 向量的维度</span></span><br><span class="line">    meta.writeVInt(field.getVectorDimension());</span><br><span class="line"><span class="comment">// 向量的数量</span></span><br><span class="line">    meta.writeInt(count);</span><br><span class="line">    meta.writeVInt(M);</span><br><span class="line">    <span class="comment">// write graph nodes on each level</span></span><br><span class="line">    <span class="keyword">if</span> (graph == <span class="literal">null</span>) &#123;</span><br><span class="line">      meta.writeVInt(<span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// HNSW索引的层级</span></span><br><span class="line">      meta.writeVInt(graph.numLevels());</span><br><span class="line">      <span class="type">long</span> <span class="variable">valueCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">level</span> <span class="operator">=</span> <span class="number">0</span>; level &lt; graph.numLevels(); level++) &#123;</span><br><span class="line"><span class="comment">// 获取每个层级的节点</span></span><br><span class="line">        <span class="type">NodesIterator</span> <span class="variable">nodesOnLevel</span> <span class="operator">=</span> graph.getNodesOnLevel(level);</span><br><span class="line">        valueCount += nodesOnLevel.size();</span><br><span class="line">        <span class="keyword">if</span> (level &gt; <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="comment">// 非level0 的才需要写入meta</span></span><br><span class="line">          <span class="type">int</span>[] nol = <span class="keyword">new</span> <span class="title class_">int</span>[nodesOnLevel.size()];</span><br><span class="line">          <span class="type">int</span> <span class="variable">numberConsumed</span> <span class="operator">=</span> nodesOnLevel.consume(nol);</span><br><span class="line">  <span class="comment">// 方便后面差值编码</span></span><br><span class="line">          Arrays.sort(nol);</span><br><span class="line">          <span class="keyword">assert</span> numberConsumed == nodesOnLevel.size();</span><br><span class="line">  <span class="comment">// 写入该层级的节点数</span></span><br><span class="line">          meta.writeVInt(nol.length); <span class="comment">// number of nodes on a level</span></span><br><span class="line">          <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> nodesOnLevel.size() - <span class="number">1</span>; i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">            nol[i] -= nol[i - <span class="number">1</span>];</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">for</span> (<span class="type">int</span> n : nol) &#123;</span><br><span class="line">            <span class="keyword">assert</span> n &gt;= <span class="number">0</span> : <span class="string">&quot;delta encoding for nodes failed; expected nodes to be sorted&quot;</span>;</span><br><span class="line"><span class="comment">// 写入该层级的节点压缩编码</span></span><br><span class="line">            meta.writeVInt(n);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">assert</span> nodesOnLevel.size() == count : <span class="string">&quot;Level 0 expects to have all nodes&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> vectorIndex.getFilePointer();</span><br><span class="line">  <span class="comment">// 记录vectorIndex当前的文件位置（已经写完graph的连接信息的位置）</span></span><br><span class="line">      meta.writeLong(start);</span><br><span class="line">      meta.writeVInt(DIRECT_MONOTONIC_BLOCK_SHIFT);</span><br><span class="line">  <span class="comment">// graphLevelNodeOffsets的压缩编码, valueCount是说有level的总连接点的数量</span></span><br><span class="line">  <span class="comment">// graphLevelNodeOffsets写入的也是VectorIndex</span></span><br><span class="line">      <span class="keyword">final</span> <span class="type">DirectMonotonicWriter</span> <span class="variable">memoryOffsetsWriter</span> <span class="operator">=</span></span><br><span class="line">          DirectMonotonicWriter.getInstance(</span><br><span class="line">              meta, vectorIndex, valueCount, DIRECT_MONOTONIC_BLOCK_SHIFT);</span><br><span class="line">      <span class="type">long</span> <span class="variable">cumulativeOffsetSum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span>[] levelOffsets : graphLevelNodeOffsets) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> v : levelOffsets) &#123;</span><br><span class="line">          memoryOffsetsWriter.add(cumulativeOffsetSum);</span><br><span class="line">          cumulativeOffsetSum += v;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      memoryOffsetsWriter.finish();</span><br><span class="line">      meta.writeLong(vectorIndex.getFilePointer() - start);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ol><li>Lucene中对整个向量相关的存储整体是分成两部分（原始向量和HNSW向量索引）.</li><li>在存储向量的索引过程中整体分成两个步骤<ul><li>第一步存储各个层级节点的连接信息（graph），通过对连接节点的排序，存储差值对连接信息进行了压缩，在写入节点信息的过程过程中，会生成offset表，表示了每个层级中节点对应的连接信息的offset</li><li>第二步存储第一步生成的offset表，利用了DirectMonotonicWriter 进行了压缩处理</li></ul></li><li>整体可以看到，Lucene并没有存储索引的原始信息，而是经过一系列精巧的压缩处理，减少了磁盘占用，后面的文章中会深入探讨这种压缩处理的利弊</li></ol><h1 id="Lucene在Merge的过程中如何处理HNSW索引的"><a href="#Lucene在Merge的过程中如何处理HNSW索引的" class="headerlink" title="Lucene在Merge的过程中如何处理HNSW索引的"></a>Lucene在Merge的过程中如何处理HNSW索引的</h1><p>上文介绍的内容都是Lucene在生成一个Segment的过程中对向量及其索引的计算和存储，在实际的系统中，比如Elasticsearch一般都会有多个Lucene Segment的生成，Lucene本身也会对多个小Segment进行Merge, 我们需要知道在merge的过程中Lucene是如何处理向量相关的索引的</p><p>本文使用<code>IndexWriter.forceMerge(1)</code>触发merge操作，得到下文的调用栈</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">mergeOneField</span><span class="params">(FieldInfo fieldInfo, MergeState mergeState)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">CloseableRandomVectorScorerSupplier</span> <span class="variable">scorerSupplier</span> <span class="operator">=</span></span><br><span class="line">        flatVectorWriter.mergeOneFieldToIndex(fieldInfo, mergeState);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="type">long</span> <span class="variable">vectorIndexOffset</span> <span class="operator">=</span> vectorIndex.getFilePointer();</span><br><span class="line">      <span class="comment">// build the graph using the temporary vector data</span></span><br><span class="line">      <span class="comment">// we use Lucene99HnswVectorsReader.DenseOffHeapVectorValues for the graph construction</span></span><br><span class="line">      <span class="comment">// doesn&#x27;t need to know docIds</span></span><br><span class="line">      <span class="comment">// <span class="doctag">TODO:</span> separate random access vector values from DocIdSetIterator?</span></span><br><span class="line">      <span class="type">OnHeapHnswGraph</span> <span class="variable">graph</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">      <span class="type">int</span>[][] vectorIndexNodeOffsets = <span class="literal">null</span>;</span><br><span class="line">      <span class="keyword">if</span> (scorerSupplier.totalVectorCount() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// build graph</span></span><br><span class="line"><span class="comment">// Merger是IncrementalHnswGraphMerger</span></span><br><span class="line">        <span class="type">HnswGraphMerger</span> <span class="variable">merger</span> <span class="operator">=</span> createGraphMerger(fieldInfo, scorerSupplier);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; mergeState.liveDocs.length; i++) &#123;</span><br><span class="line">  <span class="comment">// 这里会选出节点数最大的graph，作为merge过程中初始的graph以减少图的构建</span></span><br><span class="line">          merger.addReader(</span><br><span class="line">              mergeState.knnVectorsReaders[i], mergeState.docMaps[i], mergeState.liveDocs[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> DocIdSetIterator mergedVectorIterator;</span><br><span class="line">        <span class="keyword">switch</span> (fieldInfo.getVectorEncoding()) &#123;</span><br><span class="line">          <span class="keyword">case</span> BYTE:</span><br><span class="line">            mergedVectorIterator =</span><br><span class="line">                KnnVectorsWriter.MergedVectorValues.mergeByteVectorValues(fieldInfo, mergeState);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> FLOAT32:</span><br><span class="line"> <span class="comment">// 获取每个Segment对应的原始向量，使用 OffHeapFloatVectorValues.load 获取每个原始向量</span></span><br><span class="line">            mergedVectorIterator =</span><br><span class="line">                KnnVectorsWriter.MergedVectorValues.mergeFloatVectorValues(fieldInfo, mergeState);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(</span><br><span class="line">                <span class="string">&quot;Unsupported vector encoding: &quot;</span> + fieldInfo.getVectorEncoding());</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// 多个Segment中的HNSW graph合并成一个OnHeapHnswGraph</span></span><br><span class="line">        graph =</span><br><span class="line">            merger.merge(</span><br><span class="line">                mergedVectorIterator,</span><br><span class="line">                segmentWriteState.infoStream,</span><br><span class="line">                scorerSupplier.totalVectorCount());</span><br><span class="line"><span class="comment">// 这里的写入和上文中的处理是一致的</span></span><br><span class="line">        vectorIndexNodeOffsets = writeGraph(graph);</span><br><span class="line">      &#125;</span><br><span class="line">  <span class="comment">// 这里同上文也是一致的</span></span><br><span class="line">      <span class="type">long</span> <span class="variable">vectorIndexLength</span> <span class="operator">=</span> vectorIndex.getFilePointer() - vectorIndexOffset;</span><br><span class="line">      writeMeta(</span><br><span class="line">          fieldInfo,</span><br><span class="line">          vectorIndexOffset,</span><br><span class="line">          vectorIndexLength,</span><br><span class="line">          scorerSupplier.totalVectorCount(),</span><br><span class="line">          graph,</span><br><span class="line">          vectorIndexNodeOffsets);</span><br><span class="line">      success = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (success) &#123;</span><br><span class="line">        IOUtils.close(scorerSupplier);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        IOUtils.closeWhileHandlingException(scorerSupplier);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 选出最大的graph 作为初始graph</span></span><br><span class="line"><span class="keyword">public</span> IncrementalHnswGraphMerger <span class="title function_">addReader</span><span class="params">(</span></span><br><span class="line"><span class="params">      KnnVectorsReader reader, MergeState.DocMap docMap, Bits liveDocs)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">KnnVectorsReader</span> <span class="variable">currKnnVectorsReader</span> <span class="operator">=</span> reader;</span><br><span class="line">    <span class="keyword">if</span> (reader <span class="keyword">instanceof</span> PerFieldKnnVectorsFormat.FieldsReader) &#123;</span><br><span class="line">      currKnnVectorsReader =</span><br><span class="line">          ((PerFieldKnnVectorsFormat.FieldsReader) reader).getFieldReader(fieldInfo.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!(currKnnVectorsReader <span class="keyword">instanceof</span> HnswGraphProvider) || !noDeletes(liveDocs)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">candidateVectorCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">switch</span> (fieldInfo.getVectorEncoding()) &#123;</span><br><span class="line">      <span class="keyword">case</span> BYTE:</span><br><span class="line">        <span class="type">ByteVectorValues</span> <span class="variable">byteVectorValues</span> <span class="operator">=</span></span><br><span class="line">            currKnnVectorsReader.getByteVectorValues(fieldInfo.name);</span><br><span class="line">        <span class="keyword">if</span> (byteVectorValues == <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        candidateVectorCount = byteVectorValues.size();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> FLOAT32:</span><br><span class="line">        <span class="type">FloatVectorValues</span> <span class="variable">vectorValues</span> <span class="operator">=</span> currKnnVectorsReader.getFloatVectorValues(fieldInfo.name);</span><br><span class="line">        <span class="keyword">if</span> (vectorValues == <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        candidateVectorCount = vectorValues.size();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(</span><br><span class="line">            <span class="string">&quot;Unexpected vector encoding: &quot;</span> + fieldInfo.getVectorEncoding());</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 选取最大节点数（向量数）的graph作为初始化的graph，这里使用initReader代替，后续使用initReader读取graph的时候就以这个graph作为初始graph</span></span><br><span class="line">    <span class="keyword">if</span> (candidateVectorCount &gt; initGraphSize) &#123;</span><br><span class="line">      initReader = currKnnVectorsReader;</span><br><span class="line">      initDocMap = docMap;</span><br><span class="line">      initGraphSize = candidateVectorCount;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理merge的入口</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> OnHeapHnswGraph <span class="title function_">merge</span><span class="params">(</span></span><br><span class="line"><span class="params">      DocIdSetIterator mergedVectorIterator, InfoStream infoStream, <span class="type">int</span> maxOrd)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"><span class="comment">// 创建 InitializedHnswGraphBuilder 对象, 同时会将最大的初始化graph load进内存变成`OnHeapHnswGraph`</span></span><br><span class="line">    <span class="type">HnswBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> createBuilder(mergedVectorIterator, maxOrd);</span><br><span class="line">    builder.setInfoStream(infoStream);</span><br><span class="line">    <span class="keyword">return</span> builder.build(maxOrd);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化graph的 init过程</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> OnHeapHnswGraph <span class="title function_">initGraph</span><span class="params">(</span></span><br><span class="line"><span class="params">      <span class="type">int</span> M, HnswGraph initializerGraph, <span class="type">int</span>[] newOrdMap, <span class="type">int</span> totalNumberOfVectors)</span></span><br><span class="line">      <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"><span class="comment">// 用新的总向量数量和代替之前的节点数</span></span><br><span class="line">    <span class="type">OnHeapHnswGraph</span> <span class="variable">hnsw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OnHeapHnswGraph</span>(M, totalNumberOfVectors);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">level</span> <span class="operator">=</span> initializerGraph.numLevels() - <span class="number">1</span>; level &gt;= <span class="number">0</span>; level--) &#123;</span><br><span class="line">      HnswGraph.<span class="type">NodesIterator</span> <span class="variable">it</span> <span class="operator">=</span> initializerGraph.getNodesOnLevel(level);</span><br><span class="line">      <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">oldOrd</span> <span class="operator">=</span> it.nextInt();</span><br><span class="line">        <span class="type">int</span> <span class="variable">newOrd</span> <span class="operator">=</span> newOrdMap[oldOrd];</span><br><span class="line">        hnsw.addNode(level, newOrd);</span><br><span class="line">        hnsw.trySetNewEntryNode(newOrd, level);</span><br><span class="line">        <span class="type">NeighborArray</span> <span class="variable">newNeighbors</span> <span class="operator">=</span> hnsw.getNeighbors(level, newOrd);</span><br><span class="line">        initializerGraph.seek(level, oldOrd);</span><br><span class="line"><span class="comment">// 直接复制之前的连接信息</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">oldNeighbor</span> <span class="operator">=</span> initializerGraph.nextNeighbor();</span><br><span class="line">            oldNeighbor != NO_MORE_DOCS;</span><br><span class="line">            oldNeighbor = initializerGraph.nextNeighbor()) &#123;</span><br><span class="line">          <span class="type">int</span> <span class="variable">newNeighbor</span> <span class="operator">=</span> newOrdMap[oldNeighbor];</span><br><span class="line">          <span class="comment">// we will compute these scores later when we need to pop out the non-diverse nodes</span></span><br><span class="line">          newNeighbors.addOutOfOrder(newNeighbor, Float.NaN);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hnsw;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// merge过程中处理Vector相关的代码</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">addVectors</span><span class="params">(<span class="type">int</span> minOrd, <span class="type">int</span> maxOrd)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.nanoTime(), t = start;</span><br><span class="line">    <span class="keyword">if</span> (infoStream.isEnabled(HNSW_COMPONENT)) &#123;</span><br><span class="line">      infoStream.message(HNSW_COMPONENT, <span class="string">&quot;addVectors [&quot;</span> + minOrd + <span class="string">&quot; &quot;</span> + maxOrd + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">node</span> <span class="operator">=</span> minOrd; node &lt; maxOrd; node++) &#123;</span><br><span class="line"><span class="comment">// 添加新的node到graph中</span></span><br><span class="line">      addGraphNode(node);</span><br><span class="line">      <span class="keyword">if</span> ((node % <span class="number">10000</span> == <span class="number">0</span>) &amp;&amp; infoStream.isEnabled(HNSW_COMPONENT)) &#123;</span><br><span class="line">        t = printGraphBuildStatus(node, start, t);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// 实际的addGraphNode 调用，`InitializedHnswGraphBuilder.addGraphNode`</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addGraphNode</span><span class="params">(<span class="type">int</span> node)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"><span class="comment">// merge的时候会选出节点数最多的索引作为初始的graph, 初始graph的所有信息都是构建好的，所以就不要添加了</span></span><br><span class="line">    <span class="keyword">if</span> (initializedNodes.get(node)) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 向当前的graph中添加节点，执行标准hnsw构建流程</span></span><br><span class="line">    <span class="built_in">super</span>.addGraphNode(node);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><ul><li>merge过程中，核心点是选出一个最大的graph作为初始化graph，然后将其他segment的hsnw graph 写入到这个初始化graph中（省去了一些计算）,不过由于其他segment的graph的节点仍然需要重新计算, 导致merge的cpu成本也比较高</li><li>merge过程中，所有的向量都会被读取到<code>OnHeapHnswGraph</code>中，所以内存压力比较高</li><li>对于HNSW 索引来说，merge一个成本高昂的操作</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;主要内容&quot;&gt;&lt;a href=&quot;#主要内容&quot; class=&quot;headerlink&quot; title=&quot;主要内容&quot;&gt;&lt;/a&gt;主要内容&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;梳理IndexWriter.addDocuments 和 IndexWriter.commit的调用栈&lt;/li&gt;</summary>
      
    
    
    
    
    <category term="algorithm hnsw 向量数据库 Lucene Indexing" scheme="https://skyitachi.github.io/tags/algorithm-hnsw-%E5%90%91%E9%87%8F%E6%95%B0%E6%8D%AE%E5%BA%93-Lucene-Indexing/"/>
    
  </entry>
  
  <entry>
    <title>Lucene中Term相关的倒排文件是如何生成的</title>
    <link href="https://skyitachi.github.io/2024/08/04/Lucene%E4%B8%ADTerm%E7%9B%B8%E5%85%B3%E7%9A%84%E5%80%92%E6%8E%92%E6%96%87%E4%BB%B6%E6%98%AF%E5%A6%82%E4%BD%95%E7%94%9F%E6%88%90%E7%9A%84/"/>
    <id>https://skyitachi.github.io/2024/08/04/Lucene%E4%B8%ADTerm%E7%9B%B8%E5%85%B3%E7%9A%84%E5%80%92%E6%8E%92%E6%96%87%E4%BB%B6%E6%98%AF%E5%A6%82%E4%BD%95%E7%94%9F%E6%88%90%E7%9A%84/</id>
    <published>2024-08-03T16:00:00.000Z</published>
    <updated>2024-08-03T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Lucene中Term代表了一个原子粒度的索引和搜索单位，ES中keyword和text类型经过分词之后都会以Term的形式被Lucene索引并落入磁盘持久化，与Term相关的索引文件有Term Dictionary（.tim），Term Index(.tip), 还有与之关联的倒排索引相关的文件(.doc, .pos, .pay)，本文重点关注在如何将内存中已经生成好的Term相关的数据结构落入磁盘的这一过程.</p><p>本文以<a href="https://github.com/apache/lucene.git">Lucene</a> tag <code>releases/lucene/9.1.0</code> 代码为准, commit: 5b522487ba8e0f1002b50a136817ca037aec9686, 只关注posting list中docId的写入，freq, position和payload 将会忽略</p><h1 id="调用链路"><a href="#调用链路" class="headerlink" title="调用链路"></a>调用链路</h1><p><img src="/../../imgs/lucene.jpg" alt="function"></p><h1 id="相关源码分析"><a href="#相关源码分析" class="headerlink" title="相关源码分析"></a>相关源码分析</h1><p>主要分析<code>Lucene90BlockTreeTermsWriter</code>的写入过程, 核心函数是<code>TermsWriter.write</code></p><ol><li>Lucene90BlockTreeTermsWriter.write -&gt; TermsWriter.write</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Lucene90BlockTreeTermsWriter.TermsWriter.write</span></span><br><span class="line"><span class="comment">// TermsEnum 代表了这个Field关联的所有terms</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(BytesRef text, TermsEnum termsEnum, NormsProducer norms)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 首先写入倒排索引相关的问题, postingWriter是Lucene90PostingWriter的实例, 包括了docId和skip List相关的数据</span></span><br><span class="line"><span class="type">BlockTermState</span> <span class="variable">state</span> <span class="operator">=</span> postingsWriter.writeTerm(text, termsEnum, docsSeen, norms);</span><br><span class="line"><span class="keyword">if</span> (state != <span class="literal">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">assert</span> state.docFreq != <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">assert</span> fieldInfo.getIndexOptions() == IndexOptions.DOCS</span><br><span class="line">                || state.totalTermFreq &gt;= state.docFreq</span><br><span class="line">            : <span class="string">&quot;postingsWriter=&quot;</span> + postingsWriter;</span><br><span class="line">        pushTerm(text);</span><br><span class="line"></span><br><span class="line">        <span class="type">PendingTerm</span> <span class="variable">term</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PendingTerm</span>(text, state);</span><br><span class="line">        pending.add(term);</span><br><span class="line">        <span class="comment">// if (DEBUG) System.out.println(&quot;    add pending term = &quot; + text + &quot; pending.size()=&quot; +</span></span><br><span class="line">        <span class="comment">// pending.size());</span></span><br><span class="line"></span><br><span class="line">        sumDocFreq += state.docFreq;</span><br><span class="line">        sumTotalTermFreq += state.totalTermFreq;</span><br><span class="line">        numTerms++;</span><br><span class="line">        <span class="keyword">if</span> (firstPendingTerm == <span class="literal">null</span>) &#123;</span><br><span class="line">          firstPendingTerm = term;</span><br><span class="line">        &#125;</span><br><span class="line">        lastPendingTerm = term;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><code>PushPostingsWriterBase.writeTerm</code> 抽象了writeTerm的整体流程，<code>Lucene90PostingWriter</code> extends <code>PushPostingsWriterBase</code></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">final</span> BlockTermState <span class="title function_">writeTerm</span><span class="params">(</span></span><br><span class="line"><span class="params">      BytesRef term, TermsEnum termsEnum, FixedBitSet docsSeen, NormsProducer norms)</span></span><br><span class="line">      <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"><span class="comment">// 本文不涉及</span></span><br><span class="line">    NumericDocValues normValues;</span><br><span class="line">    <span class="keyword">if</span> (fieldInfo.hasNorms() == <span class="literal">false</span>) &#123;</span><br><span class="line">      normValues = <span class="literal">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      normValues = norms.getNorms(fieldInfo);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 写入这个Term的一些初始化，包括lastDocId和skipList的初始化, 调用的实例方法是Lucene90PostingWriter.startTerm</span></span><br><span class="line">    startTerm(normValues);</span><br><span class="line"><span class="comment">// 从term中取出对应的posting list的iterator，本文主要关注posting中的docId</span></span><br><span class="line">    postingsEnum = termsEnum.postings(postingsEnum, enumFlags);</span><br><span class="line">    <span class="keyword">assert</span> postingsEnum != <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">docFreq</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">long</span> <span class="variable">totalTermFreq</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">      <span class="type">int</span> <span class="variable">docID</span> <span class="operator">=</span> postingsEnum.nextDoc();</span><br><span class="line">      <span class="keyword">if</span> (docID == PostingsEnum.NO_MORE_DOCS) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      docFreq++;</span><br><span class="line">      docsSeen.set(docID);</span><br><span class="line">      <span class="type">int</span> freq;</span><br><span class="line">      <span class="keyword">if</span> (writeFreqs) &#123;</span><br><span class="line">        freq = postingsEnum.freq();</span><br><span class="line">        totalTermFreq += freq;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        freq = -<span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  <span class="comment">// posting相关的核心函数, Lucene90PostingsWriter.startDoc</span></span><br><span class="line">      startDoc(docID, freq);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (writePositions) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; freq; i++) &#123;</span><br><span class="line">          <span class="type">int</span> <span class="variable">pos</span> <span class="operator">=</span> postingsEnum.nextPosition();</span><br><span class="line">          <span class="type">BytesRef</span> <span class="variable">payload</span> <span class="operator">=</span> writePayloads ? postingsEnum.getPayload() : <span class="literal">null</span>;</span><br><span class="line">          <span class="type">int</span> startOffset;</span><br><span class="line">          <span class="type">int</span> endOffset;</span><br><span class="line">          <span class="keyword">if</span> (writeOffsets) &#123;</span><br><span class="line">            startOffset = postingsEnum.startOffset();</span><br><span class="line">            endOffset = postingsEnum.endOffset();</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            startOffset = -<span class="number">1</span>;</span><br><span class="line">            endOffset = -<span class="number">1</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          addPosition(pos, payload, startOffset, endOffset);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      finishDoc();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (docFreq == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="type">BlockTermState</span> <span class="variable">state</span> <span class="operator">=</span> newTermState();</span><br><span class="line">      state.docFreq = docFreq;</span><br><span class="line">      state.totalTermFreq = writeFreqs ? totalTermFreq : -<span class="number">1</span>;</span><br><span class="line">      finishTerm(state);</span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><code>Lucene90PostingsWriter.startDoc</code></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">startDoc</span><span class="params">(<span class="type">int</span> docID, <span class="type">int</span> termDocFreq)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"><span class="comment">// 为新的posting block创建(初始化)skipList </span></span><br><span class="line">   <span class="keyword">if</span> (lastBlockDocID != -<span class="number">1</span> &amp;&amp; docBufferUpto == <span class="number">0</span>) &#123;</span><br><span class="line">     skipWriter.bufferSkip(</span><br><span class="line">         lastBlockDocID,</span><br><span class="line">         competitiveFreqNormAccumulator,</span><br><span class="line">         docCount,</span><br><span class="line">         lastBlockPosFP,</span><br><span class="line">         lastBlockPayFP,</span><br><span class="line">         lastBlockPosBufferUpto,</span><br><span class="line">         lastBlockPayloadByteUpto);</span><br><span class="line">     competitiveFreqNormAccumulator.clear();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// posting 存储的docId 都是差值，且要求所有docId都是严格升序排列，隐含条件docId不会重复(相同Term在posting中只会出现一次)</span></span><br><span class="line">   <span class="keyword">final</span> <span class="type">int</span> <span class="variable">docDelta</span> <span class="operator">=</span> docID - lastDocID;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (docID &lt; <span class="number">0</span> || (docCount &gt; <span class="number">0</span> &amp;&amp; docDelta &lt;= <span class="number">0</span>)) &#123;</span><br><span class="line">     <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">CorruptIndexException</span>(</span><br><span class="line">         <span class="string">&quot;docs out of order (&quot;</span> + docID + <span class="string">&quot; &lt;= &quot;</span> + lastDocID + <span class="string">&quot; )&quot;</span>, docOut);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   docDeltaBuffer[docBufferUpto] = docDelta;</span><br><span class="line">   <span class="keyword">if</span> (writeFreqs) &#123;</span><br><span class="line">     freqBuffer[docBufferUpto] = termDocFreq;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">// block内docCount的计数</span></span><br><span class="line">   docBufferUpto++;</span><br><span class="line"><span class="comment">// 整体的docCount 计数</span></span><br><span class="line">   docCount++;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以128的BLOCK_SIZE写入docOut(.doc)文件中</span></span><br><span class="line">   <span class="keyword">if</span> (docBufferUpto == BLOCK_SIZE) &#123;</span><br><span class="line">     pforUtil.encode(docDeltaBuffer, docOut);</span><br><span class="line">     <span class="keyword">if</span> (writeFreqs) &#123;</span><br><span class="line">       pforUtil.encode(freqBuffer, docOut);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// <span class="doctag">NOTE:</span> don&#x27;t set docBufferUpto back to 0 here;</span></span><br><span class="line">     <span class="comment">// finishDoc will do so (because it needs to see that</span></span><br><span class="line">     <span class="comment">// the block was filled so it can save skip data)</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新lastDocID</span></span><br><span class="line">   lastDocID = docID;</span><br><span class="line">   lastPosition = <span class="number">0</span>;</span><br><span class="line">   lastStartOffset = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">   <span class="type">long</span> norm;</span><br><span class="line">   <span class="keyword">if</span> (fieldHasNorms) &#123;</span><br><span class="line">     <span class="type">boolean</span> <span class="variable">found</span> <span class="operator">=</span> norms.advanceExact(docID);</span><br><span class="line">     <span class="keyword">if</span> (found == <span class="literal">false</span>) &#123;</span><br><span class="line">       <span class="comment">// This can happen if indexing hits a problem after adding a doc to the</span></span><br><span class="line">       <span class="comment">// postings but before buffering the norm. Such documents are written</span></span><br><span class="line">       <span class="comment">// deleted and will go away on the first merge.</span></span><br><span class="line">       norm = <span class="number">1L</span>;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       norm = norms.longValue();</span><br><span class="line">       <span class="keyword">assert</span> norm != <span class="number">0</span> : docID;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     norm = <span class="number">1L</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   competitiveFreqNormAccumulator.add(writeFreqs ? termDocFreq : <span class="number">1</span>, norm);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><ol start="4"><li><code>Lucene90PostingsWriter.finishDoc</code></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">finishDoc</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">   <span class="comment">// Since we don&#x27;t know df for current term, we had to buffer</span></span><br><span class="line">   <span class="comment">// those skip data for each block, and when a new doc comes,</span></span><br><span class="line">   <span class="comment">// write them to skip file.</span></span><br><span class="line">   <span class="keyword">if</span> (docBufferUpto == BLOCK_SIZE) &#123;</span><br><span class="line">  <span class="comment">// skip data是针对block的，block对应的docId 是该block中最大的docId</span></span><br><span class="line">     lastBlockDocID = lastDocID;</span><br><span class="line">     <span class="keyword">if</span> (posOut != <span class="literal">null</span>) &#123;</span><br><span class="line">       <span class="keyword">if</span> (payOut != <span class="literal">null</span>) &#123;</span><br><span class="line">         lastBlockPayFP = payOut.getFilePointer();</span><br><span class="line">       &#125;</span><br><span class="line">       lastBlockPosFP = posOut.getFilePointer();</span><br><span class="line">       lastBlockPosBufferUpto = posBufferUpto;</span><br><span class="line">       lastBlockPayloadByteUpto = payloadByteUpto;</span><br><span class="line">     &#125;</span><br><span class="line">     docBufferUpto = <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="5"><li><code>Lucene90PostingsWriter.finishTerm</code></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">finishTerm</span><span class="params">(BlockTermState _state)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">IntBlockTermState</span> <span class="variable">state</span> <span class="operator">=</span> (IntBlockTermState) _state;</span><br><span class="line">    <span class="keyword">assert</span> state.docFreq &gt; <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> wasteful we are counting this (counting # docs</span></span><br><span class="line">    <span class="comment">// for this term) in two places?</span></span><br><span class="line">    <span class="keyword">assert</span> state.docFreq == docCount : state.docFreq + <span class="string">&quot; vs &quot;</span> + docCount;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// docFreq == 1, don&#x27;t write the single docid/freq to a separate file along with a pointer to</span></span><br><span class="line">    <span class="comment">// it.</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> singletonDocID;</span><br><span class="line">    <span class="keyword">if</span> (state.docFreq == <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="comment">// pulse the singleton docid into the term dictionary, freq is implicitly totalTermFreq</span></span><br><span class="line">      singletonDocID = (<span class="type">int</span>) docDeltaBuffer[<span class="number">0</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      singletonDocID = -<span class="number">1</span>;</span><br><span class="line">      <span class="comment">// vInt encode the remaining doc deltas and freqs:</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; docBufferUpto; i++) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">docDelta</span> <span class="operator">=</span> (<span class="type">int</span>) docDeltaBuffer[i];</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">freq</span> <span class="operator">=</span> (<span class="type">int</span>) freqBuffer[i];</span><br><span class="line">        <span class="keyword">if</span> (!writeFreqs) &#123;</span><br><span class="line">  <span class="comment">// 将最后一个未满BLOCK_SIZE的block的docDelta 写入到doc文件中</span></span><br><span class="line">          docOut.writeVInt(docDelta);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (freq == <span class="number">1</span>) &#123;</span><br><span class="line">          docOut.writeVInt((docDelta &lt;&lt; <span class="number">1</span>) | <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          docOut.writeVInt(docDelta &lt;&lt; <span class="number">1</span>);</span><br><span class="line">          docOut.writeVInt(freq);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">long</span> lastPosBlockOffset;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (writePositions) &#123;</span><br><span class="line">      <span class="comment">// totalTermFreq is just total number of positions(or payloads, or offsets)</span></span><br><span class="line">      <span class="comment">// associated with current term.</span></span><br><span class="line">      <span class="keyword">assert</span> state.totalTermFreq != -<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span> (state.totalTermFreq &gt; BLOCK_SIZE) &#123;</span><br><span class="line">        <span class="comment">// record file offset for last pos in last block</span></span><br><span class="line">        lastPosBlockOffset = posOut.getFilePointer() - posStartFP;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        lastPosBlockOffset = -<span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (posBufferUpto &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> should we send offsets/payloads to</span></span><br><span class="line">        <span class="comment">// .pay...?  seems wasteful (have to store extra</span></span><br><span class="line">        <span class="comment">// vLong for low (&lt; BLOCK_SIZE) DF terms = vast vast</span></span><br><span class="line">        <span class="comment">// majority)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// vInt encode the remaining positions/payloads/offsets:</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">lastPayloadLength</span> <span class="operator">=</span> -<span class="number">1</span>; <span class="comment">// force first payload length to be written</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">lastOffsetLength</span> <span class="operator">=</span> -<span class="number">1</span>; <span class="comment">// force first offset length to be written</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">payloadBytesReadUpto</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; posBufferUpto; i++) &#123;</span><br><span class="line">          <span class="keyword">final</span> <span class="type">int</span> <span class="variable">posDelta</span> <span class="operator">=</span> (<span class="type">int</span>) posDeltaBuffer[i];</span><br><span class="line">          <span class="keyword">if</span> (writePayloads) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">payloadLength</span> <span class="operator">=</span> (<span class="type">int</span>) payloadLengthBuffer[i];</span><br><span class="line">            <span class="keyword">if</span> (payloadLength != lastPayloadLength) &#123;</span><br><span class="line">              lastPayloadLength = payloadLength;</span><br><span class="line">              posOut.writeVInt((posDelta &lt;&lt; <span class="number">1</span>) | <span class="number">1</span>);</span><br><span class="line">              posOut.writeVInt(payloadLength);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              posOut.writeVInt(posDelta &lt;&lt; <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (payloadLength != <span class="number">0</span>) &#123;</span><br><span class="line">              posOut.writeBytes(payloadBytes, payloadBytesReadUpto, payloadLength);</span><br><span class="line">              payloadBytesReadUpto += payloadLength;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            posOut.writeVInt(posDelta);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (writeOffsets) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">delta</span> <span class="operator">=</span> (<span class="type">int</span>) offsetStartDeltaBuffer[i];</span><br><span class="line">            <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> (<span class="type">int</span>) offsetLengthBuffer[i];</span><br><span class="line">            <span class="keyword">if</span> (length == lastOffsetLength) &#123;</span><br><span class="line">              posOut.writeVInt(delta &lt;&lt; <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              posOut.writeVInt(delta &lt;&lt; <span class="number">1</span> | <span class="number">1</span>);</span><br><span class="line">              posOut.writeVInt(length);</span><br><span class="line">              lastOffsetLength = length;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (writePayloads) &#123;</span><br><span class="line">          <span class="keyword">assert</span> payloadBytesReadUpto == payloadByteUpto;</span><br><span class="line">          payloadByteUpto = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      lastPosBlockOffset = -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> skipOffset;</span><br><span class="line"><span class="comment">// 写入skipList的data, 可以看到skipList的数据是写完posting之后再写入的</span></span><br><span class="line">    <span class="keyword">if</span> (docCount &gt; BLOCK_SIZE) &#123;</span><br><span class="line">      skipOffset = skipWriter.writeSkip(docOut) - docStartFP;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      skipOffset = -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    state.docStartFP = docStartFP;</span><br><span class="line">    state.posStartFP = posStartFP;</span><br><span class="line">    state.payStartFP = payStartFP;</span><br><span class="line">    state.singletonDocID = singletonDocID;</span><br><span class="line">    state.skipOffset = skipOffset;</span><br><span class="line">    state.lastPosBlockOffset = lastPosBlockOffset;</span><br><span class="line">    docBufferUpto = <span class="number">0</span>;</span><br><span class="line">    posBufferUpto = <span class="number">0</span>;</span><br><span class="line">    lastDocID = <span class="number">0</span>;</span><br><span class="line">    docCount = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="6"><li><code>Lucene90BlockTreeTermsWriter.TermsWriter.pushTerm</code></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pushTerm</span><span class="params">(BytesRef text)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">      <span class="comment">// Find common prefix between last term and current term:</span></span><br><span class="line">      <span class="type">int</span> <span class="variable">prefixLength</span> <span class="operator">=</span></span><br><span class="line">          Arrays.mismatch(</span><br><span class="line">              lastTerm.bytes(),</span><br><span class="line">              <span class="number">0</span>,</span><br><span class="line">              lastTerm.length(),</span><br><span class="line">              text.bytes,</span><br><span class="line">              text.offset,</span><br><span class="line">              text.offset + text.length);</span><br><span class="line">      <span class="keyword">if</span> (prefixLength == -<span class="number">1</span>) &#123; <span class="comment">// Only happens for the first term, if it is empty</span></span><br><span class="line">        <span class="keyword">assert</span> lastTerm.length() == <span class="number">0</span>;</span><br><span class="line">        prefixLength = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// if (DEBUG) System.out.println(&quot;  shared=&quot; + pos + &quot;  lastTerm.length=&quot; + lastTerm.length);</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// Close the &quot;abandoned&quot; suffix now:</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> lastTerm.length() - <span class="number">1</span>; i &gt;= prefixLength; i--) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// How many items on top of the stack share the current suffix</span></span><br><span class="line">        <span class="comment">// we are closing:</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">prefixTopSize</span> <span class="operator">=</span> pending.size() - prefixStarts[i];</span><br><span class="line">        <span class="keyword">if</span> (prefixTopSize &gt;= minItemsInBlock) &#123;</span><br><span class="line">          <span class="comment">// if (DEBUG) System.out.println(&quot;pushTerm i=&quot; + i + &quot; prefixTopSize=&quot; + prefixTopSize + &quot;</span></span><br><span class="line">          <span class="comment">// minItemsInBlock=&quot; + minItemsInBlock);</span></span><br><span class="line">  <span class="comment">// 重点： 构建FST 相关的索引</span></span><br><span class="line">          writeBlocks(i + <span class="number">1</span>, prefixTopSize);</span><br><span class="line">          prefixStarts[i] -= prefixTopSize - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (prefixStarts.length &lt; text.length) &#123;</span><br><span class="line">        prefixStarts = ArrayUtil.grow(prefixStarts, text.length);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Init new tail:</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> prefixLength; i &lt; text.length; i++) &#123;</span><br><span class="line">        prefixStarts[i] = pending.size();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      lastTerm.copyBytes(text);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="7"><li><code>Lucene90BlockTreeTermsWriter.TermsWriter.writeBlocks</code></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">writeBlocks</span><span class="params">(<span class="type">int</span> prefixLength, <span class="type">int</span> count)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">assert</span> count &gt; <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// if (DEBUG2) &#123;</span></span><br><span class="line">      <span class="comment">//  BytesRef br = new BytesRef(lastTerm.bytes());</span></span><br><span class="line">      <span class="comment">//  br.length = prefixLength;</span></span><br><span class="line">      <span class="comment">//  System.out.println(&quot;writeBlocks: seg=&quot; + segment + &quot; prefix=&quot; + brToString(br) + &quot; count=&quot;</span></span><br><span class="line">      <span class="comment">// + count);</span></span><br><span class="line">      <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// Root block better write all remaining pending entries:</span></span><br><span class="line">      <span class="keyword">assert</span> prefixLength &gt; <span class="number">0</span> || count == pending.size();</span><br><span class="line"></span><br><span class="line">      <span class="type">int</span> <span class="variable">lastSuffixLeadLabel</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// True if we saw at least one term in this block (we record if a block</span></span><br><span class="line">      <span class="comment">// only points to sub-blocks in the terms index so we can avoid seeking</span></span><br><span class="line">      <span class="comment">// to it when we are looking for a term):</span></span><br><span class="line">      <span class="type">boolean</span> <span class="variable">hasTerms</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">      <span class="type">boolean</span> <span class="variable">hasSubBlocks</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">      <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> pending.size() - count;</span><br><span class="line">      <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> pending.size();</span><br><span class="line">      <span class="type">int</span> <span class="variable">nextBlockStart</span> <span class="operator">=</span> start;</span><br><span class="line">      <span class="type">int</span> <span class="variable">nextFloorLeadLabel</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; end; i++) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">PendingEntry</span> <span class="variable">ent</span> <span class="operator">=</span> pending.get(i);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> suffixLeadLabel;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ent.isTerm) &#123;</span><br><span class="line">          <span class="type">PendingTerm</span> <span class="variable">term</span> <span class="operator">=</span> (PendingTerm) ent;</span><br><span class="line">          <span class="keyword">if</span> (term.termBytes.length == prefixLength) &#123;</span><br><span class="line">            <span class="comment">// Suffix is 0, i.e. prefix &#x27;foo&#x27; and term is</span></span><br><span class="line">            <span class="comment">// &#x27;foo&#x27; so the term has empty string suffix</span></span><br><span class="line">            <span class="comment">// in this block</span></span><br><span class="line">            <span class="keyword">assert</span> lastSuffixLeadLabel == -<span class="number">1</span></span><br><span class="line">                : <span class="string">&quot;i=&quot;</span> + i + <span class="string">&quot; lastSuffixLeadLabel=&quot;</span> + lastSuffixLeadLabel;</span><br><span class="line">            suffixLeadLabel = -<span class="number">1</span>;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            suffixLeadLabel = term.termBytes[prefixLength] &amp; <span class="number">0xff</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="type">PendingBlock</span> <span class="variable">block</span> <span class="operator">=</span> (PendingBlock) ent;</span><br><span class="line">          <span class="keyword">assert</span> block.prefix.length &gt; prefixLength;</span><br><span class="line">          suffixLeadLabel = block.prefix.bytes[block.prefix.offset + prefixLength] &amp; <span class="number">0xff</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// if (DEBUG) System.out.println(&quot;  i=&quot; + i + &quot; ent=&quot; + ent + &quot; suffixLeadLabel=&quot; +</span></span><br><span class="line">        <span class="comment">// suffixLeadLabel);</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (suffixLeadLabel != lastSuffixLeadLabel) &#123;</span><br><span class="line">          <span class="type">int</span> <span class="variable">itemsInBlock</span> <span class="operator">=</span> i - nextBlockStart;</span><br><span class="line">          <span class="keyword">if</span> (itemsInBlock &gt;= minItemsInBlock &amp;&amp; end - nextBlockStart &gt; maxItemsInBlock) &#123;</span><br><span class="line">            <span class="comment">// The count is too large for one block, so we must break it into &quot;floor&quot; blocks, where</span></span><br><span class="line">            <span class="comment">// we record</span></span><br><span class="line">            <span class="comment">// the leading label of the suffix of the first term in each floor block, so at search</span></span><br><span class="line">            <span class="comment">// time we can</span></span><br><span class="line">            <span class="comment">// jump to the right floor block.  We just use a naive greedy segmenter here: make a new</span></span><br><span class="line">            <span class="comment">// floor</span></span><br><span class="line">            <span class="comment">// block as soon as we have at least minItemsInBlock.  This is not always best: it often</span></span><br><span class="line">            <span class="comment">// produces</span></span><br><span class="line">            <span class="comment">// a too-small block as the final block:</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">isFloor</span> <span class="operator">=</span> itemsInBlock &lt; count;</span><br><span class="line">            newBlocks.add(</span><br><span class="line">                writeBlock(</span><br><span class="line">                    prefixLength,</span><br><span class="line">                    isFloor,</span><br><span class="line">                    nextFloorLeadLabel,</span><br><span class="line">                    nextBlockStart,</span><br><span class="line">                    i,</span><br><span class="line">                    hasTerms,</span><br><span class="line">                    hasSubBlocks));</span><br><span class="line"></span><br><span class="line">            hasTerms = <span class="literal">false</span>;</span><br><span class="line">            hasSubBlocks = <span class="literal">false</span>;</span><br><span class="line">            nextFloorLeadLabel = suffixLeadLabel;</span><br><span class="line">            nextBlockStart = i;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          lastSuffixLeadLabel = suffixLeadLabel;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ent.isTerm) &#123;</span><br><span class="line">          hasTerms = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          hasSubBlocks = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Write last block, if any:</span></span><br><span class="line">      <span class="keyword">if</span> (nextBlockStart &lt; end) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">itemsInBlock</span> <span class="operator">=</span> end - nextBlockStart;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isFloor</span> <span class="operator">=</span> itemsInBlock &lt; count;</span><br><span class="line">        newBlocks.add(</span><br><span class="line">            writeBlock(</span><br><span class="line">                prefixLength,</span><br><span class="line">                isFloor,</span><br><span class="line">                nextFloorLeadLabel,</span><br><span class="line">                nextBlockStart,</span><br><span class="line">                end,</span><br><span class="line">                hasTerms,</span><br><span class="line">                hasSubBlocks));</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">assert</span> newBlocks.isEmpty() == <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">      <span class="type">PendingBlock</span> <span class="variable">firstBlock</span> <span class="operator">=</span> newBlocks.get(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">assert</span> firstBlock.isFloor || newBlocks.size() == <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// <span class="doctag">NOTE:</span> 每个block生成fst的index</span></span><br><span class="line">      firstBlock.compileIndex(newBlocks, scratchBytes, scratchIntsRef);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Remove slice from the top of the pending stack, that we just wrote:</span></span><br><span class="line">      pending.subList(pending.size() - count, pending.size()).clear();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Append new block</span></span><br><span class="line">      pending.add(firstBlock);</span><br><span class="line"></span><br><span class="line">      newBlocks.clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="8"><li><code>Lucene90BlockTreeTermsWriter.TermsWriter.writeBlock</code><br>PendingBlock中记录了对应的在<code>.tim</code>文件中的位置(startFP), 后续会被FST索引到对应的value里</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> PendingBlock <span class="title function_">writeBlock</span><span class="params">(</span></span><br><span class="line"><span class="params">        <span class="type">int</span> prefixLength,</span></span><br><span class="line"><span class="params">        <span class="type">boolean</span> isFloor,</span></span><br><span class="line"><span class="params">        <span class="type">int</span> floorLeadLabel,</span></span><br><span class="line"><span class="params">        <span class="type">int</span> start,</span></span><br><span class="line"><span class="params">        <span class="type">int</span> end,</span></span><br><span class="line"><span class="params">        <span class="type">boolean</span> hasTerms,</span></span><br><span class="line"><span class="params">        <span class="type">boolean</span> hasSubBlocks)</span></span><br><span class="line">        <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"><span class="comment">// ....</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="keyword">if</span> (isLeafBlock) &#123;</span><br><span class="line">subIndices = <span class="literal">null</span>;</span><br><span class="line">        <span class="type">StatsWriter</span> <span class="variable">statsWriter</span> <span class="operator">=</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">StatsWriter</span>(<span class="built_in">this</span>.statsWriter, fieldInfo.getIndexOptions() != IndexOptions.DOCS);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; end; i++) &#123;</span><br><span class="line">          <span class="type">PendingEntry</span> <span class="variable">ent</span> <span class="operator">=</span> pending.get(i);</span><br><span class="line">          <span class="keyword">assert</span> ent.isTerm : <span class="string">&quot;i=&quot;</span> + i;</span><br><span class="line"></span><br><span class="line">          <span class="type">PendingTerm</span> <span class="variable">term</span> <span class="operator">=</span> (PendingTerm) ent;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">assert</span> StringHelper.startsWith(term.termBytes, prefix) : term + <span class="string">&quot; prefix=&quot;</span> + prefix;</span><br><span class="line">          <span class="type">BlockTermState</span> <span class="variable">state</span> <span class="operator">=</span> term.state;</span><br><span class="line">          <span class="keyword">final</span> <span class="type">int</span> <span class="variable">suffix</span> <span class="operator">=</span> term.termBytes.length - prefixLength;</span><br><span class="line">          <span class="comment">// if (DEBUG2) &#123;</span></span><br><span class="line">          <span class="comment">//  BytesRef suffixBytes = new BytesRef(suffix);</span></span><br><span class="line">          <span class="comment">//  System.arraycopy(term.termBytes, prefixLength, suffixBytes.bytes, 0, suffix);</span></span><br><span class="line">          <span class="comment">//  suffixBytes.length = suffix;</span></span><br><span class="line">          <span class="comment">//  System.out.println(&quot;    write term suffix=&quot; + brToString(suffixBytes));</span></span><br><span class="line">          <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">          <span class="comment">// For leaf block we write suffix straight</span></span><br><span class="line">          suffixLengthsWriter.writeVInt(suffix);</span><br><span class="line">          suffixWriter.append(term.termBytes, prefixLength, suffix);</span><br><span class="line">          <span class="keyword">assert</span> floorLeadLabel == -<span class="number">1</span> || (term.termBytes[prefixLength] &amp; <span class="number">0xff</span>) &gt;= floorLeadLabel;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// Write term stats, to separate byte[] blob:</span></span><br><span class="line">          statsWriter.add(state.docFreq, state.totalTermFreq);</span><br><span class="line"></span><br><span class="line">          <span class="comment">// Write term meta data</span></span><br><span class="line">          postingsWriter.encodeTerm(metaWriter, fieldInfo, state, absolute);</span><br><span class="line">          absolute = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"> <span class="comment">// Block has at least one prefix term or a sub block:</span></span><br><span class="line">        subIndices = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">StatsWriter</span> <span class="variable">statsWriter</span> <span class="operator">=</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">StatsWriter</span>(<span class="built_in">this</span>.statsWriter, fieldInfo.getIndexOptions() != IndexOptions.DOCS);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; end; i++) &#123;</span><br><span class="line">          <span class="type">PendingEntry</span> <span class="variable">ent</span> <span class="operator">=</span> pending.get(i);</span><br><span class="line">          <span class="keyword">if</span> (ent.isTerm) &#123;</span><br><span class="line">            <span class="type">PendingTerm</span> <span class="variable">term</span> <span class="operator">=</span> (PendingTerm) ent;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">assert</span> StringHelper.startsWith(term.termBytes, prefix) : term + <span class="string">&quot; prefix=&quot;</span> + prefix;</span><br><span class="line">            <span class="type">BlockTermState</span> <span class="variable">state</span> <span class="operator">=</span> term.state;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">suffix</span> <span class="operator">=</span> term.termBytes.length - prefixLength;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// For non-leaf block we borrow 1 bit to record</span></span><br><span class="line">            <span class="comment">// if entry is term or sub-block, and 1 bit to record if</span></span><br><span class="line">            <span class="comment">// it&#x27;s a prefix term.  Terms cannot be larger than ~32 KB</span></span><br><span class="line">            <span class="comment">// so we won&#x27;t run out of bits:</span></span><br><span class="line"></span><br><span class="line">            suffixLengthsWriter.writeVInt(suffix &lt;&lt; <span class="number">1</span>);</span><br><span class="line">            suffixWriter.append(term.termBytes, prefixLength, suffix);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Write term stats, to separate byte[] blob:</span></span><br><span class="line">            statsWriter.add(state.docFreq, state.totalTermFreq);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> now that terms dict &quot;sees&quot; these longs,</span></span><br><span class="line">            <span class="comment">// we can explore better column-stride encodings</span></span><br><span class="line">            <span class="comment">// to encode all long[0]s for this block at</span></span><br><span class="line">            <span class="comment">// once, all long[1]s, etc., e.g. using</span></span><br><span class="line">            <span class="comment">// Simple64.  Alternatively, we could interleave</span></span><br><span class="line">            <span class="comment">// stats + meta ... no reason to have them</span></span><br><span class="line">            <span class="comment">// separate anymore:</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// Write term meta data</span></span><br><span class="line">            postingsWriter.encodeTerm(metaWriter, fieldInfo, state, absolute);</span><br><span class="line">            absolute = <span class="literal">false</span>;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">PendingBlock</span> <span class="variable">block</span> <span class="operator">=</span> (PendingBlock) ent;</span><br><span class="line">            <span class="keyword">assert</span> StringHelper.startsWith(block.prefix, prefix);</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">suffix</span> <span class="operator">=</span> block.prefix.length - prefixLength;</span><br><span class="line">            <span class="keyword">assert</span> StringHelper.startsWith(block.prefix, prefix);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">assert</span> suffix &gt; <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// For non-leaf block we borrow 1 bit to record</span></span><br><span class="line">            <span class="comment">// if entry is term or sub-block:f</span></span><br><span class="line">            suffixLengthsWriter.writeVInt((suffix &lt;&lt; <span class="number">1</span>) | <span class="number">1</span>);</span><br><span class="line">            suffixWriter.append(block.prefix.bytes, prefixLength, suffix);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// if (DEBUG2) &#123;</span></span><br><span class="line">            <span class="comment">//  BytesRef suffixBytes = new BytesRef(suffix);</span></span><br><span class="line">            <span class="comment">//  System.arraycopy(block.prefix.bytes, prefixLength, suffixBytes.bytes, 0, suffix);</span></span><br><span class="line">            <span class="comment">//  suffixBytes.length = suffix;</span></span><br><span class="line">            <span class="comment">//  System.out.println(&quot;      write sub-block suffix=&quot; + brToString(suffixBytes) + &quot;</span></span><br><span class="line">            <span class="comment">// subFP=&quot; + block.fp + &quot; subCode=&quot; + (startFP-block.fp) + &quot; floor=&quot; + block.isFloor);</span></span><br><span class="line">            <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">assert</span> floorLeadLabel == -<span class="number">1</span></span><br><span class="line">                    || (block.prefix.bytes[prefixLength] &amp; <span class="number">0xff</span>) &gt;= floorLeadLabel</span><br><span class="line">                : <span class="string">&quot;floorLeadLabel=&quot;</span></span><br><span class="line">                    + floorLeadLabel</span><br><span class="line">                    + <span class="string">&quot; suffixLead=&quot;</span></span><br><span class="line">                    + (block.prefix.bytes[prefixLength] &amp; <span class="number">0xff</span>);</span><br><span class="line">            <span class="keyword">assert</span> block.fp &lt; startFP;</span><br><span class="line"></span><br><span class="line">            suffixLengthsWriter.writeVLong(startFP - block.fp);</span><br><span class="line">            subIndices.add(block.index);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        statsWriter.finish();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">assert</span> subIndices.size() != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// Write term meta data byte[] blob</span></span><br><span class="line">termsOut.writeVInt((<span class="type">int</span>) metaWriter.size());</span><br><span class="line"><span class="comment">// 写入到`tim`文件</span></span><br><span class="line">metaWriter.copyTo(termsOut);</span><br><span class="line">metaWriter.reset();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="9"><li><code>Lucene90PostingWriter.encodeTerm</code></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里的DataOutput 指的是ByteBuffersDataOutput, 一个内存结构, 这里记录了每个Term 倒排索引对应的文件位置相关, 最终会被写入`.tim`文件</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">encodeTerm</span><span class="params">(</span></span><br><span class="line"><span class="params">      DataOutput out, FieldInfo fieldInfo, BlockTermState _state, <span class="type">boolean</span> absolute)</span></span><br><span class="line">      <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">IntBlockTermState</span> <span class="variable">state</span> <span class="operator">=</span> (IntBlockTermState) _state;</span><br><span class="line">    <span class="keyword">if</span> (absolute) &#123;</span><br><span class="line">      lastState = emptyState;</span><br><span class="line">      <span class="keyword">assert</span> lastState.docStartFP == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (lastState.singletonDocID != -<span class="number">1</span></span><br><span class="line">        &amp;&amp; state.singletonDocID != -<span class="number">1</span></span><br><span class="line">        &amp;&amp; state.docStartFP == lastState.docStartFP) &#123;</span><br><span class="line">      <span class="comment">// With runs of rare values such as ID fields, the increment of pointers in the docs file is</span></span><br><span class="line">      <span class="comment">// often 0.</span></span><br><span class="line">      <span class="comment">// Furthermore some ID schemes like auto-increment IDs or Flake IDs are monotonic, so we</span></span><br><span class="line">      <span class="comment">// encode the delta</span></span><br><span class="line">      <span class="comment">// between consecutive doc IDs to save space.</span></span><br><span class="line">      <span class="keyword">final</span> <span class="type">long</span> <span class="variable">delta</span> <span class="operator">=</span> (<span class="type">long</span>) state.singletonDocID - lastState.singletonDocID;</span><br><span class="line">      out.writeVLong((BitUtil.zigZagEncode(delta) &lt;&lt; <span class="number">1</span>) | <span class="number">0x01</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      out.writeVLong((state.docStartFP - lastState.docStartFP) &lt;&lt; <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">if</span> (state.singletonDocID != -<span class="number">1</span>) &#123;</span><br><span class="line">        out.writeVInt(state.singletonDocID);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (writePositions) &#123;</span><br><span class="line">      out.writeVLong(state.posStartFP - lastState.posStartFP);</span><br><span class="line">      <span class="keyword">if</span> (writePayloads || writeOffsets) &#123;</span><br><span class="line">        out.writeVLong(state.payStartFP - lastState.payStartFP);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (writePositions) &#123;</span><br><span class="line">      <span class="keyword">if</span> (state.lastPosBlockOffset != -<span class="number">1</span>) &#123;</span><br><span class="line">        out.writeVLong(state.lastPosBlockOffset);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (state.skipOffset != -<span class="number">1</span>) &#123;</span><br><span class="line">      out.writeVLong(state.skipOffset);</span><br><span class="line">    &#125;</span><br><span class="line">    lastState = state;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ol start="10"><li><code>Lucene90BlockTreeTermsWriter.TermsWriter.finish</code></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">finish</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">     <span class="keyword">if</span> (numTerms &gt; <span class="number">0</span>) &#123;</span><br><span class="line">       <span class="comment">// if (DEBUG) System.out.println(&quot;BTTW: finish prefixStarts=&quot; +</span></span><br><span class="line">       <span class="comment">// Arrays.toString(prefixStarts));</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">// Add empty term to force closing of all final blocks:</span></span><br><span class="line">       pushTerm(<span class="keyword">new</span> <span class="title class_">BytesRef</span>());</span><br><span class="line"></span><br><span class="line">       <span class="comment">// <span class="doctag">TODO:</span> if pending.size() is already 1 with a non-zero prefix length</span></span><br><span class="line">       <span class="comment">// we can save writing a &quot;degenerate&quot; root block, but we have to</span></span><br><span class="line">       <span class="comment">// fix all the places that assume the root block&#x27;s prefix is the empty string:</span></span><br><span class="line">       pushTerm(<span class="keyword">new</span> <span class="title class_">BytesRef</span>());</span><br><span class="line"><span class="comment">// 这里完成将所有Term生成FST的索引, pending.get(0)是root的block，其索引包含了整个pending的Terms</span></span><br><span class="line">       writeBlocks(<span class="number">0</span>, pending.size());</span><br><span class="line"></span><br><span class="line">       <span class="comment">// We better have one final &quot;root&quot; block:</span></span><br><span class="line">       <span class="keyword">assert</span> pending.size() == <span class="number">1</span> &amp;&amp; !pending.get(<span class="number">0</span>).isTerm</span><br><span class="line">           : <span class="string">&quot;pending.size()=&quot;</span> + pending.size() + <span class="string">&quot; pending=&quot;</span> + pending;</span><br><span class="line">       <span class="keyword">final</span> <span class="type">PendingBlock</span> <span class="variable">root</span> <span class="operator">=</span> (PendingBlock) pending.get(<span class="number">0</span>);</span><br><span class="line">       <span class="keyword">assert</span> root.prefix.length == <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">final</span> <span class="type">BytesRef</span> <span class="variable">rootCode</span> <span class="operator">=</span> root.index.getEmptyOutput();</span><br><span class="line">       <span class="keyword">assert</span> rootCode != <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">       <span class="type">ByteBuffersDataOutput</span> <span class="variable">metaOut</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteBuffersDataOutput</span>();</span><br><span class="line">       fields.add(metaOut);</span><br><span class="line"></span><br><span class="line">       metaOut.writeVInt(fieldInfo.number);</span><br><span class="line">       metaOut.writeVLong(numTerms);</span><br><span class="line">       metaOut.writeVInt(rootCode.length);</span><br><span class="line">       metaOut.writeBytes(rootCode.bytes, rootCode.offset, rootCode.length);</span><br><span class="line">       <span class="keyword">assert</span> fieldInfo.getIndexOptions() != IndexOptions.NONE;</span><br><span class="line">       <span class="keyword">if</span> (fieldInfo.getIndexOptions() != IndexOptions.DOCS) &#123;</span><br><span class="line">         metaOut.writeVLong(sumTotalTermFreq);</span><br><span class="line">       &#125;</span><br><span class="line">       metaOut.writeVLong(sumDocFreq);</span><br><span class="line">       metaOut.writeVInt(docsSeen.cardinality());</span><br><span class="line">       writeBytesRef(metaOut, <span class="keyword">new</span> <span class="title class_">BytesRef</span>(firstPendingTerm.termBytes));</span><br><span class="line">       writeBytesRef(metaOut, <span class="keyword">new</span> <span class="title class_">BytesRef</span>(lastPendingTerm.termBytes));</span><br><span class="line">       metaOut.writeVLong(indexOut.getFilePointer());</span><br><span class="line">       <span class="comment">// Write FST to index</span></span><br><span class="line"><span class="comment">// 这里的indexOut就是&quot;.tip&quot;</span></span><br><span class="line">       root.index.save(metaOut, indexOut);</span><br><span class="line">       <span class="comment">// System.out.println(&quot;  write FST &quot; + indexStartFP + &quot; field=&quot; + fieldInfo.name);</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">/*</span></span><br><span class="line"><span class="comment">       if (DEBUG) &#123;</span></span><br><span class="line"><span class="comment">         final String dotFileName = segment + &quot;_&quot; + fieldInfo.name + &quot;.dot&quot;;</span></span><br><span class="line"><span class="comment">         Writer w = new OutputStreamWriter(new FileOutputStream(dotFileName));</span></span><br><span class="line"><span class="comment">         Util.toDot(root.index, w, false, false);</span></span><br><span class="line"><span class="comment">         System.out.println(&quot;SAVED to &quot; + dotFileName);</span></span><br><span class="line"><span class="comment">         w.close();</span></span><br><span class="line"><span class="comment">       &#125;</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line"></span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="keyword">assert</span> sumTotalTermFreq == <span class="number">0</span></span><br><span class="line">           || fieldInfo.getIndexOptions() == IndexOptions.DOCS &amp;&amp; sumTotalTermFreq == -<span class="number">1</span>;</span><br><span class="line">       <span class="keyword">assert</span> sumDocFreq == <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">assert</span> docsSeen.cardinality() == <span class="number">0</span>;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Lucene整体倒排索引设计还是非常复杂的，这里仅仅是将内存的数据写入到磁盘就需要这么多步骤，同时Lucene保持了很好的抽象，不同格式的索引数据只要涉及实现对应的接口即可，通过codec的方式嵌入到引擎中.</p><p>我的问题是如何评估这些设计对性能的影响，FST的涉及需要如此复杂吗，只是为了定位Term对应的倒排表位置，有没有其他可以使用的数据结构呢, 在后续的学习过程中还是要多加深入了解和思考，希望能得到更好的答案.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;Lucene中Term代表了一个原子粒度的索引和搜索单位，ES中keyword和text类型经过分词之后都会以Term的形式被Lucene索</summary>
      
    
    
    
    
    <category term="ES, Lucene, elasticsearch" scheme="https://skyitachi.github.io/tags/ES-Lucene-elasticsearch/"/>
    
  </entry>
  
  <entry>
    <title>IVFPQ的原理</title>
    <link href="https://skyitachi.github.io/2024/08/04/IVFPQ%E7%9A%84%E5%8E%9F%E7%90%86/"/>
    <id>https://skyitachi.github.io/2024/08/04/IVFPQ%E7%9A%84%E5%8E%9F%E7%90%86/</id>
    <published>2024-08-03T16:00:00.000Z</published>
    <updated>2024-08-03T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h1><ul><li>介绍IVF和PQ的简单原理</li><li>介绍IVFPQ的主要流程</li></ul><h1 id="Kmeans-聚类算法"><a href="#Kmeans-聚类算法" class="headerlink" title="Kmeans 聚类算法"></a>Kmeans 聚类算法</h1><p>在IVF和PQ中都涉及到聚类算法，简单介绍下kmeans聚类算法原理</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 随机选择k个初始中心点</span><br><span class="line">2. 将每个向量分配到最近的中心点所在的簇</span><br><span class="line">3. 重新计算每个簇的中心点（找出质心）</span><br><span class="line">4. 重复步骤2和3，直到簇中心不再变化或者达到迭代次数 </span><br></pre></td></tr></table></figure><h1 id="IVF的与原理介绍"><a href="#IVF的与原理介绍" class="headerlink" title="IVF的与原理介绍"></a>IVF的与原理介绍</h1><blockquote><p>Inverted File (IVF) 是一种索引结构，通常用于信息检索系统，特别是在全文搜索引擎中</p></blockquote><p>IVF的原理简单直接:</p><p>向量中的IVF索引就是将样本向量首先生成nlist个聚类，然后每次向量查询的时候只要比较查询向量和nlist个聚类中心的距离，可以找出nprobe个最近的聚类中心，然后在每个聚类里暴力搜索出距离最近的K个向量</p><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> faiss</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成一些示例数据</span></span><br><span class="line">d = <span class="number">64</span>  <span class="comment"># 向量维度</span></span><br><span class="line">nb = <span class="number">100000</span>  <span class="comment"># 数据库大小</span></span><br><span class="line">nq = <span class="number">10</span>  <span class="comment"># 查询数量</span></span><br><span class="line">np.random.seed(<span class="number">1234</span>)  <span class="comment"># 确保可重复性</span></span><br><span class="line">xb = np.random.random((nb, d)).astype(<span class="string">&#x27;float32&#x27;</span>)</span><br><span class="line">xq = np.random.random((nq, d)).astype(<span class="string">&#x27;float32&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构建 IVF 索引</span></span><br><span class="line">nlist = <span class="number">1024</span> <span class="comment"># 聚类数量</span></span><br><span class="line">quantizer = faiss.IndexFlatL2(d)  <span class="comment"># 量化器</span></span><br><span class="line">index = faiss.IndexIVFFlat(quantizer, d, nlist)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 训练索引</span></span><br><span class="line">index.train(xb)</span><br><span class="line">index.add(xb)</span><br><span class="line"></span><br><span class="line">index.nprobe = <span class="number">256</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查询</span></span><br><span class="line">k = <span class="number">4</span>  <span class="comment"># 返回的最近邻数量</span></span><br><span class="line">D, I = index.search(xq, k)  <span class="comment"># 搜索</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印结果</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;查询结果 (距离, 索引):&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(nq):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;查询 <span class="subst">&#123;i&#125;</span></span></span><br></pre></td></tr></table></figure><h1 id="PQ-Product-Quantization-的原理与介绍"><a href="#PQ-Product-Quantization-的原理与介绍" class="headerlink" title="PQ(Product Quantization)的原理与介绍"></a>PQ(Product Quantization)的原理与介绍</h1><p>PQ 主要用于向量的压缩, 一般而言向量都是高维数据, 假设一个1024维的float32类型的向量，单个向量的大小就是1024 * 4 &#x3D; 4kb, 使用PQ压缩后往往能极大缩小单个向量的大小，当然不可避免的会丢失精度。</p><h2 id="PQ向量压缩的主要步骤"><a href="#PQ向量压缩的主要步骤" class="headerlink" title="PQ向量压缩的主要步骤"></a>PQ向量压缩的主要步骤</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 将d维向量分成M组，在每一组内找到ksub个聚类中心</span><br><span class="line">2. 将每一组的向量用离它最近聚类中心的id来表示，那么每组内的向量的大小就是nbits（2^nbits=ksub）, 整体压缩过后的向量大小就是M * nbits, 一般而言M选择8，nbits一般是8或16</span><br></pre></td></tr></table></figure><h2 id="搜索压缩过后的样本向量"><a href="#搜索压缩过后的样本向量" class="headerlink" title="搜索压缩过后的样本向量"></a>搜索压缩过后的样本向量</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 将查询向量分为M组，每一组内和ksub个聚类中心计算距离, 并使用一张表存下来(table[i][ck])</span><br><span class="line">2. 计算查询向量和样本向量的距离时，可以用距离聚类中心的距离来代替，进行O(1)的查表即可获取，（样本空间压缩后的编码是[c0, c1, c2... cM-1]，只要取之前计算好的table[i][ck]的距离即可）</span><br><span class="line">3. 取最近K个即可</span><br></pre></td></tr></table></figure><h1 id="IVFPQ的工作原理"><a href="#IVFPQ的工作原理" class="headerlink" title="IVFPQ的工作原理"></a>IVFPQ的工作原理</h1><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 建立索引</span><br><span class="line"></span><br><span class="line">1. 样本空间先用IVF 分类成nlist个聚类</span><br><span class="line">2. 每个聚类中的样本向量计算它们和聚类中心的差值，得到新的向量</span><br><span class="line">3. 使用PQ压缩每个聚类中新的样本向量</span><br><span class="line"></span><br><span class="line"># 查询</span><br><span class="line">1. 先找到距离查询量最近的聚类中心</span><br><span class="line">2. 计算查询向量和聚类中心的差值，得到新的查询向量</span><br><span class="line">3. 对新的查询向量使用PQ量化，并和该聚类中的压缩过后的样本向量做距离计算，并取出K个</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="代码示例-1"><a href="#代码示例-1" class="headerlink" title="代码示例"></a>代码示例</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> faiss</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成一些示例数据</span></span><br><span class="line">d = <span class="number">128</span>  <span class="comment"># 向量维度</span></span><br><span class="line">nb = <span class="number">100000</span>  <span class="comment"># 数据库大小</span></span><br><span class="line">nq = <span class="number">10</span>  <span class="comment"># 查询数量</span></span><br><span class="line">np.random.seed(<span class="number">1234</span>)  <span class="comment"># 确保可重复性</span></span><br><span class="line">xb = np.random.random((nb, d)).astype(<span class="string">&#x27;float32&#x27;</span>)</span><br><span class="line">xq = np.random.random((nq, d)).astype(<span class="string">&#x27;float32&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构建IVFPQ索引</span></span><br><span class="line">nlist = <span class="number">100</span>  <span class="comment"># 聚类数量, ivf的聚类</span></span><br><span class="line">m = <span class="number">8</span>  <span class="comment"># 每个向量的子向量数量</span></span><br><span class="line">nbit = <span class="number">8</span> <span class="comment"># ksub = 2^8, 每组要有ksub个聚类中心</span></span><br><span class="line">quantizer = faiss.IndexFlatL2(d)  <span class="comment"># 量化器</span></span><br><span class="line">index = faiss.IndexIVFPQ(quantizer, d, nlist, m, nbit)  <span class="comment"># 8位量化</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 训练索引</span></span><br><span class="line">index.train(xb)</span><br><span class="line">index.add(xb)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查询</span></span><br><span class="line">k = <span class="number">4</span>  <span class="comment"># 返回的最近邻数量</span></span><br><span class="line">D, I = index.search(xq, k)  <span class="comment"># 搜索</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印结果</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;查询结果 (距离, 索引):&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(nq):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;查询 <span class="subst">&#123;i&#125;</span>:</span></span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>PQ量化压缩技术在向量索引领域较为常见，了解其整体的工作流程有助于我们选择合适的向量索引，从而达到较好的搜索性能. 而且PQ可以和很多算法结合，可以帮助理解部分faiss中index_factory的参数</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;主要内容&quot;&gt;&lt;a href=&quot;#主要内容&quot; class=&quot;headerlink&quot; title=&quot;主要内容&quot;&gt;&lt;/a&gt;主要内容&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;介绍IVF和PQ的简单原理&lt;/li&gt;
&lt;li&gt;介绍IVFPQ的主要流程&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;K</summary>
      
    
    
    
    
    <category term="algorithm 向量数据库 vector ann" scheme="https://skyitachi.github.io/tags/algorithm-%E5%90%91%E9%87%8F%E6%95%B0%E6%8D%AE%E5%BA%93-vector-ann/"/>
    
  </entry>
  
  <entry>
    <title>java中如何处理批量请求及其异常处理</title>
    <link href="https://skyitachi.github.io/2024/07/26/java%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
    <id>https://skyitachi.github.io/2024/07/26/java%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</id>
    <published>2024-07-25T16:00:00.000Z</published>
    <updated>2024-07-25T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class ScoredItems &#123;</span><br><span class="line">public Object items;</span><br><span class="line">public double score;</span><br><span class="line">public ScoredItems(Object items, double score) &#123;</span><br><span class="line">this.items = items;</span><br><span class="line">this.score = score;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public interface Scorer &#123;</span><br><span class="line">List&lt;ScoredItems&gt; score(List&lt;Object&gt; items);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Ranker &#123;</span><br><span class="line">private Scorer scorer;</span><br><span class="line"></span><br><span class="line">public List&lt;ScoredItems&gt; rank(List&lt;Object&gt; items) &#123;</span><br><span class="line">// TODO:</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>请实现<code>Ranker.rank</code>接口，并以全局score降序排列返回<code>List&lt;ScoredItems&gt;</code> 其中items的长度最大是10000， <code>Scorer.score</code>接口items的长度最大是100.</p><h1 id="实现一"><a href="#实现一" class="headerlink" title="实现一"></a>实现一</h1><h2 id="使用线程池处理批量请求"><a href="#使用线程池处理批量请求" class="headerlink" title="使用线程池处理批量请求"></a>使用线程池处理批量请求</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"> public List&lt;ScoredItems&gt; rank(List&lt;Object&gt; items) &#123;</span><br><span class="line">// 100 分组</span><br><span class="line">List&lt;List&lt;Object&gt;&gt; partitions = Lists.partition(items, 100);</span><br><span class="line"></span><br><span class="line">if (partitions.size() == 1) &#123;</span><br><span class="line">return scorer.score(items);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">List&lt;Future&lt;List&lt;ScoredItems&gt;&gt;&gt; futures = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">for(List&lt;Object&gt; partition: partitions) &#123;</span><br><span class="line">Future&lt;List&lt;ScoredItems&gt;&gt; future = threadPoolExecutor.submit(() -&gt; scorer.score(partition));</span><br><span class="line">futures.add(future);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">List&lt;ScoredItems&gt; results = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">for (Future&lt;List&lt;ScoredItems&gt;&gt; f: futures) &#123;</span><br><span class="line">List&lt;ScoredItems&gt; result = f.get();</span><br><span class="line">results.addAll(result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">results.sort((o1, o2) -&gt; Double.compare(o2.score, o1.score));</span><br><span class="line"></span><br><span class="line">return results;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中线程池的初始化</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">threadPoolExecutor = new ThreadPoolExecutor(100, 100, 60, TimeUnit.SECONDS, workQueue);</span><br></pre></td></tr></table></figure><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><ul><li>基于分组，然后利用线城池批量请求, 达到并发的的目的</li><li>缺点: 1. 没有异常处理, 2. 线程池的设置合理性</li></ul><h1 id="实现二"><a href="#实现二" class="headerlink" title="实现二"></a>实现二</h1><h2 id="加入异常处理并对超时异常特殊处理-异常处理的准则是只要有一个score请求发生异常了，这个rank接口需要抛异常"><a href="#加入异常处理并对超时异常特殊处理-异常处理的准则是只要有一个score请求发生异常了，这个rank接口需要抛异常" class="headerlink" title="加入异常处理并对超时异常特殊处理, 异常处理的准则是只要有一个score请求发生异常了，这个rank接口需要抛异常"></a>加入异常处理并对超时异常特殊处理, 异常处理的准则是只要有一个score请求发生异常了，这个rank接口需要抛异常</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">for (Future&lt;List&lt;ScoredItems&gt;&gt; f: futures) &#123;</span><br><span class="line">try &#123;</span><br><span class="line">List&lt;ScoredItems&gt; result = f.get(timeout, TimeUnit.MILLISECONDS);</span><br><span class="line">results.addAll(result);</span><br><span class="line">&#125; catch (TimeoutException e) &#123;</span><br><span class="line">throw new RPCTimeoutException(&quot;超时异常&quot;);</span><br><span class="line">&#125; catch (ExecutionException | InterruptedException e) &#123;</span><br><span class="line">throw new SystemException(&quot;其他异常&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="说明-1"><a href="#说明-1" class="headerlink" title="说明"></a>说明</h2><ol><li>这里在循环里用了future.get(timeout, TimeUnit.MILLISECONDS)造成了整体超时时间会累积，我们期望的是接口每一次调用的延迟是固定的. 这种写法是有问题的.</li><li>这里只处理了发生异常的请求, rank接口层面已经完成了异常处理，但是其他请求仍然在线程池里执行</li><li>通过future.cancel 会取消其他线程池里的执行线程吗 (只适用于非超时异常的场景, 如果发生了超时异常再去取消，那么其他future大概率要么完成，要么已经异常)</li></ol><h1 id="实现三"><a href="#实现三" class="headerlink" title="实现三"></a>实现三</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;ScoredItems&gt; rank(List&lt;Object&gt; items) throws RPCTimeoutException &#123;</span><br><span class="line"></span><br><span class="line">List&lt;List&lt;Object&gt;&gt; partitions = Lists.partition(items, 100);</span><br><span class="line">if (partitions.size() == 1) &#123;</span><br><span class="line">return scorer.score(items);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">List&lt;CompletableFuture&lt;List&lt;ScoredItems&gt;&gt;&gt; allScored = partitions</span><br><span class="line">.stream()</span><br><span class="line">.map(partition -&gt;</span><br><span class="line">CompletableFuture.supplyAsync(() -&gt; scorer.score(partition), executor)</span><br><span class="line">.orTimeout(timeout, TimeUnit.MILLISECONDS))</span><br><span class="line">.toList();</span><br><span class="line"></span><br><span class="line">List&lt;ScoredItems&gt; result = new ArrayList&lt;&gt;();</span><br><span class="line">for(CompletableFuture&lt;List&lt;ScoredItems&gt;&gt; pf: allScored) &#123;</span><br><span class="line">try &#123;</span><br><span class="line">List&lt;ScoredItems&gt; scored = pf.join();</span><br><span class="line">result.addAll(scored);</span><br><span class="line">&#125; catch (CompletionException e) &#123;</span><br><span class="line">if (e.getCause() instanceof TimeoutException) &#123;</span><br><span class="line">logger.warn(&quot;[rank] found TimeoutException&quot;);</span><br><span class="line">throw new RPCTimeoutException(e.getMessage());</span><br><span class="line">&#125; else &#123;</span><br><span class="line">// pass</span><br><span class="line">&#125;</span><br><span class="line">&#125; catch (CancellationException e) &#123;</span><br><span class="line">// pass</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">result.sort((o1, o2) -&gt; Double.compare(o2.score, o1.score));</span><br><span class="line">return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="说明-2"><a href="#说明-2" class="headerlink" title="说明"></a>说明</h2><ul><li>使用了<code>CompletableFuture.orTimeout</code> 处理每个请求的异常，获取结果的时候用了<code>cf.join()</code> 方法.</li><li>使用CompletableFuture总是更好的选择</li><li><code>CompletableFuture.cancel(true)</code>的实际效果是什么, 会节省线程池资源吗</li></ul><h1 id="CompletableFuture-cancel-true-的实验"><a href="#CompletableFuture-cancel-true-的实验" class="headerlink" title="CompletableFuture.cancel(true)的实验"></a><code>CompletableFuture.cancel(true)</code>的实验</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">public static void groupCompletableFutureDemo() &#123;</span><br><span class="line">List&lt;CompletableFuture&lt;Integer&gt;&gt; futures = Stream.of(1, 2)</span><br><span class="line">.map(o -&gt; CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">try &#123;</span><br><span class="line">Thread.sleep(1000);</span><br><span class="line">logger.info(&quot;[GroupCompletableFuture] finish execution got result &#123;&#125;&quot;, o * 2);</span><br><span class="line">return o * 2;</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">return null;</span><br><span class="line">&#125;, gExecutorService).orTimeout(o * 900, TimeUnit.MILLISECONDS))</span><br><span class="line">.toList();</span><br><span class="line"></span><br><span class="line">int timeoutExceptions = 0;</span><br><span class="line">int cancelExceptions = 0;</span><br><span class="line"></span><br><span class="line">for(CompletableFuture&lt;Integer&gt; future: futures) &#123;</span><br><span class="line">try &#123;</span><br><span class="line">Integer result = future.join();</span><br><span class="line">logger.info(&quot;[GroupCompletableFuture] got result: &#123;&#125;&quot;, result);</span><br><span class="line">&#125; catch (CompletionException e) &#123;</span><br><span class="line">if (e.getCause() instanceof TimeoutException) &#123;</span><br><span class="line">timeoutExceptions += 1;</span><br><span class="line">logger.warn(&quot;[GroupCompletableFuture] got TimeoutException correctly done: &#123;&#125;&quot;, future.isDone());</span><br><span class="line">for (CompletableFuture&lt;Integer&gt; f: futures) &#123;</span><br><span class="line">if (!f.isDone() &amp;&amp; !f.isCancelled()) &#123;</span><br><span class="line">f.cancel(true);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; catch (CancellationException e) &#123;</span><br><span class="line">cancelExceptions += 1;</span><br><span class="line">logger.warn(&quot;[GroupCompletableFuture] got cancel exception&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">logger.info(&quot;[GroupCompletableFuture] timeout exceptions: &#123;&#125;, cancel exceptions: &#123;&#125;&quot;,</span><br><span class="line">timeoutExceptions, cancelExceptions);</span><br><span class="line">&#125;</span><br><span class="line">// </span><br><span class="line">2024-07-26 11:48:48 WARN  ConcurrentScoreDemo:434 - [GroupCompletableFuture] got TimeoutException correctly done: true</span><br><span class="line">2024-07-26 11:48:48 WARN  ConcurrentScoreDemo:443 - [GroupCompletableFuture] got cancel exception</span><br><span class="line">2024-07-26 11:48:48 INFO  ConcurrentScoreDemo:447 - [GroupCompletableFuture] timeout exceptions: 1, cancel exceptions: 1</span><br><span class="line">2024-07-26 11:48:48 INFO  ConcurrentScoreDemo:415 - [GroupCompletableFuture] finish execution got result 4</span><br><span class="line">2024-07-26 11:48:48 INFO  ConcurrentScoreDemo:415 - [GroupCompletableFuture] finish execution got result 2</span><br></pre></td></tr></table></figure><h2 id="说明-3"><a href="#说明-3" class="headerlink" title="说明"></a>说明</h2><ul><li><code>CompletableFuture.cancel(true)</code> 并不能取消线程的执行，只会更改future本身的状态</li></ul><h1 id="使用Thread-interrupt-改变Thread运行状态"><a href="#使用Thread-interrupt-改变Thread运行状态" class="headerlink" title="使用Thread.interrupt() 改变Thread运行状态"></a>使用<code>Thread.interrupt()</code> 改变Thread运行状态</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">public static void longRunningTask(ScheduledExecutorService scheduledExecutorService, long timeout)</span><br><span class="line">            throws InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">Thread thread = Thread.currentThread();</span><br><span class="line"></span><br><span class="line">AtomicBoolean done = new AtomicBoolean(false);</span><br><span class="line"></span><br><span class="line">scheduledExecutorService.schedule(new Runnable() &#123;</span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">if (!done.get()) &#123;</span><br><span class="line">done.set(true);</span><br><span class="line">thread.interrupt();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;, timeout, TimeUnit.MILLISECONDS);</span><br><span class="line"></span><br><span class="line">// 模拟耗时工作</span><br><span class="line">Thread.sleep(1000);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void realInterruptTaskDemo() throws InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">ScheduledExecutorService scheduledExecutorService = Executors.newScheduledThreadPool(1);</span><br><span class="line"></span><br><span class="line">BlockingQueue&lt;Runnable&gt; workingQueue = new LinkedBlockingQueue&lt;&gt;(Integer.MAX_VALUE);</span><br><span class="line"></span><br><span class="line">ThreadPoolExecutor executor = new ThreadPoolExecutor(2, 10, 60, TimeUnit.MILLISECONDS, workingQueue);</span><br><span class="line"></span><br><span class="line">long start = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">try &#123;</span><br><span class="line">longRunningTask(scheduledExecutorService, 800);</span><br><span class="line">logger.info(&quot;[realInterruptTaskDemo.longRunningTask] finished&quot;);</span><br><span class="line">return 1;</span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line">logger.info(&quot;[realInterruptTaskDemo.longRunningTask] canceled: &#123;&#125;&quot;, e.getMessage());</span><br><span class="line">&#125;</span><br><span class="line">return null;</span><br><span class="line">&#125;, executor);</span><br><span class="line"></span><br><span class="line">logger.warn(&quot;[realInterruptTaskDemo] active thread count: &#123;&#125;&quot;, executor.getActiveCount());</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">future.join();</span><br><span class="line">&#125; catch (CompletionException e) &#123;</span><br><span class="line">logger.warn(&quot;[realInterruptTaskDemo] CompletionException: &#123;&#125;&quot;, e.getMessage());</span><br><span class="line">&#125; catch (CancellationException e) &#123;</span><br><span class="line">logger.warn(&quot;[realInterruptTaskDemo] CancellationException: &#123;&#125;&quot;, e.getMessage());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">logger.warn(&quot;[realInterruptTaskDemo] task is still running after join active thread count: &#123;&#125;, consumes: &#123;&#125;&quot;, executor.getActiveCount(),</span><br><span class="line">System.currentTimeMillis() - start);</span><br><span class="line"></span><br><span class="line">if (future.isCompletedExceptionally()) &#123;</span><br><span class="line">logger.warn(&quot;[realInterruptTaskDemo] future is error&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">scheduledExecutorService.shutdown();</span><br><span class="line">executor.shutdown();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// output</span><br><span class="line">2024-07-26 11:59:50 WARN  ConcurrentScoreDemo:281 - [realInterruptTaskDemo] active thread count: 1</span><br><span class="line">2024-07-26 11:59:51 INFO  ConcurrentScoreDemo:276 - [realInterruptTaskDemo.longRunningTask] canceled: sleep interrupted</span><br><span class="line">2024-07-26 11:59:51 WARN  ConcurrentScoreDemo:291 - [realInterruptTaskDemo] task is still running after join active thread count: 0, consumes: 803</span><br></pre></td></tr></table></figure><h2 id="说明-4"><a href="#说明-4" class="headerlink" title="说明"></a>说明</h2><ul><li>使用了<code>Thread.interrupt</code>之后，本来1000ms的sleep 在800ms的时候被打断了，同时线程也没了.</li><li>这样做的后果是什么, 虽然activeCount的线程没了，但是意味着线程池需要重新创建一个新的线程（有必要的情况下），创建线程同样也需要消耗资源, 实际的生产环境中，一般都是有超时处理的，这种情况直接让请求在线程池中走完，而不是销毁线程，这样更加合理一些.</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>在处理批量的请求中，异常处理使用CompleableFuture更加合理和简洁，接口的超时使用orTimeout加入超时机制，避免在循环中手动调用future.get(timeout)这种实践</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;场景&quot;&gt;&lt;a href=&quot;#场景&quot; class=&quot;headerlink&quot; title=&quot;场景&quot;&gt;&lt;/a&gt;场景&lt;/h1&gt;&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;s</summary>
      
    
    
    
    
    <category term="java, Exception, CompletableFuture, ThreadPool, batch" scheme="https://skyitachi.github.io/tags/java-Exception-CompletableFuture-ThreadPool-batch/"/>
    
  </entry>
  
  <entry>
    <title>ann-benchmarks中hnsw简单解读</title>
    <link href="https://skyitachi.github.io/2024/07/23/hnswlib%E5%92%8Cfaiss_hnsw%E7%9A%84ann-benchmarks%E7%BB%93%E6%9E%9C%E8%A7%A3%E8%AF%BB/"/>
    <id>https://skyitachi.github.io/2024/07/23/hnswlib%E5%92%8Cfaiss_hnsw%E7%9A%84ann-benchmarks%E7%BB%93%E6%9E%9C%E8%A7%A3%E8%AF%BB/</id>
    <published>2024-07-22T16:00:00.000Z</published>
    <updated>2024-07-22T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="hnswlib和faiss-hnsw在ann-benchmark中的参数解读"><a href="#hnswlib和faiss-hnsw在ann-benchmark中的参数解读" class="headerlink" title="hnswlib和faiss_hnsw在ann-benchmark中的参数解读"></a>hnswlib和faiss_hnsw在ann-benchmark中的参数解读</h1><p><a href="https://ann-benchmarks.com/sift-128-euclidean_10_euclidean.html">benchmark链接</a><br>只需要关注hnswlib和hnsw(faiss) 即可</p><h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><ul><li>数据集: sift-128-euclidean数据集(向量的维度是128)</li><li>k-nn的k是10</li><li>hnswlib和faiss_hnsw的benchmark都是基于单线程的</li></ul><h2 id="benchmark的细节点说明"><a href="#benchmark的细节点说明" class="headerlink" title="benchmark的细节点说明"></a>benchmark的细节点说明</h2><ol><li><p>hnswlib中有相同图例的点, eg：<code>Parameters: hnswlib (&#123;&#39;M&#39;: 12, &#39;efConstruction&#39;: 500&#125;)</code> 这样得点标记了好几个，但是QPS和Recall都不相同,<br>原因在于hnswlib的benchmark配置中有query-args参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// ann_benchmarks/algorithms/hnswlib/config.yml</span><br><span class="line">float:</span><br><span class="line">  any:</span><br><span class="line">  - base_args: [&#x27;@metric&#x27;]</span><br><span class="line">    constructor: HnswLib</span><br><span class="line">    disabled: false</span><br><span class="line">    docker_tag: ann-benchmarks-hnswlib</span><br><span class="line">    module: ann_benchmarks.algorithms.hnswlib</span><br><span class="line">    name: hnswlib</span><br><span class="line">    run_groups:</span><br><span class="line">      M-12:</span><br><span class="line">        arg_groups: [&#123;M: 12, efConstruction: 500&#125;]</span><br><span class="line">        args: &#123;&#125;</span><br><span class="line">        query_args: [[10, 20, 40, 80, 120, 200, 400, 600, 800]]</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">// query_args 对应了 hnswlib/module.py中的set_query_arguments函数的参数</span><br><span class="line"></span><br><span class="line">    def set_query_arguments(self, ef):</span><br><span class="line">        self.p.set_ef(ef)</span><br></pre></td></tr></table></figure></li><li><p>hnswlib中set_ef和faiss_hnsw中设置efSearch的效果是一样的, faiss中的图例就标注了efSearch(ef) <code>,&quot;faiss (&#123;&#39;M&#39;: 12, &#39;efConstruction&#39;: 500&#125;, ef: 80)</code></p></li><li><p>efSearch不影响build，所以在Recall&#x2F;Build time的图上hnswlib就没有”重复”的点了</p></li></ol><h1 id="hnswlib和faiss-hnsw的性能表现"><a href="#hnswlib和faiss-hnsw的性能表现" class="headerlink" title="hnswlib和faiss_hnsw的性能表现"></a>hnswlib和faiss_hnsw的性能表现</h1><p>主要看recall和build的表现</p><h2 id="ann-benchmark中的表现"><a href="#ann-benchmark中的表现" class="headerlink" title="ann-benchmark中的表现"></a>ann-benchmark中的表现</h2><p>参考ann-benchmark的论文，他们运行的硬件环境是: Amazon EC2 c5.4xlarge instances that are equipped with Intel Xeon Platinum 8124M CPU (16 cores available, 3.00 GHz, 25.0MB Cache) and 32GB of RAM running Amazon Linux.</p><p>ann-benchmarks网站上的benchmark如下:</p><p><img src="/../../imgs/annb_recall_hnsw.png" alt="Recall"></p><p>说明: </p><ol><li><p>整体QPS随着recall的上升成指数级的下降 (两者都是)</p></li><li><p>相同召回率的情况下，hnswlib的QPS要高一点, 由于faiss标注了ef(efSearch)但是hnswlib没有标注，所以比较起来不太直观，后面我在本地自己跑的时候给hnswlib带上了ef参数，这样就更加直观了</p></li></ol><p><img src="/../../imgs/annb_build_hnsw.png" alt="Build Index Time"></p><p>说明: 1. Build Index Time也是hnswlib占优</p><h2 id="本地的表现"><a href="#本地的表现" class="headerlink" title="本地的表现"></a>本地的表现</h2><p>硬件环境: AMD Ryzen 5 3600 (3.6G Hz), 6 core 12 threads, 32GB of RAM running Ubuntu 24.04</p><p>这里我修改了ann-benchmarks中hnswlib的环境和在efConstruction&#x3D;200和500的情况下比较hnswlib的表现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// ann_benchmarks/algorithms/hnswlib/config.yml</span><br><span class="line">FROM ann-benchmarks</span><br><span class="line"></span><br><span class="line"># RUN apt-get install -y python-setuptools python-pip</span><br><span class="line">RUN pip3 install pybind11 numpy setuptools hnswlib==0.8.0</span><br><span class="line"></span><br><span class="line"># RUN cd hnsw/python_bindings; python3 setup.py install</span><br><span class="line"></span><br><span class="line">RUN python3 -c &#x27;import hnswlib&#x27;</span><br></pre></td></tr></table></figure><h3 id="Recall-QPS-表现"><a href="#Recall-QPS-表现" class="headerlink" title="Recall &amp; QPS 表现"></a>Recall &amp; QPS 表现</h3><p>关于recall 我们更需要关注是否通过参数配置到足够高的精度，我这里以0.99的recall作为基础，主要比较在0.99以上的召回率条件下(qps &gt; 2000)，两种算法实现的qps及其对应的参数</p><table><thead><tr><th>algorithm</th><th>parameters</th><th>k-nn(recall)</th><th>qps</th><th>build(s)</th><th>indexsize(kb)</th></tr></thead><tbody><tr><td>faiss_hnsw</td><td>faiss ({‘M’: 24, ‘efConstruction’: 500}, ef: 80)</td><td>0.99031</td><td>2561.923162412995</td><td>1458.773098230362</td><td>794864.0</td></tr><tr><td>faiss_hnsw</td><td>faiss ({‘M’: 16, ‘efConstruction’: 500}, ef: 120)</td><td>0.99347</td><td>2194.419076982479</td><td>1285.849939107895</td><td>732492.0</td></tr><tr><td>faiss_hnsw</td><td>faiss ({‘M’: 36, ‘efConstruction’: 500}, ef: 80)</td><td>0.99314</td><td>2191.7604350595634</td><td>1585.1033165454865</td><td>888936.0</td></tr><tr><td>faiss_hnsw</td><td>faiss ({‘M’: 48, ‘efConstruction’: 500}, ef: 80)</td><td>0.99411</td><td>2077.6779248107487</td><td>1667.5446255207062</td><td>982148.0</td></tr><tr><td>hnswlib</td><td>hnswlib ({‘M’: 64, ‘efConstruction’: 200}, ef: 80)</td><td>0.9901500000000001</td><td>3731.2651844102425</td><td>496.65849924087524</td><td>1150800.0</td></tr><tr><td>hnswlib</td><td>hnswlib ({‘M’: 96, ‘efConstruction’: 200}, ef: 80)</td><td>0.9902599999999999</td><td>3616.44180507205</td><td>513.7249546051025</td><td>1400632.0</td></tr><tr><td>hnswlib</td><td>hnswlib ({‘M’: 36, ‘efConstruction’: 500}, ef: 80)</td><td>0.99308</td><td>3571.6658501707066</td><td>1156.385510444641</td><td>931660.0</td></tr><tr><td>hnswlib</td><td>hnswlib ({‘M’: 24, ‘efConstruction’: 200}, ef: 120)</td><td>0.9939</td><td>3314.9200264352426</td><td>426.75320744514465</td><td>838564.0</td></tr><tr><td>hnswlib</td><td>hnswlib ({‘M’: 48, ‘efConstruction’: 500}, ef: 80)</td><td>0.99433</td><td>3290.7135482210724</td><td>1246.9214706420898</td><td>1026148.0</td></tr><tr><td>hnswlib</td><td>hnswlib ({‘M’: 64, ‘efConstruction’: 500}, ef: 80)</td><td>0.9946999999999999</td><td>3153.6867226554614</td><td>1276.8294219970703</td><td>1146332.0</td></tr><tr><td>hnswlib</td><td>hnswlib ({‘M’: 24, ‘efConstruction’: 500}, ef: 120)</td><td>0.9955999999999999</td><td>3139.927141602247</td><td>1008.0483357906342</td><td>838676.0</td></tr><tr><td>hnswlib</td><td>hnswlib ({‘M’: 12, ‘efConstruction’: 200}, ef: 200)</td><td>0.9920199999999999</td><td>3100.2119285498034</td><td>313.95580410957336</td><td>745664.0</td></tr><tr><td>hnswlib</td><td>hnswlib ({‘M’: 12, ‘efConstruction’: 500}, ef: 200)</td><td>0.99271</td><td>3040.3355289720653</td><td>709.9178235530853</td><td>745132.0</td></tr><tr><td>hnswlib</td><td>hnswlib ({‘M’: 96, ‘efConstruction’: 500}, ef: 80)</td><td>0.9949</td><td>3036.296166689699</td><td>1317.8283751010895</td><td>1400940.0</td></tr><tr><td>hnswlib</td><td>hnswlib ({‘M’: 36, ‘efConstruction’: 200}, ef: 120)</td><td>0.99544</td><td>2873.9128879689624</td><td>466.08784890174866</td><td>931436.0</td></tr><tr><td>hnswlib</td><td>hnswlib ({‘M’: 48, ‘efConstruction’: 200}, ef: 120)</td><td>0.9956799999999999</td><td>2690.4460742892884</td><td>482.9417383670807</td><td>1025096.0</td></tr><tr><td>hnswlib</td><td>hnswlib ({‘M’: 64, ‘efConstruction’: 200}, ef: 120)</td><td>0.99576</td><td>2671.663602183599</td><td>496.65849924087524</td><td>1150800.0</td></tr><tr><td>hnswlib</td><td>hnswlib ({‘M’: 36, ‘efConstruction’: 500}, ef: 120)</td><td>0.99753</td><td>2612.247989122775</td><td>1156.385510444641</td><td>931660.0</td></tr><tr><td>hnswlib</td><td>hnswlib ({‘M’: 96, ‘efConstruction’: 200}, ef: 120)</td><td>0.99588</td><td>2581.161300550079</td><td>513.7249546051025</td><td>1400632.0</td></tr><tr><td>hnswlib</td><td>hnswlib ({‘M’: 16, ‘efConstruction’: 200}, ef: 200)</td><td>0.9962</td><td>2565.1980331237614</td><td>364.242990732193</td><td>778360.0</td></tr><tr><td>hnswlib</td><td>hnswlib ({‘M’: 48, ‘efConstruction’: 500}, ef: 120)</td><td>0.9979100000000001</td><td>2394.6802442922076</td><td>1246.9214706420898</td><td>1026148.0</td></tr><tr><td>hnswlib</td><td>hnswlib ({‘M’: 64, ‘efConstruction’: 500}, ef: 120)</td><td>0.9980800000000001</td><td>2282.691070497442</td><td>1276.8294219970703</td><td>1146332.0</td></tr><tr><td>hnswlib</td><td>hnswlib ({‘M’: 96, ‘efConstruction’: 500}, ef: 120)</td><td>0.99821</td><td>2188.4360442789643</td><td>1317.8283751010895</td><td>1400940.0</td></tr><tr><td>hnswlib</td><td>hnswlib ({‘M’: 24, ‘efConstruction’: 200}, ef: 200)</td><td>0.99818</td><td>2166.896152958348</td><td>426.75320744514465</td><td>838564.0</td></tr><tr><td>hnswlib</td><td>hnswlib ({‘M’: 8, ‘efConstruction’: 200}, ef: 400)</td><td>0.99244</td><td>2138.951169866413</td><td>256.2939279079437</td><td>715140.0</td></tr><tr><td>hnswlib</td><td>hnswlib ({‘M’: 8, ‘efConstruction’: 500}, ef: 400)</td><td>0.9936</td><td>2124.6338197635687</td><td>588.7308986186981</td><td>715372.0</td></tr><tr><td>hnswlib</td><td>hnswlib ({‘M’: 24, ‘efConstruction’: 500}, ef: 200)</td><td>0.9989100000000001</td><td>2017.995520316913</td><td>1008.0483357906342</td><td>838676.0</td></tr></tbody></table><h3 id="Build-Index-Time"><a href="#Build-Index-Time" class="headerlink" title="Build Index Time"></a>Build Index Time</h3><table><thead><tr><th>algorithm</th><th>parameters</th><th>indexsize</th><th>build</th></tr></thead><tbody><tr><td>hnswlib</td><td>hnswlib ({‘M’: 8, ‘efConstruction’: 200}, ef: 400)</td><td>715140.0</td><td>256.2939279079437</td></tr><tr><td>hnswlib</td><td>hnswlib ({‘M’: 12, ‘efConstruction’: 200}, ef: 200)</td><td>745664.0</td><td>313.95580410957336</td></tr><tr><td>hnswlib</td><td>hnswlib ({‘M’: 16, ‘efConstruction’: 200}, ef: 200)</td><td>778360.0</td><td>364.242990732193</td></tr><tr><td>hnswlib</td><td>hnswlib ({‘M’: 24, ‘efConstruction’: 200}, ef: 120)</td><td>838564.0</td><td>426.75320744514465</td></tr><tr><td>hnswlib</td><td>hnswlib ({‘M’: 36, ‘efConstruction’: 200}, ef: 120)</td><td>931436.0</td><td>466.08784890174866</td></tr><tr><td>hnswlib</td><td>hnswlib ({‘M’: 48, ‘efConstruction’: 200}, ef: 120)</td><td>1025096.0</td><td>482.9417383670807</td></tr><tr><td>hnswlib</td><td>hnswlib ({‘M’: 64, ‘efConstruction’: 200}, ef: 120)</td><td>1150800.0</td><td>496.65849924087524</td></tr><tr><td>hnswlib</td><td>hnswlib ({‘M’: 96, ‘efConstruction’: 200}, ef: 80)</td><td>1400632.0</td><td>513.7249546051025</td></tr><tr><td>hnswlib</td><td>hnswlib ({‘M’: 8, ‘efConstruction’: 500}, ef: 400)</td><td>715372.0</td><td>588.7308986186981</td></tr><tr><td>hnswlib</td><td>hnswlib ({‘M’: 12, ‘efConstruction’: 500}, ef: 200)</td><td>745132.0</td><td>709.9178235530853</td></tr><tr><td>hnswlib</td><td>hnswlib ({‘M’: 24, ‘efConstruction’: 500}, ef: 120)</td><td>838676.0</td><td>1008.0483357906342</td></tr><tr><td>hnswlib</td><td>hnswlib ({‘M’: 36, ‘efConstruction’: 500}, ef: 120)</td><td>931660.0</td><td>1156.385510444641</td></tr><tr><td>hnswlib</td><td>hnswlib ({‘M’: 48, ‘efConstruction’: 500}, ef: 120)</td><td>1026148.0</td><td>1246.9214706420898</td></tr><tr><td>hnswlib</td><td>hnswlib ({‘M’: 64, ‘efConstruction’: 500}, ef: 120)</td><td>1146332.0</td><td>1276.8294219970703</td></tr><tr><td>faiss_hnsw</td><td>faiss ({‘M’: 16, ‘efConstruction’: 500}, ef: 120)</td><td>732492.0</td><td>1285.849939107895</td></tr><tr><td>hnswlib</td><td>hnswlib ({‘M’: 96, ‘efConstruction’: 500}, ef: 120)</td><td>1400940.0</td><td>1317.8283751010895</td></tr><tr><td>faiss_hnsw</td><td>faiss ({‘M’: 24, ‘efConstruction’: 500}, ef: 80)</td><td>794864.0</td><td>1458.773098230362</td></tr><tr><td>faiss_hnsw</td><td>faiss ({‘M’: 36, ‘efConstruction’: 500}, ef: 80)</td><td>888936.0</td><td>1585.1033165454865</td></tr><tr><td>faiss_hnsw</td><td>faiss ({‘M’: 48, ‘efConstruction’: 500}, ef: 80)</td><td>982148.0</td><td>1667.5446255207062</td></tr></tbody></table><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>1.efConstruction越小，build 耗费时间越小，牺牲的精确性可以通过加大ef来弥补, 要想获取最佳性能需要对M，efConstruction, ef这三个参数进行平衡<br>2.indexsize 只和M有关系<br>3.整体而言，hnswlib的性能仍然要比faiss的hnsw的要好一点, 两者差距不大<br>4.efConstruction&#x3D;200的情况下通过适当调大ef也能实现较高的召回率，也不会带来性能损失，但是对Build Index Time 会有较大的提升</p><h1 id="其他细节指标解读"><a href="#其他细节指标解读" class="headerlink" title="其他细节指标解读"></a>其他细节指标解读</h1><ol><li>ann-benchmarks中通过python data_export.py可以得出详细的指标数据, 其中有两列<code>epsilon</code>, <code>largeepsilon</code><br>这里其实对应得是在算recall的时候，允许的距离误差大小(使用euclidean距离，就是向量召回的点和实际的knn的点距离误差), <code>epsilon</code> 是0.01， <code>largeepsilon</code>, 允许的误差越大，对应的recall 就越高, 论文中的实际公式如下:</li></ol><p><img src="/../../imgs/recall_epsilon.png"></p><ol start="2"><li>indexsize在graph base的算法中都挺大的，不过整体上hnswlib的更小一点</li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol><li><p>这里列举都是在特定数据集下的表现，事实上不同数据集下不同类型的算法表现不尽相同，hnswlib不是在任何情况下的表现都由于faiss_hnsw， 那在实际的生产环境中，还是需要对不同的算法进行benchmark，从而得出更好的参数和选出更好的算法</p></li><li><p>ann-benchmarks的论文指出虽然graph-based的算法在rand-euclidean的数据集下性能还不如faiss-ivf，但是在实际的数据集上，往往会有所谓的global structure出现，graph based的算法一般都是更好的选择，graph based中的hnsw也是更好的选择</p></li><li><p>ann-benchmarks也指出如果使用GPU的话，graph based的算法不如ivf这种简单的算法</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;hnswlib和faiss-hnsw在ann-benchmark中的参数解读&quot;&gt;&lt;a href=&quot;#hnswlib和faiss-hnsw在ann-benchmark中的参数解读&quot; class=&quot;headerlink&quot; title=&quot;hnswlib和faiss_hn</summary>
      
    
    
    
    
    <category term="algorithm hnsw 向量数据库 faiss hnswlib" scheme="https://skyitachi.github.io/tags/algorithm-hnsw-%E5%90%91%E9%87%8F%E6%95%B0%E6%8D%AE%E5%BA%93-faiss-hnswlib/"/>
    
  </entry>
  
  <entry>
    <title>HNSW算法原理及其实现</title>
    <link href="https://skyitachi.github.io/2024/07/22/HNSW%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/"/>
    <id>https://skyitachi.github.io/2024/07/22/HNSW%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/</id>
    <published>2024-07-21T16:00:00.000Z</published>
    <updated>2024-07-21T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h1><ul><li>介绍HNSW的算法原理</li><li>介绍hnswlib和faiss中的实现，以及他们之间的区别</li><li>介绍HNSW中每个参数的实际影响</li></ul><h1 id="HNSW的算法原理"><a href="#HNSW的算法原理" class="headerlink" title="HNSW的算法原理"></a>HNSW的算法原理</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ol><li>HNSW的算法大致原理很像skplist，区别在于hnsw每层维护的是节点直接的链接（links）,每一层都是graph的结构，相同点就是每下一层的节点数更多,维护的图也越大，到了0层维护了所有节点的链接信息</li><li>无论是插入还是查找，都是从上往下找enter point（当前层和插入或者查询点最接近的点）,到了下一层时候，通过在enter point的链接的点中早出指定数量的候选集，并选出和目标点最接近的指定数量的点，建立连接</li><li>插入算法还需要维护当前的enter point</li></ol><h2 id="具体算法"><a href="#具体算法" class="headerlink" title="具体算法"></a>具体算法</h2><p>论文中有提到一些最佳参数设置，mL &#x3D; 1&#x2F;ln(M), Mmax &#x3D; M, Mmax0 &#x3D; M * 2 可以直接带入算法中的参数，减少未知量，看起来会清晰一点，其中hnswlib的实现就是按照这组参数来的</p><h3 id="SEARCH-LAYER算法"><a href="#SEARCH-LAYER算法" class="headerlink" title="SEARCH-LAYER算法"></a>SEARCH-LAYER算法</h3><p>SEARCH-LAYER(q, ep, ef, lc)</p><p>Input: query element q, enter points ep, number of nearest to q elements to return ef, layer number lc</p><p>Output: ef closest neighbors to q</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">v ← ep // set of visited elements</span><br><span class="line">C ← ep // set of candidates</span><br><span class="line">W ← ep // dynamic list of found nearest neighbors</span><br><span class="line"></span><br><span class="line">while │C│ &gt; 0</span><br><span class="line">  c ← extract nearest element from C to q</span><br><span class="line">  f ← get furthest element from W to q</span><br><span class="line"></span><br><span class="line">  if distance(c, q) &gt; distance(f, q)</span><br><span class="line">break // all elements in W are evaluated</span><br><span class="line">  for each e ∈ neighbourhood(c) at layer lc // update C and W</span><br><span class="line">if e ∉ v</span><br><span class="line">  v ← v ⋃ e</span><br><span class="line">f ← get furthest element from W to q</span><br><span class="line">if distance(e, q) &lt; distance(f, q) or │W│ &lt; ef</span><br><span class="line">  C ← C ⋃ e</span><br><span class="line">  W ← W ⋃ e</span><br><span class="line">  if │W│ &gt; ef</span><br><span class="line">remove furthest element from W to q</span><br><span class="line"></span><br><span class="line">return W</span><br></pre></td></tr></table></figure><h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><ul><li>ep可以是由多个点组成的集合，也可以是单个点</li></ul><h3 id="插入算法"><a href="#插入算法" class="headerlink" title="插入算法"></a>插入算法</h3><p>INSERT(hnsw, q, M, Mmax, efConstruction, mL)</p><p>Input: multilayer graph hnsw, new element q, number of established connections M, maximum number of connections for each element per layer Mmax, size of the dynamic candidate list efConstruction, normalization factor for level generation mL</p><p>Output: update hnsw inserting element q</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">W ← ∅ // list for the currently found nearest elements</span><br><span class="line">ep ← get enter point for hnsw</span><br><span class="line">L ← level of ep // top layer for hnsw</span><br><span class="line">l ← ⌊-ln(unif(0..1))∙mL⌋ // new element’s level</span><br><span class="line"></span><br><span class="line">for lc ← L … l+1</span><br><span class="line">  W ← SEARCH-LAYER(q, ep, ef=1, lc)</span><br><span class="line">  ep ← get the nearest element from W to q</span><br><span class="line">for lc ← min(L, l) … 0</span><br><span class="line">  W ← SEARCH-LAYER(q, ep, efConstruction, lc)</span><br><span class="line">  neighbors ← SELECT-NEIGHBORS(q, W, M, lc) // alg. 3 or alg. 4 </span><br><span class="line"> add bidirectionall connectionts from neighbors to q at layer lc</span><br><span class="line">for each e ∈ neighbors // shrink connections if needed</span><br><span class="line">  eConn ← neighbourhood(e) at layer lc</span><br><span class="line">  if │eConn│ &gt; Mmax // shrink connections of e</span><br><span class="line">if lc = 0 then Mmax = Mmax0</span><br><span class="line">eNewConn ← SELECT-NEIGHBORS(e, eConn, Mmax, lc)</span><br><span class="line">  // alg. 3 or alg. 4</span><br><span class="line">  set neighbourhood(e) at layer lc to eNewConn</span><br><span class="line">ep ← W</span><br><span class="line"></span><br><span class="line">if l &gt; L</span><br><span class="line">  set enter point for hnsw to q</span><br></pre></td></tr></table></figure><h4 id="entry-point的更新"><a href="#entry-point的更新" class="headerlink" title="entry point的更新"></a>entry point的更新</h4><ul><li>新插入的节点最终会变为全局的enter pointer</li><li>level0会维护2*M的链接</li></ul><h3 id="搜索算法"><a href="#搜索算法" class="headerlink" title="搜索算法"></a>搜索算法</h3><p>K-NN-SEARCH(hnsw, q, K, ef)</p><p>Input: multilayer graph hnsw, query element q, number of nearest neighbors to return K, size of the dynamic candidate list ef</p><p>Output: K nearest elements to q</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">W ← ∅ // set for the current nearest elements</span><br><span class="line">ep ← get enter point for hnsw</span><br><span class="line">L ← level of ep // top layer for hnsw</span><br><span class="line">for lc ← L … 1</span><br><span class="line">  W ← SEARCH-LAYER(q, ep, ef=1, lc)</span><br><span class="line">  ep ← get nearest element from W to q</span><br><span class="line"></span><br><span class="line">W ← SEARCH-LAYER(q, ep, ef, lc =0)</span><br><span class="line">return K nearest elements from W to q</span><br></pre></td></tr></table></figure><h4 id="说明-1"><a href="#说明-1" class="headerlink" title="说明"></a>说明</h4><ul><li><p>搜索过程从L-&gt;1 层每层只搜和query最近的enter point, 这就要求数据集是要有一定结构的，这样才能保证在最后一层搜索的时候质量不至于太差，如果是随机的数据集可能结果会不太好</p></li><li><p>efSearch要大于K才行(faiss里会保证efSearch最少是k)</p></li></ul><h3 id="SELECT-NEIGHBORS-算法"><a href="#SELECT-NEIGHBORS-算法" class="headerlink" title="SELECT-NEIGHBORS 算法"></a>SELECT-NEIGHBORS 算法</h3><h4 id="简单算法"><a href="#简单算法" class="headerlink" title="简单算法"></a>简单算法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT-NEIGHBORS-SIMPLE(q, C, M)</span><br><span class="line">Input: base element q, candidate elements C, number of neighbors to return M</span><br><span class="line"></span><br><span class="line">Output: M nearest elements to q</span><br><span class="line">return M nearest elements from C to q</span><br><span class="line">// 实际的实现就是一个优先权队列</span><br></pre></td></tr></table></figure><h4 id="启发式方法"><a href="#启发式方法" class="headerlink" title="启发式方法"></a>启发式方法</h4><p>SELECT-NEIGHBORS-HEURISTIC(q, C, M, lc, extendCandidates, keepPrunedConnections)</p><p>Input: base element q, candidate elements C, number of neighbors to return M, layer number lc, flag indicating whether or not to extend<br>candidate list extendCandidates, flag indicating whether or not to add discarded elements keepPrunedConnections</p><p>Output: M elements selected by the heuristic</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">R ← ∅</span><br><span class="line">W ← C // working queue for the candidates</span><br><span class="line">if extendCandidates // extend candidates by their neighbors</span><br><span class="line">  for each e ∈ C</span><br><span class="line">    for each eadj ∈ neighbourhood(e) at layer lc</span><br><span class="line">      if eadj ∉ W</span><br><span class="line">    W ← W ⋃ eadj</span><br><span class="line"></span><br><span class="line">Wd ← ∅ // queue for the discarded candidates</span><br><span class="line">while │W│ &gt; 0 and │R│&lt; M</span><br><span class="line">  e ← extract nearest element from W to q</span><br><span class="line">    if e is closer to q compared to any element from R</span><br><span class="line">  R ← R ⋃ e</span><br><span class="line">else</span><br><span class="line">  Wd ← Wd ⋃ e</span><br><span class="line"></span><br><span class="line">if keepPrunedConnections // add some of the discarded </span><br><span class="line">  // connections from Wd</span><br><span class="line">  while │Wd│&gt; 0 and │R│&lt; M</span><br><span class="line">    R ← R ⋃ extract nearest element from Wd to q</span><br><span class="line"></span><br><span class="line">return R</span><br></pre></td></tr></table></figure><h4 id="说明-2"><a href="#说明-2" class="headerlink" title="说明"></a>说明</h4><ul><li>第一种方法只从candidates选择，第二种方法从candidates里的邻接的点里选择（选择范围更大, 可能受数据集的影响较小）</li><li>hnswlib和faiss_hnsw都相当于用了第一种方法</li><li>启发式方法适合中维数据和多clustering的数据( mid-dimensional data and for the case of highly clustered data)</li></ul><h1 id="HNSW每个参数实际的影响"><a href="#HNSW每个参数实际的影响" class="headerlink" title="HNSW每个参数实际的影响"></a>HNSW每个参数实际的影响</h1><ul><li>dim: 数据维度，dim 越大计算量越大</li><li>max_elements: 数据总量</li><li>M: 每个向量的最大链接数, M越大占用的内存越大, 构建和搜索也是越慢（精度更高） </li><li>efConstruction: 每个向量构建或者搜索时的候选集大小，efConstruction越大，构建和搜索速度越慢 (不会影响内存消耗)</li></ul><h2 id="M-应该如何选择"><a href="#M-应该如何选择" class="headerlink" title="M 应该如何选择"></a>M 应该如何选择</h2><ul><li>论文中指出<code>A reasonable range of M is from 5 to 48</code></li></ul><h2 id="efConstruction"><a href="#efConstruction" class="headerlink" title="efConstruction"></a>efConstruction</h2><ul><li>efConstruction 对speed&#x2F;index quality有显著影响</li><li>论文中指出10M的sift dataset，用efConstruction&#x3D;100就能达到不错的召回率(0.95), 适用多线程并发构建的话速度也不错 </li><li>进一步提升efConstruction带来的收益并不明显，反而会较大影响构建速度</li></ul><h2 id="efSearch"><a href="#efSearch" class="headerlink" title="efSearch"></a>efSearch</h2><ul><li>搜索时候用到ef值，hnswlib和faiss_hnsw都可以单独设置</li><li>合适的efSearch能保证recall</li><li>efSearch也不是越高越好，边际效应越来越小，也会影响到搜索速度</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>关于详细的性能数据可以参考论文</li><li>测试性能的时候关键指标是 <code>Distance Computations</code>, <code>Query Time</code></li><li>可以使用PQ（乘积量化）的方式优化memory</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;主要内容&quot;&gt;&lt;a href=&quot;#主要内容&quot; class=&quot;headerlink&quot; title=&quot;主要内容&quot;&gt;&lt;/a&gt;主要内容&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;介绍HNSW的算法原理&lt;/li&gt;
&lt;li&gt;介绍hnswlib和faiss中的实现，以及他们之间的区别&lt;/li&gt;
</summary>
      
    
    
    
    
    <category term="algorithm hnsw 向量数据库" scheme="https://skyitachi.github.io/tags/algorithm-hnsw-%E5%90%91%E9%87%8F%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>ES和Lucene之间的CRUD操作映射</title>
    <link href="https://skyitachi.github.io/2024/05/11/ES%E5%92%8CLucene%E4%B9%8B%E9%97%B4%E7%9A%84CRUD%E6%93%8D%E4%BD%9C%E6%98%A0%E5%B0%84/"/>
    <id>https://skyitachi.github.io/2024/05/11/ES%E5%92%8CLucene%E4%B9%8B%E9%97%B4%E7%9A%84CRUD%E6%93%8D%E4%BD%9C%E6%98%A0%E5%B0%84/</id>
    <published>2024-05-10T16:00:00.000Z</published>
    <updated>2024-07-06T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在ES中我们经常使用的数据格式json，ES也支持常见的CRUD操作，这里我们主要介绍写入相关的操作（创建，更新，删除），ES的底层存储引擎是Lucene，Lucene也有相关创建更新删除的操作，但是Lucene是没有显示的根据主键更新文档的api的，本文主要介绍的是在ES有_id的情况下，ES是如何基于Lucene实现增删改的操作的，其中的数据模型又是如何映射的.</p><p>ps: 本文不考虑ES中的数据类型到Lucene中的数据类型的映射（Field），所有的代码片段都是基于以下给定的类型映射</p><table><thead><tr><th>Name</th><th>ES type</th><th>Lucene Field</th></tr></thead><tbody><tr><td>item_id</td><td>keyword</td><td>StringField</td></tr><tr><td>name</td><td>keyword</td><td>StringField</td></tr><tr><td>color</td><td>keyword</td><td>StringField</td></tr></tbody></table><h3 id="lucene-如何基于id（主键）部分更新文档-基于lucene-9-7-0"><a href="#lucene-如何基于id（主键）部分更新文档-基于lucene-9-7-0" class="headerlink" title="lucene 如何基于id（主键）部分更新文档 (基于lucene 9.7.0)"></a>lucene 如何基于id（主键）部分更新文档 (基于lucene 9.7.0)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> &lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.apache.lucene&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;lucene-core&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;9.7.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h4 id="1-创建文档"><a href="#1-创建文档" class="headerlink" title="1. 创建文档"></a>1. 创建文档</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public static void createDocuments(IndexWriter indexWriter) throws IOException &#123;</span><br><span class="line">Document doc1 = new Document();</span><br><span class="line">doc1.add(new StringField(&quot;item_id&quot;, &quot;1&quot;, Field.Store.YES ));</span><br><span class="line">doc1.add(new StringField(&quot;name&quot;, &quot;item1&quot;, Field.Store.YES));</span><br><span class="line">doc1.add(new StringField(&quot;color&quot;, &quot;red&quot;, Field.Store.YES));</span><br><span class="line"></span><br><span class="line">Document doc2 = new Document();</span><br><span class="line">doc2.add(new StringField(&quot;item_id&quot;, &quot;2&quot;, Field.Store.YES));</span><br><span class="line">doc2.add(new StringField(&quot;name&quot;, &quot;item2&quot;, Field.Store.YES));</span><br><span class="line">doc2.add(new StringField(&quot;color&quot;, &quot;blue&quot;, Field.Store.YES));</span><br><span class="line"></span><br><span class="line">indexWriter.addDocument(doc1);</span><br><span class="line">indexWriter.addDocument(doc2);</span><br><span class="line"></span><br><span class="line">indexWriter.commit();</span><br><span class="line">indexWriter.flush();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-读取文档验证写入"><a href="#2-读取文档验证写入" class="headerlink" title="2. 读取文档验证写入"></a>2. 读取文档验证写入</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public static void getDocumentById(IndexReader reader, IndexSearcher searcher, String itemId) throws IOException &#123;</span><br><span class="line">Query query = new TermQuery(new Term(&quot;item_id&quot;, itemId));</span><br><span class="line">TopDocs topdocs = searcher.search(query, 10);</span><br><span class="line">assert topdocs.totalHits.value == 1;</span><br><span class="line"></span><br><span class="line">for (ScoreDoc doc: topdocs.scoreDocs) &#123;</span><br><span class="line">int docId = doc.doc;</span><br><span class="line">Document fullDoc = getDocumentByDocId(reader, docId);</span><br><span class="line"></span><br><span class="line">fullDoc.getFields().forEach(field -&gt; &#123;</span><br><span class="line">System.out.println(&quot;  &quot; + field.name() + &quot;: &quot; + field.stringValue());</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// item_id = &quot;1&quot;</span><br><span class="line">getDocumentById(reader, searcher, &quot;1&quot;);</span><br><span class="line">//  item_id: 1</span><br><span class="line">//  name: item1</span><br><span class="line">//  color: red</span><br><span class="line">getDocumentById(reader, searcher, &quot;2&quot;);</span><br><span class="line">//  item_id: 2</span><br><span class="line">//  name: item2</span><br><span class="line">//  color: blue</span><br></pre></td></tr></table></figure><h4 id="3-部分更新文档"><a href="#3-部分更新文档" class="headerlink" title="3. 部分更新文档"></a>3. 部分更新文档</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static void partialUpdateDocumentNameByItemId(IndexWriter writer, String itemId, String newName) throws IOException &#123;</span><br><span class="line">Document doc = new Document();</span><br><span class="line">doc.add(new StringField(&quot;name&quot;, newName, Field.Store.YES));</span><br><span class="line">// important: 这个作为主键的Term一定要带上</span><br><span class="line">doc.add(new StringField(&quot;item_id&quot;, itemId, Field.Store.YES));</span><br><span class="line">Term mainTerm = new Term(&quot;item_id&quot;, itemId);</span><br><span class="line">writer.updateDocument(mainTerm, doc);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="4-验证更新文档"><a href="#4-验证更新文档" class="headerlink" title="4. 验证更新文档"></a>4. 验证更新文档</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">partialUpdateDocumentNameByItemId(indexWriter, &quot;1&quot;, &quot;item1_updated&quot;);</span><br><span class="line">partialUpdateDocumentNameByItemId(indexWriter, &quot;2&quot;, &quot;item2_updated&quot;);</span><br><span class="line">indexWriter.commit();</span><br><span class="line">indexWriter.flush();</span><br><span class="line"></span><br><span class="line">indexReader = DirectoryReader.open(readDirectory);</span><br><span class="line">indexSearcher = new IndexSearcher(indexReader);</span><br><span class="line">getDocumentById(indexSearcher, &quot;1&quot;);</span><br><span class="line"></span><br><span class="line">indexReader = DirectoryReader.open(readDirectory);</span><br><span class="line">indexSearcher = new IndexSearcher(indexReader);</span><br><span class="line">getDocumentById(indexSearcher, &quot;2&quot;);</span><br><span class="line">//</span><br><span class="line">//  name: item1_updated</span><br><span class="line">//  item_id: 1</span><br><span class="line">//  name: item2_updated</span><br><span class="line">//  item_id: 2</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>结论： 由于在partialUpdateDocumentNameByItemId 中只写了item_id和name属性（符合update的直觉），但是可以看出Lucene把updateDocument中的doc对象当成了最新且完整的mainTerm对应的doc，这就导致了虽然我们目的是部分更新，但是会丢失没有写入（没有变化）的那些属性，这个例子也可以看出Lucene本质上是用新文档覆盖旧文档的形式，用一个可以代表主键的Term做关联，来实现部分更新字段的目的，这个和一般RDBMS的存储模型有点区别.</p><h4 id="5-完全更新所有字段（不变的field也要加入将要更新的document中）"><a href="#5-完全更新所有字段（不变的field也要加入将要更新的document中）" class="headerlink" title="5. 完全更新所有字段（不变的field也要加入将要更新的document中）"></a>5. 完全更新所有字段（不变的field也要加入将要更新的document中）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static void fullUpdateDocumentNameByItemId(IndexWriter writer, String itemId, String newName, String oldColor) throws IOException &#123;</span><br><span class="line">Document doc = new Document();</span><br><span class="line">doc.add(new StringField(&quot;name&quot;, newName, Field.Store.YES));</span><br><span class="line">doc.add(new StringField(&quot;item_id&quot;, itemId, Field.Store.YES));</span><br><span class="line">doc.add(new StringField(&quot;color&quot;, oldColor, Field.Store.YES));</span><br><span class="line"></span><br><span class="line">Term mainTerm = new Term(&quot;item_id&quot;, itemId);</span><br><span class="line">writer.updateDocument(mainTerm, doc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-验证完全更新"><a href="#6-验证完全更新" class="headerlink" title="6. 验证完全更新"></a>6. 验证完全更新</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">fullUpdateDocumentNameByItemId(indexWriter, &quot;1&quot;, &quot;item1_updated&quot;, &quot;red&quot;);</span><br><span class="line">fullUpdateDocumentNameByItemId(indexWriter, &quot;2&quot;, &quot;item2_updated&quot;, &quot;blue&quot;);</span><br><span class="line"></span><br><span class="line">indexWriter.commit();</span><br><span class="line">indexWriter.flush();</span><br><span class="line"></span><br><span class="line">indexReader = DirectoryReader.open(readDirectory);</span><br><span class="line">indexSearcher = new IndexSearcher(indexReader);</span><br><span class="line">getDocumentById(indexSearcher, &quot;1&quot;);</span><br><span class="line"></span><br><span class="line">indexReader = DirectoryReader.open(readDirectory);</span><br><span class="line">indexSearcher = new IndexSearcher(indexReader);</span><br><span class="line">getDocumentById(indexSearcher, &quot;2&quot;);</span><br><span class="line"></span><br><span class="line">// output</span><br><span class="line">//  name: item1_updated</span><br><span class="line">//  item_id: 1</span><br><span class="line">//  color: red</span><br><span class="line">//  name: item2_updated</span><br><span class="line">//  item_id: 2</span><br><span class="line">//  color: blue</span><br></pre></td></tr></table></figure><h4 id="7-删除文档"><a href="#7-删除文档" class="headerlink" title="7. 删除文档"></a>7. 删除文档</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static void deleteDocument(IndexWriter writer, String itemId) throws IOException &#123;</span><br><span class="line">    Term mainTerm = new Term(&quot;item_id&quot;, itemId);</span><br><span class="line">    writer.deleteDocuments(mainTerm);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-验证删除文档"><a href="#8-验证删除文档" class="headerlink" title="8. 验证删除文档"></a>8. 验证删除文档</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">getDocumentById(indexSearcher, &quot;1&quot;);</span><br><span class="line">getDocumentById(indexSearcher, &quot;2&quot;);</span><br><span class="line"></span><br><span class="line">// cannot found 1</span><br><span class="line">// cannot found 2</span><br></pre></td></tr></table></figure><p>结论： </p><ol><li>必须将原始文档的所有字段全部获取到再用updateDocument的方式更新，才能实现我们预期中部分更新字段的目的，可以看到成本还是比较高的</li><li>由于Lucene的这种机制也导致了，ES的CRUD模型中需要实现一些额外的机制才能使用到Lucene的能力</li></ol><h3 id="ES中的操作"><a href="#ES中的操作" class="headerlink" title="ES中的操作"></a>ES中的操作</h3><h4 id="ES-mapping"><a href="#ES-mapping" class="headerlink" title="ES mapping"></a>ES mapping</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">PUT /my_index</span><br><span class="line">&#123;</span><br><span class="line">  &quot;mappings&quot;: &#123;</span><br><span class="line">    &quot;properties&quot;: &#123;</span><br><span class="line">      &quot;item_id&quot;: &#123;</span><br><span class="line">        &quot;type&quot;: &quot;keyword&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;name&quot;: &#123;</span><br><span class="line">        &quot;type&quot;: &quot;keyword&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;color&quot;: &#123;</span><br><span class="line">        &quot;type&quot;: &quot;keyword&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-创建文档-1"><a href="#1-创建文档-1" class="headerlink" title="1. 创建文档"></a>1. 创建文档</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">PUT my_index/_doc/1</span><br><span class="line">&#123;</span><br><span class="line">  &quot;item_id&quot;: &quot;1&quot;,</span><br><span class="line">  &quot;name&quot;:&quot;item1&quot;,</span><br><span class="line">  &quot;color&quot;: &quot;red&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT my_index/_doc/2</span><br><span class="line">&#123;</span><br><span class="line">  &quot;item_id&quot;: &quot;2&quot;,</span><br><span class="line">  &quot;name&quot;:&quot;item2&quot;,</span><br><span class="line">  &quot;color&quot;: &quot;blue&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-获取文档"><a href="#2-获取文档" class="headerlink" title="2. 获取文档"></a>2. 获取文档</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">GET my_index/_search</span><br><span class="line">// output</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">&quot;hits&quot;: [</span><br><span class="line">&#123;</span><br><span class="line">&quot;_index&quot;: &quot;my_index&quot;,</span><br><span class="line">&quot;_id&quot;: &quot;1&quot;,</span><br><span class="line">&quot;_score&quot;: 1,</span><br><span class="line">&quot;_source&quot;: &#123;</span><br><span class="line">&quot;item_id&quot;: &quot;1&quot;,</span><br><span class="line">&quot;name&quot;: &quot;item1&quot;,</span><br><span class="line">&quot;color&quot;: &quot;red&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">&quot;_index&quot;: &quot;my_index&quot;,</span><br><span class="line">&quot;_id&quot;: &quot;2&quot;,</span><br><span class="line">&quot;_score&quot;: 1,</span><br><span class="line">&quot;_source&quot;: &#123;</span><br><span class="line">&quot;item_id&quot;: &quot;2&quot;,</span><br><span class="line">&quot;name&quot;: &quot;item2&quot;,</span><br><span class="line">&quot;color&quot;: &quot;blue&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-部分更新"><a href="#3-部分更新" class="headerlink" title="3.部分更新"></a>3.部分更新</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">POST my_index/_update/1</span><br><span class="line">&#123;</span><br><span class="line">  &quot;doc&quot;: &#123;</span><br><span class="line">    &quot;name&quot;: &quot;item1_updated&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">POST my_index/_update/2</span><br><span class="line">&#123;</span><br><span class="line">  &quot;doc&quot;: &#123;</span><br><span class="line">    &quot;name&quot;: &quot;item2_updated&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-获取部分更新后的文档"><a href="#4-获取部分更新后的文档" class="headerlink" title="4.获取部分更新后的文档"></a>4.获取部分更新后的文档</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">GET my_index/_search</span><br><span class="line">// output</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">&quot;hits&quot;: [</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;_index&quot;: &quot;my_index&quot;,</span><br><span class="line">        &quot;_id&quot;: &quot;1&quot;,</span><br><span class="line">        &quot;_score&quot;: 1,</span><br><span class="line">        &quot;_source&quot;: &#123;</span><br><span class="line">          &quot;item_id&quot;: &quot;1&quot;,</span><br><span class="line">          &quot;name&quot;: &quot;item1_updated&quot;,</span><br><span class="line">          &quot;color&quot;: &quot;red&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;_index&quot;: &quot;my_index&quot;,</span><br><span class="line">        &quot;_id&quot;: &quot;2&quot;,</span><br><span class="line">        &quot;_score&quot;: 1,</span><br><span class="line">        &quot;_source&quot;: &#123;</span><br><span class="line">          &quot;item_id&quot;: &quot;2&quot;,</span><br><span class="line">          &quot;name&quot;: &quot;item2_updated&quot;,</span><br><span class="line">          &quot;color&quot;: &quot;blue&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明: 可以看ES中部分更新是可以正常的工作的, 原因就在于ES在处理update的时候会自动拉取原始文档的所有字段和新的更新的字段组合成一份完整的新的全量字段的文档，再去更新Lucene</p><h4 id="5-完整更新所有字段"><a href="#5-完整更新所有字段" class="headerlink" title="5. 完整更新所有字段"></a>5. 完整更新所有字段</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 方式一</span><br><span class="line">POST my_index/_update/1</span><br><span class="line">&#123;</span><br><span class="line">  &quot;doc&quot;: &#123;</span><br><span class="line">    &quot;name&quot;: &quot;item1_updated&quot;,</span><br><span class="line">    &quot;item_id&quot;: &quot;1&quot;,</span><br><span class="line">    &quot;color&quot;: &quot;red&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 方式二</span><br><span class="line">PUT my_index/_doc/1</span><br><span class="line">&#123;</span><br><span class="line">  &quot;item_id&quot;: &quot;1&quot;,</span><br><span class="line">  &quot;name&quot;:&quot;item1_update_by_put&quot;,</span><br><span class="line">  &quot;color&quot;: &quot;red&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-验证完全更新-1"><a href="#6-验证完全更新-1" class="headerlink" title="6. 验证完全更新"></a>6. 验证完全更新</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">GET my_index/_search</span><br><span class="line">// output</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line"> &quot;hits&quot;: [</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;_index&quot;: &quot;my_index&quot;,</span><br><span class="line">        &quot;_id&quot;: &quot;1&quot;,</span><br><span class="line">        &quot;_score&quot;: 1,</span><br><span class="line">        &quot;_source&quot;: &#123;</span><br><span class="line">          &quot;item_id&quot;: &quot;1&quot;,</span><br><span class="line">          &quot;name&quot;: &quot;item1_update_by_put&quot;,</span><br><span class="line">          &quot;color&quot;: &quot;red&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;_index&quot;: &quot;my_index&quot;,</span><br><span class="line">        &quot;_id&quot;: &quot;2&quot;,</span><br><span class="line">        &quot;_score&quot;: 1,</span><br><span class="line">        &quot;_source&quot;: &#123;</span><br><span class="line">          &quot;item_id&quot;: &quot;2&quot;,</span><br><span class="line">          &quot;name&quot;: &quot;item2_updated&quot;,</span><br><span class="line">          &quot;color&quot;: &quot;blue&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-删除文档-1"><a href="#7-删除文档-1" class="headerlink" title="7. 删除文档"></a>7. 删除文档</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DELETE my_index/_doc/1</span><br><span class="line">DELETE my_index/_doc/2</span><br></pre></td></tr></table></figure><h4 id="8-验证删除文档-1"><a href="#8-验证删除文档-1" class="headerlink" title="8. 验证删除文档"></a>8. 验证删除文档</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET my_index/_search</span><br><span class="line"></span><br><span class="line">// output</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">&quot;hits&quot;: []</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="ES如何在Lucene的基础上实现基于主键-id-的删改"><a href="#ES如何在Lucene的基础上实现基于主键-id-的删改" class="headerlink" title="ES如何在Lucene的基础上实现基于主键(_id)的删改"></a>ES如何在Lucene的基础上实现基于主键(_id)的删改</h3><ol><li>ES 使用<code>_id</code>的内部字段作为文档的主键，这个<code>_id</code>可以用户指定，上面的例子中item_id就是对应了<code>_id</code>，Lucene中没有主键的概念，所以需要使用_id 作为一个独特的Term的维持文档的唯一性, 后续的更新, 删除也是和<code>_id</code>对应的Term绑定. Lucene的创建操作不具备幂等性（addDocument）指定了Term之后，这个Term下可以关联N个document，不具备唯一性.</li><li>ES 在部分字段的更新中，自己封装了一层获取原始文档的操作，之后使用update的方式更新Lucene.</li><li>ES 在删除文档操作中，使用<code>_id</code>对应的Term 去调用Lucene的API.</li><li>ES 在创建文档操作中，PUT 相同<code>_id</code>的文档 同样能保持唯一性, 通常情况下ES也是用Lucene update的方式实现创建的请求.</li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li>Lucene整体是一个Append Only的存储引擎，且没有主键的概念.</li><li>ES 本身封装了一系列的操作使得整个CRUD操作更加方便使用，这也不可避免的带了一些额外的开销，通过理解这些操作的底层原理，有助于我们做出一些最佳实践的选择.</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;在ES中我们经常使用的数据格式json，ES也支持常见的CRUD操作，这里我们主要介绍写入相关的操作（创建，更新，删除），ES的底层存储引擎</summary>
      
    
    
    
    
    <category term="ES, Lucene, elasticsearch" scheme="https://skyitachi.github.io/tags/ES-Lucene-elasticsearch/"/>
    
  </entry>
  
  <entry>
    <title>Golang 中[]byte, string和[]rune的相互转化的底层原理和剖析</title>
    <link href="https://skyitachi.github.io/2021/02/21/golang_slice/"/>
    <id>https://skyitachi.github.io/2021/02/21/golang_slice/</id>
    <published>2021-02-21T02:15:38.000Z</published>
    <updated>2021-02-21T02:15:38.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Golang-中-byte-string和-rune的相互转化的底层原理和剖析"><a href="#Golang-中-byte-string和-rune的相互转化的底层原理和剖析" class="headerlink" title="Golang 中[]byte, string和[]rune的相互转化的底层原理和剖析"></a>Golang 中<code>[]byte</code>, <code>string</code>和<code>[]rune</code>的相互转化的底层原理和剖析</h1><p>在golang中有些场景经常会用到[]byte和string的相互转化，尤其是在使用json.Marshal和json.Unmarshal的时候，经常会遇到需要这种转化。</p><p>本文主要说明以下内容：</p><ul><li>几种类型相互转化的方法和性能分析</li><li>这些类型的底层存储</li><li>代码<a href="https://gist.github.com/skyitachi/f8f22a390f547466216b0a4084b98bee">gist</a></li></ul><h2 id="相互转化"><a href="#相互转化" class="headerlink" title="相互转化"></a>相互转化</h2><h3 id="byte和string的相互转化"><a href="#byte和string的相互转化" class="headerlink" title="[]byte和string的相互转化"></a>[]byte和string的相互转化</h3><h4 id="string-byte"><a href="#string-byte" class="headerlink" title="string -&gt; []byte"></a>string -&gt; []byte</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkStringToByteSlice</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">s := genString(<span class="number">10000</span>)</span><br><span class="line">b.ReportAllocs()</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">bs := []<span class="type">byte</span>(s)</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(bs) != <span class="built_in">len</span>(s) &#123;</span><br><span class="line">b.Error(<span class="string">&quot;error&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkStringToByteSliceUnsafe</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">s := genString(<span class="number">10000</span>)</span><br><span class="line">b.ReportAllocs()</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">l := <span class="built_in">len</span>(s)</span><br><span class="line">bs := *(*[]<span class="type">byte</span>)(unsafe.Pointer(&amp;reflect.SliceHeader&#123;</span><br><span class="line">Data: (*(*reflect.StringHeader)(unsafe.Pointer(&amp;s))).Data,</span><br><span class="line">Len:  l,</span><br><span class="line">Cap:  l,</span><br><span class="line">&#125;))</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(bs) != <span class="built_in">len</span>(s) &#123;</span><br><span class="line">b.Error(<span class="string">&quot;error&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一种使用[]byte这种直接转化，也是我们常用的方式，第二种是使用unsafe的方式。这两种区别就在于一个是重新分配了内存，另一个是复用了原来的内存。</p><p>benchmark的结果也验证了这一点</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">go test  -run=BenchmarkStringToByteSlice -bench=StringToByteSlice</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">go-demo.test</span></span><br><span class="line"></span><br><span class="line">goos: darwin</span><br><span class="line">goarch: amd64</span><br><span class="line">pkg: go-demo</span><br><span class="line">BenchmarkStringToByteSlice-12           1164224       964 ns/op   10285 B/op       1 allocs/op</span><br><span class="line">BenchmarkStringToByteSliceUnsafe-12    1000000000         0.380 ns/op       0 B/op       0 allocs/op</span><br><span class="line">PASS</span><br><span class="line">ok  go-demo2.089s</span><br></pre></td></tr></table></figure><h4 id="byte-string"><a href="#byte-string" class="headerlink" title="[]byte -&gt; string"></a>[]byte -&gt; string</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkSliceByteToString</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">bs := genSliceByte(<span class="number">100</span>)</span><br><span class="line">b.ReportAllocs()</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">s := <span class="type">string</span>(bs)</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(s) != <span class="built_in">len</span>(bs) &#123;</span><br><span class="line">b.Error(<span class="string">&quot;error&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkSliceByteToStringUnsafe</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">bs := genSliceByte(<span class="number">100</span>)</span><br><span class="line">b.ReportAllocs()</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">s := *(*<span class="type">string</span>)(unsafe.Pointer(&amp;bs))</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(s) != <span class="built_in">len</span>(bs) &#123;</span><br><span class="line">b.Log(<span class="string">&quot;slice: &quot;</span>, <span class="built_in">len</span>(bs), <span class="string">&quot; string: &quot;</span>, <span class="built_in">len</span>(s))</span><br><span class="line">b.Error(<span class="string">&quot;error: &quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>benchmark 结果</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">go test  -run=BenchmarkSliceByteToString -bench=SliceByteToString</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">go-demo.test</span></span><br><span class="line"></span><br><span class="line">goos: darwin</span><br><span class="line">goarch: amd64</span><br><span class="line">pkg: go-demo</span><br><span class="line">BenchmarkSliceByteToString-12          35913873        32.4 ns/op     112 B/op       1 allocs/op</span><br><span class="line">BenchmarkSliceByteToStringUnsafe-12    1000000000         0.253 ns/op       0 B/op       0 allocs/op</span><br><span class="line">PASS</span><br><span class="line">ok  go-demo3.796s</span><br></pre></td></tr></table></figure><h3 id="string和-rune的相互转化"><a href="#string和-rune的相互转化" class="headerlink" title="string和[]rune的相互转化"></a>string和[]rune的相互转化</h3><p>string和rune的相互转化其实和上面类似，主要是[]rune对应的[]byte数组长度需要计算下，这里就只贴一个[]rune到string的转化了</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkSliceRuneToStringUnsafe</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">bs := genSliceRune(<span class="number">100</span>)</span><br><span class="line">s1 := <span class="type">string</span>(bs)</span><br><span class="line">b.ReportAllocs()</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line"><span class="keyword">var</span> l <span class="type">int</span></span><br><span class="line"><span class="keyword">for</span> _, r := <span class="keyword">range</span> bs &#123;</span><br><span class="line">l += utf8.RuneLen(r)</span><br><span class="line">&#125;</span><br><span class="line">s := *(*<span class="type">string</span>)(unsafe.Pointer(&amp;reflect.StringHeader&#123;</span><br><span class="line">Data: (*(*reflect.SliceHeader)(unsafe.Pointer(&amp;bs))).Data,</span><br><span class="line">Len:  l,</span><br><span class="line">&#125;))</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(s1) != <span class="built_in">len</span>(s) &#123;</span><br><span class="line">b.Error(<span class="string">&quot;error&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="String和Slice的底层存储分析"><a href="#String和Slice的底层存储分析" class="headerlink" title="String和Slice的底层存储分析"></a>String和Slice的底层存储分析</h2><h4 id="reflect-SliceHeader-和reflect-StringHeader"><a href="#reflect-SliceHeader-和reflect-StringHeader" class="headerlink" title="reflect.SliceHeader 和reflect.StringHeader"></a>reflect.SliceHeader 和reflect.StringHeader</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> StringHeader <span class="keyword">struct</span> &#123;</span><br><span class="line">Data <span class="type">uintptr</span></span><br><span class="line">Len  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> SliceHeader <span class="keyword">struct</span> &#123;</span><br><span class="line">Data <span class="type">uintptr</span></span><br><span class="line">Len  <span class="type">int</span></span><br><span class="line">Cap  <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两者类型基本一样，Slice多了一个Cap，其实这也决定了[]byte可以直接使用指针强转成string，但是反过来却不行</p><h4 id="slice的底层存储"><a href="#slice的底层存储" class="headerlink" title="slice的底层存储"></a>slice的底层存储</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> slice <span class="keyword">struct</span> &#123;</span><br><span class="line">array unsafe.Pointer</span><br><span class="line"><span class="built_in">len</span>   <span class="type">int</span></span><br><span class="line"><span class="built_in">cap</span>   <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="以汇编的形式看下slice的底层结构"><a href="#以汇编的形式看下slice的底层结构" class="headerlink" title="以汇编的形式看下slice的底层结构"></a>以汇编的形式看下slice的底层结构</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> pkg</span><br><span class="line"></span><br><span class="line"><span class="comment">// var data = make([]int, 0, 10)</span></span><br><span class="line"><span class="keyword">var</span> data = []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">go tool compile -S pkg.go</span><br><span class="line">go.cuinfo.packagename. SDWARFINFO dupok size=0</span><br><span class="line">0x0000 70 6b 67                                         pkg</span><br><span class="line">&quot;&quot;.data SDATA size=24</span><br><span class="line">0x0000 00 00 00 00 00 00 00 00 02 00 00 00 00 00 00 00  ................</span><br><span class="line">0x0010 02 00 00 00 00 00 00 00                          ........</span><br><span class="line">rel 0+8 t=1 &quot;&quot;..stmp_0+0</span><br><span class="line">&quot;&quot;..stmp_0 SNOPTRDATA size=16</span><br><span class="line">0x0000 01 00 00 00 00 00 00 00 02 00 00 00 00 00 00 00  ................</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>可以看到””.data 对应的是size是24（8byte的指针，len和cap各自8byte），slice里的内容是两个int对应的就是，””.stmp_0 里的内容</p><p>进一步分析data对应的二进制</p><ul><li>data+8是<code>02 00 ...</code> ，对应len</li><li>data+16是<code>02 00</code> 对应cap</li></ul><p>整个slice struct在内存里是紧凑分布的，所以我们可以进行指针类的强制转化，类似于c++中<code>reinterpret_cast</code></p><h5 id="string的底层结构"><a href="#string的底层结构" class="headerlink" title="string的底层结构"></a>string的底层结构</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> pkg</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> testStr = <span class="string">&quot;abc&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">go.cuinfo.packagename. SDWARFINFO dupok size=0</span><br><span class="line">0x0000 70 6b 67                                         pkg</span><br><span class="line">go.string.&quot;abc&quot; SRODATA dupok size=3</span><br><span class="line">0x0000 61 62 63                                         abc</span><br><span class="line">&quot;&quot;.testStr SDATA size=16</span><br><span class="line">0x0000 00 00 00 00 00 00 00 00 03 00 00 00 00 00 00 00  ................</span><br><span class="line">rel 0+8 t=1 go.string.&quot;abc&quot;+0</span><br></pre></td></tr></table></figure><p>和上文的slice很类似，size变成了16而已</p><h4 id="Fat-Pointer"><a href="#Fat-Pointer" class="headerlink" title="Fat Pointer"></a>Fat Pointer</h4><p>像slice这种结构在c中常被称为fatpointer，感兴趣的同学可以参考<a href="https://nullprogram.com/blog/2019/06/30/">Go Slices are Fat Pointers</a></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>介绍了golang中string，[]byte和[]rune的转化及简单的性能分析</li><li>slice在golang中的底层存储</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Golang-中-byte-string和-rune的相互转化的底层原理和剖析&quot;&gt;&lt;a href=&quot;#Golang-中-byte-string和-rune的相互转化的底层原理和剖析&quot; class=&quot;headerlink&quot; title=&quot;Golang 中[]byte</summary>
      
    
    
    
    
    <category term="golang slice" scheme="https://skyitachi.github.io/tags/golang-slice/"/>
    
  </entry>
  
  <entry>
    <title>二分法的两种实现</title>
    <link href="https://skyitachi.github.io/2020/04/14/%E4%BA%8C%E5%88%86%E6%B3%95%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%AE%9E%E7%8E%B0/"/>
    <id>https://skyitachi.github.io/2020/04/14/%E4%BA%8C%E5%88%86%E6%B3%95%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%AE%9E%E7%8E%B0/</id>
    <published>2020-04-14T14:15:38.000Z</published>
    <updated>2020-04-14T14:11:39.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>虽然二分搜索很简单（在无重复的有序数组上）,但是也有很多值得注意的地方，而且有两种完全不同的写法（两种完全不同的功能）</p><h4 id="lower-bound"><a href="#lower-bound" class="headerlink" title="lower bound"></a>lower bound</h4><blockquote><p>找出大于等于target的最小数组下标, 不存在的情况下返回-1</p></blockquote><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lower_bound</span><span class="params">(a []<span class="type">int</span>, target <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">  l := <span class="number">0</span></span><br><span class="line">  h := <span class="built_in">len</span>(a) - <span class="number">1</span></span><br><span class="line">  <span class="keyword">for</span> l &lt; h &#123;</span><br><span class="line">    m := l + (h - l) / <span class="number">2</span></span><br><span class="line">    <span class="keyword">if</span> a[m] &gt;= target &#123;</span><br><span class="line">      h = m</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// l肯定可以取到h值，所以不需要使用向上取整计算m值</span></span><br><span class="line">      l += <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> a[l] &gt;= target &#123;</span><br><span class="line">    <span class="keyword">return</span> l</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="upper-bound"><a href="#upper-bound" class="headerlink" title="upper bound"></a>upper bound</h4><blockquote><p>找出小于等于target的最大数组下标</p></blockquote><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">upper_bound</span><span class="params">(a []<span class="type">int</span>, target <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">  l := <span class="number">0</span></span><br><span class="line">h := <span class="built_in">len</span>(a) - <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> l &lt; h &#123;</span><br><span class="line">m := l + (h - l + <span class="number">1</span>) / <span class="number">2</span></span><br><span class="line"><span class="keyword">if</span> a[m] &lt;= target &#123;</span><br><span class="line">      <span class="comment">// l 要能够取到h值，就必须保证m使用向上取整计算, (h - l + 1) / 2 就是这么来的</span></span><br><span class="line">l = m</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">h = m - <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> a[l] &lt;= target &#123;</span><br><span class="line"><span class="keyword">return</span> l</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h4><ul><li>计算mid的时候不能发生溢出</li><li>数组下标不能越界</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;虽然二分搜索很简单（在无重复的有序数组上）,但是也有很多值得注意的地方，而且有两种完全不同的写法（两种完全不同的功能）&lt;/p&gt;
&lt;h4 id</summary>
      
    
    
    
    
    <category term="algorithm" scheme="https://skyitachi.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>dubbo-go support protobuf</title>
    <link href="https://skyitachi.github.io/2019/12/30/dubbo-go-protobuf-support/"/>
    <id>https://skyitachi.github.io/2019/12/30/dubbo-go-protobuf-support/</id>
    <published>2019-12-29T16:00:00.000Z</published>
    <updated>2019-12-29T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="主要用法"><a href="#主要用法" class="headerlink" title="主要用法"></a>主要用法</h4><ul><li>和grpc中使用protobuf生成代码基本一致（至少在形式上）,直接看例子吧</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">├── go-client</span><br><span class="line">│   ├── client.go</span><br><span class="line">│   ├── client.yml</span><br><span class="line">├── go-server</span><br><span class="line">│   ├── main.go</span><br><span class="line">│   └── server.yml</span><br><span class="line">└── user</span><br><span class="line">    ├── user.pb.go</span><br><span class="line">    └── user.proto</span><br></pre></td></tr></table></figure><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> user;</span><br><span class="line"></span><br><span class="line"><span class="keyword">service </span><span class="title class_">UserProvider</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">rpc</span> GetUser (UserRequest) <span class="keyword">returns</span> (UserReply) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">UserRequest</span> &#123;</span><br><span class="line">  <span class="type">string</span> id = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">UserReply</span> &#123;</span><br><span class="line">  <span class="type">string</span> id = <span class="number">1</span>;</span><br><span class="line">  <span class="type">string</span> name = <span class="number">2</span>;</span><br><span class="line">  <span class="type">int32</span> age = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用protoc-gen-dubbogo插件生成dubbogo的代理</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protoc --plugin=&#123;plugin_path&#125; --dubbogo_out=plugins=dubbogo:. user/user.proto</span><br></pre></td></tr></table></figure><ul><li>client关键代码</li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">user := user.NewUserProvider()</span><br><span class="line">reply := user.UserReply&#123;&#125;</span><br><span class="line">err := userProvider.GetUser(context.TODO(), &amp;user.UserRequest&#123;Id: <span class="string">&quot;A001&quot;</span>&#125;, &amp;reply)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">  log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;response result: %+v&quot;</span>, reply)</span><br></pre></td></tr></table></figure><p>ps: 一切都是熟悉的味道<br>ps: 生成代理的名称需要和reference里配置的一样</p><ul><li>server关键代码</li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> UserProvider <span class="keyword">struct</span> &#123;</span><br><span class="line">pb.UnimplementedUserProviderServer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*UserProvider)</span></span> GetUser(ctx context.Context, user *pb.UserRequest) (*pb.UserReply, <span class="type">error</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> &amp;pb.UserReply&#123;Id: <span class="string">&quot;001&quot;</span>, Name: <span class="string">&quot;alice&quot;</span>, Age: <span class="number">18</span>&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册</span></span><br><span class="line">pb.RegisterProvider(<span class="built_in">new</span>(UserProvider))</span><br></pre></td></tr></table></figure><h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><ul><li>在dubbogo抽出一层serialization，任何和serialization相关的之后只要实现Serialize接口就行了，这样是为了更好的实现更多序列化的支持，逻辑上会更合理一些，原有的go hessian2中做了一部分dubbo相关的codec工作，这里我也把它抽到dubbogo中了， 当然hessian2的序列化仍然保留了，这次实现是兼容老版本的。</li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Serializer <span class="keyword">interface</span> &#123;</span><br><span class="line">Marshal(p DubboPackage) ([]<span class="type">byte</span>, <span class="type">error</span>)</span><br><span class="line">Unmarshal([]<span class="type">byte</span>, *DubboPackage) <span class="type">error</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>参考了dubbo的protobuf实现，实现了在protobuf层面和java互通（不一定是好事:(）</li><li>其他的就是细节了</li></ul><h4 id="一些注意点"><a href="#一些注意点" class="headerlink" title="一些注意点"></a>一些注意点</h4><ul><li><code>error</code>的处理和java不太一样，java会把详细的java error stack都返回给客户端，go只会把message传过来，生成一个error</li><li>由于java protobuf生成的代理方法名是小写开头(完全搞不明白是为什么)，这在golang中表示私有方法，个人已经提了<a href="https://github.com/apache/dubbo/issues/5536">issue</a>, 所以直接用java的例子是不行的</li><li>java protobuf的代理生成的是内部接口，比如xxx$IDemoService, <code>$</code>是url中的一个特殊字符，正好发现了dubbogo的一个注册url的bug</li></ul><h4 id="我为什么要支持protobuf"><a href="#我为什么要支持protobuf" class="headerlink" title="我为什么要支持protobuf"></a>我为什么要支持protobuf</h4><ul><li>protobuf的语言中立性更好，序列化性能也更好</li><li>更加符合golang的生态</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;主要用法&quot;&gt;&lt;a href=&quot;#主要用法&quot; class=&quot;headerlink&quot; title=&quot;主要用法&quot;&gt;&lt;/a&gt;主要用法&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;和grpc中使用protobuf生成代码基本一致（至少在形式上）,直接看例子吧&lt;/li&gt;
&lt;/ul&gt;
&lt;figu</summary>
      
    
    
    
    
    <category term="dubbo, go, protobuf" scheme="https://skyitachi.github.io/tags/dubbo-go-protobuf/"/>
    
  </entry>
  
  <entry>
    <title>c++中的传参</title>
    <link href="https://skyitachi.github.io/2019/08/21/passing-value-in-cpp/"/>
    <id>https://skyitachi.github.io/2019/08/21/passing-value-in-cpp/</id>
    <published>2019-08-21T02:30:36.000Z</published>
    <updated>2019-08-21T02:30:36.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>最近在用c++写基于libuv的websocket engine的时候发现, 设置callback的参数是一个很有挑战性的工作, 原来觉得c++的复杂在于其模板，oo范式概念的复杂, 现在发现c++的每个方面都很复杂，因为有太多可以通过编译的方式了，我想从传参这个方面切入，让大家了解下c++的复杂（强大）。</p><p>ps：本文的传参使基于涉及到动态内存分配对象的传参，一般普通对象的传参基本是不需要考虑这么复杂的(至少我目前这么认为)。</p><p>以下是本文中需要传递的参数，一个简单的String, 只保留会讲到的构造函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">String</span>: &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">String</span>(<span class="type">const</span> <span class="type">char</span>* src): <span class="built_in">data_</span>(<span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(src) + <span class="number">1</span>]), <span class="built_in">size_</span>(<span class="built_in">strlen</span>(src)) &#123;</span><br><span class="line">      ::<span class="built_in">strcpy</span>(data_, src);</span><br><span class="line">      data_[size_] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">String</span>(<span class="type">const</span> String&amp; lhs): <span class="built_in">data_</span>(<span class="keyword">new</span> <span class="type">char</span>[lhs.<span class="built_in">size</span>() + <span class="number">1</span>]), <span class="built_in">size_</span>(lhs.<span class="built_in">size</span>()) &#123;</span><br><span class="line">      ::<span class="built_in">strcpy</span>(data_, lhs.<span class="built_in">data</span>());</span><br><span class="line">      data_[size_] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// move</span></span><br><span class="line">    <span class="built_in">String</span>(String &amp;&amp;rhs) <span class="keyword">noexcept</span>: <span class="built_in">data_</span>(rhs.data_), <span class="built_in">size_</span>(rhs.size_) &#123;</span><br><span class="line">      rhs.data_ = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我遇到的一个问题是在MessageCallback中，应该使用<code>const String&amp; message</code>还是<code>String&amp;&amp; message</code>, 这两种形参的区别是什么</p><h5 id="理解std-move-和右值引用"><a href="#理解std-move-和右值引用" class="headerlink" title="理解std::move 和右值引用"></a>理解<code>std::move</code> 和<code>右值引用</code></h5><p>在弄清上述问题之前，还是要从根本上着手，弄清<code>std::move</code>和右值引用。<br>右值引用是c++11中引入的一种新的引用类型，必须要绑定到右值的引用。<br>而std::move的作用是可以把几乎任意值转化成一个右值引用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_passing_value</span><span class="params">(std::string&amp; s1)</span> </span>&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;in the left reference&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_passing_value</span><span class="params">(std::string&amp;&amp; s1)</span> </span>&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;in the right reference&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::string s1 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">std::string &amp;sr = s1;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test_passing_value</span>(s1); <span class="comment">// in the left</span></span><br><span class="line"><span class="built_in">test_passing_value</span>(std::<span class="built_in">move</span>(s1)); <span class="comment">// in the right</span></span><br><span class="line"><span class="built_in">test_passing_value</span>(sr); <span class="comment">// in the left</span></span><br><span class="line"><span class="built_in">test_passing_value</span>(std::<span class="built_in">move</span>(sr)); <span class="comment">// in the right</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以看到无论是左值，还是左值引用，使用std::move之后都可以变成右值引用</span></span><br><span class="line"><span class="comment">// 意外的情况就是const T&amp; 在使用std::move转化时的特殊情况</span></span><br></pre></td></tr></table></figure><h5 id="const-T-vs-T"><a href="#const-T-vs-T" class="headerlink" title="const T&amp; vs T&amp;&amp;"></a><code>const T&amp;</code> vs <code>T&amp;&amp;</code></h5><p>c++11中引入了右值引用和move语义，初学者（比如我）很容易被这种特性吸引（move比copy快）, 两者其实是解决不同场景下的问题，T&amp;&amp; 的确提供了一种更为高效的传参方式, 让我们看下两者的细节和使用场景吧。</p><ul><li><p>仅仅使用<code>const T&amp;</code>并不会发生copy</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">const</span> String&amp; s)</span> </span>&#123;</span><br><span class="line">  std::cout &lt;&lt; s &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">String <span class="title">s0</span><span class="params">(<span class="string">&quot;hello&quot;</span>)</span></span>;</span><br><span class="line">  <span class="built_in">foo</span>(s0); <span class="comment">// 不会发生复制</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>const T&amp;</code> 发生复制的情况是在函数体内用到T的local variable， 比如<code>T local = t</code>, 这时候会发生拷贝控制</p></li><li><p>仅仅使用<code>T&amp;&amp;</code>不会发生move</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f2</span><span class="params">(String &amp;&amp;s2)</span> </span>&#123;</span><br><span class="line">  std::cout &lt;&lt; s2 &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">f2</span>(<span class="built_in">String</span>(<span class="string">&quot;hello&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从以上两种情况来看似乎传参的代价都很低，那么应该如何选择呢，主要还是根据语义来做选择，如果你的实参是个左值自然选择第一种，如果是右值那自然是后者，如果你确定需要第二种那么使用<code>std::move</code>也是可以的</p></li></ul><h5 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h5><ul><li>由于我在传给callback的string是从buffer中复制构造来的，而不是仅仅像stringpiece那样使用，所以使用右值引用更合适，使用者会放心大胆的使用这个string，move之类的更不在话下了</li></ul><h5 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h5><ul><li>可以考虑使用StringPiece类似的技术，不过我感觉StringPiece在这个场景下并不好</li><li>关于std::move的原理其中涉及到了引用折叠这些比较复杂的概念，所以没有深入介绍</li><li>在模板中使用T&amp;&amp; 和实参中的&amp;&amp;还是不一样的，模板中的T&amp;&amp; 在转发参数时要保证不丢失T的信息(T可能是引用) 所以有涉及到了完美转发的概念，std::forward可以解决这个问题</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;最近在用c++写基于libuv的websocket engine的时候发现, 设置callback的参数是一个很有挑战性的工作, 原来觉得c</summary>
      
    
    
    
    
    <category term="cpp" scheme="https://skyitachi.github.io/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>浅谈 javascript 作用域</title>
    <link href="https://skyitachi.github.io/2017/04/24/scope/"/>
    <id>https://skyitachi.github.io/2017/04/24/scope/</id>
    <published>2017-04-23T16:00:00.000Z</published>
    <updated>2017-04-23T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><ul><li>本文将主要介绍javascript中作用域相关的问题，尽可能多的使用代码举例说明，尽量少涉及动态作用域相关</li></ul><h4 id="词法作用域-核心"><a href="#词法作用域-核心" class="headerlink" title="词法作用域(核心)"></a>词法作用域(核心)</h4><blockquote><p>javascript的作用域是词法作用域（静态作用域）, 不过像<code>eval</code>，<code>with</code>这些具有动态改变作用域的能力, 本文重点在于词法作用域</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">testLexicalScope</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// 由于当前scope中a是由最外层定义的，所以此处的a只能访问到最外层的a</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">b</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">2</span>;</span><br><span class="line">  <span class="title function_">testLexicalScope</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">b</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 另一个例子</span></span><br><span class="line"><span class="keyword">let</span> sameVar1 = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> sameVar2 = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">outerScope</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> sameVar1 = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">innerScope</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;current scope: sameVar1 is &quot;</span>, sameVar1); <span class="comment">// 当前的scope中最近的sameVar1值是2</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;current scope: sameVar2 is &quot;</span>, sameVar2);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">innerScope</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">outerScope</span>();</span><br><span class="line"><span class="comment">// current scope: sameVar1 is  2</span></span><br><span class="line"><span class="comment">// current scope: sameVar2 is  1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//另一个例子</span></span><br><span class="line"><span class="keyword">const</span> f1 = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(outVar);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> outVar = <span class="number">1</span>;</span><br><span class="line"><span class="title function_">f1</span>(); <span class="comment">// 1 why</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>只有在函数声明的时候才会遵循lexical scope的规则, 如果是函数表达式则取决于调用的时机</p></blockquote><h4 id="不同类型的作用域-如何创建scope"><a href="#不同类型的作用域-如何创建scope" class="headerlink" title="不同类型的作用域(如何创建scope)"></a>不同类型的作用域(如何创建scope)</h4><ul><li>函数作用域</li></ul><blockquote><p>属于这个函数的全部变量都可以在整个函数的范围内使用及复用<br>javascript 每个函数都会创建一个scope</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fScope</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> aStr = <span class="string">&quot;function&quot;</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(aStr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">fScope</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(aStr); <span class="comment">// ReferenceError: aStr is not defined</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>块级作用域({…})</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="literal">true</span>;</span><br><span class="line">&#123; <span class="comment">// 这里是使用let，将foo绑定到了&#123;&#125;这个块作用域中</span></span><br><span class="line">  <span class="keyword">let</span> foo = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">let</span> bar = <span class="string">&quot;cannot seen&quot;</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(foo); <span class="comment">// false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(bar); <span class="comment">// ReferenceError</span></span><br></pre></td></tr></table></figure><h4 id="var"><a href="#var" class="headerlink" title="var"></a><code>var</code></h4><ul><li>函数作用域中的<code>var</code>仍然遵循函数作用域相关的</li><li><code>var</code>中没有块级作用域</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="literal">true</span>;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">var</span> foo = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">var</span> bar = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo); <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(bar); <span class="comment">// bar</span></span><br></pre></td></tr></table></figure><h4 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h4><blockquote><p>变量和函数的所有声明多会在任何代码被执行前首先被处理（编译器找到这些变量与合适的作用域关联）</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">hoisting</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">hoisting</span>();</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>又是let</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">hoisting</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// 第一个let之上的区域叫做`temporal dead zone`</span></span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">hoisting</span>(); <span class="comment">// ReferenceError</span></span><br></pre></td></tr></table></figure><p><strong>函数声明的优先级会高于变量声明</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">foo</span>(); <span class="comment">// in the function</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;in the function&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li>关于块级作用域, 可用try{} catch(err) {&#x2F;<em>这里是块级作用域</em>&#x2F;}模拟，更多参考:《你不知道的javascript》上卷中3.4.2节</li><li>使用<code>let</code>，<code>const</code>是最佳实践</li><li>需要区分函数声明和函数表达式</li><li>尽量不要写有提升的代码（声明尽量提前）</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;本文将主要介绍javascript中作用域相关的问题，尽可能多的使用代码举例说明，尽量少涉及动态作用域相关&lt;/li&gt;
&lt;/ul&gt;</summary>
      
    
    
    
    
    <category term="javascript" scheme="https://skyitachi.github.io/tags/javascript/"/>
    
  </entry>
  
</feed>
