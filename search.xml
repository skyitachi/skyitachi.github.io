<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Java ByteBuffer实践</title>
      <link href="/2021/08/14/bytebuffer%E5%AE%9E%E8%B7%B5/"/>
      <url>/2021/08/14/bytebuffer%E5%AE%9E%E8%B7%B5/</url>
      
        <content type="html"><![CDATA[<h1 id="Java-bytebuffer实践"><a href="#Java-bytebuffer实践" class="headerlink" title="Java bytebuffer实践"></a>Java bytebuffer实践</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近在使用java做文件io相关的代码时，不可避免的使用的filechannel和bytebuffer，其中bytebuffer有些地方容易让初学者产生困扰，这里记录一下我的一些实践</p><h2 id="类结构"><a href="#类结构" class="headerlink" title="类结构"></a>类结构</h2><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/64970207be0849109cffe25ec6028838~tplv-k3u1fbpfcp-zoom-1.image"></p><h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p>我们解释下Buffer类和ByteBuffer中的字段</p><ul><li>hb：这个就是实际的byte数组</li><li>capacity：就是这个hb实际容量，绝大部分场景下都不可改变，无法增大</li><li>offset：内置的偏移量，每次读写buffer都必须加上offset，默认ByteBuffer.allocate的偏移量是0</li><li>position: 当前buffer 读写的位置，类似于cursor的概念，默认是0</li><li>limit: 当前buffer读写位置的上限，默认是capacity</li><li>mark：用来记录某个时刻position的位置，默认值是-1</li></ul><blockquote><p><em>&#x2F;&#x2F; Invariants: mark &lt;&#x3D; position &lt;&#x3D; limit &lt;&#x3D; capacity</em></p></blockquote><ol><li>向buffer中写入内容: position变大</li><li>读取buffer中的内容：当写入完成时此时相当于0到position之间的内容都是刚刚写入的，那应该如何读取呢, 因为读写都是根据position来的，此时需要做一次flip操作，position需要被清零，limit换成之前的position</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public final Buffer flip() &#123;</span><br><span class="line"></span><br><span class="line">    limit = position;</span><br><span class="line"></span><br><span class="line">    position = 0;</span><br><span class="line"></span><br><span class="line">    mark = -1;</span><br><span class="line"></span><br><span class="line">    return this;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>flip操作完之后会发现，limit和capacity之前有可能不一样了，下次在写入buffer的时候能写入的数据变小了</p><h3 id="为什么要在写buffer完之后使用flip呢"><a href="#为什么要在写buffer完之后使用flip呢" class="headerlink" title="为什么要在写buffer完之后使用flip呢"></a>为什么要在写buffer完之后使用flip呢</h3><p>因为写入到buffer中的只有0到position之间的数据，而position和就limit之间的数据是未定义的，不应该被应用程序读到，所以需要将最新的写入position设置为新的limit，这样应用程序读到limit就不读取数据了。</p><h3 id="读完之后再写应该怎么处理"><a href="#读完之后再写应该怎么处理" class="headerlink" title="读完之后再写应该怎么处理"></a>读完之后再写应该怎么处理</h3><ul><li>假设完全读完了buffer，此时position和limit相等，对于这个buffer来说它的remaining是0了，不存在可写入的空间了，此时可以继续使用flip，当然更好的处理是使用rewind</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public final Buffer rewind() &#123;</span><br><span class="line"></span><br><span class="line">    position = 0;</span><br><span class="line"></span><br><span class="line">    mark = -1;</span><br><span class="line"></span><br><span class="line">    return this;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="具体的使用场景"><a href="#具体的使用场景" class="headerlink" title="具体的使用场景"></a>具体的使用场景</h2><ol><li><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 初始化</span><br><span class="line"></span><br><span class="line">ByteBuffer buf = ByteBuffer.allocate(4096);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public static ByteBuffer allocate(int capacity) &#123;</span><br><span class="line"></span><br><span class="line">    if (capacity &lt; 0)</span><br><span class="line"></span><br><span class="line">        throw new IllegalArgumentException();</span><br><span class="line"></span><br><span class="line">    return new HeapByteBuffer(capacity, capacity);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到实际初始化的是HeapByteBuffer实例，因为还有DirectBuffer，不过本文不会涉及</p><ol start="2"><li><h3 id="读写buffer"><a href="#读写buffer" class="headerlink" title="读写buffer"></a>读写buffer</h3></li></ol><p>因为Filechannel配合在一起使用，而且经常和文件系统的读写在一个语境中使用，不免有些容易混淆的地方。</p><ul><li>从文件系统读取数据到buffer中，即使用<code>fileChannel.read(buf)</code>这个对于buffer来说其实是写入，<strong>当然该read会尽可能读满buffer</strong></li><li>通过filechannel和bytebuffer读取文件中第一个long number</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fileChannel.read(buf);   // buf会被读满，即position==limit</span><br><span class="line"></span><br><span class="line">buf.flip();              // position = 0; limit = old position</span><br><span class="line"></span><br><span class="line">buf.getLong();           // position += 8;</span><br></pre></td></tr></table></figure><p>所以我们看到从文件系统中读完之后要flip一下，在使用buf读写的时候要注意尽量读满再使用flip，否则应该使用rewind</p><ul><li>通过bytebuffer和filechannel写入一个long number到文件系统中</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">buf.putLong(1L);</span><br><span class="line"></span><br><span class="line">buf.flip(); // 未写满的情况下，必须使用flip，写满的情况下flip和rewind是等价的</span><br><span class="line"></span><br><span class="line">fileChannel.write(buf);</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>容易让人混淆的就是flip使用的时机，理解position和limit的关系之后就会简单不少</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 实践 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang 中[]byte, string和[]rune的相互转化的底层原理和剖析</title>
      <link href="/2021/02/21/golang_slice/"/>
      <url>/2021/02/21/golang_slice/</url>
      
        <content type="html"><![CDATA[<h1 id="Golang-中-byte-string和-rune的相互转化的底层原理和剖析"><a href="#Golang-中-byte-string和-rune的相互转化的底层原理和剖析" class="headerlink" title="Golang 中[]byte, string和[]rune的相互转化的底层原理和剖析"></a>Golang 中<code>[]byte</code>, <code>string</code>和<code>[]rune</code>的相互转化的底层原理和剖析</h1><p>在golang中有些场景经常会用到[]byte和string的相互转化，尤其是在使用json.Marshal和json.Unmarshal的时候，经常会遇到需要这种转化。</p><p>本文主要说明以下内容：</p><ul><li>几种类型相互转化的方法和性能分析</li><li>这些类型的底层存储</li><li>代码<a href="https://gist.github.com/skyitachi/f8f22a390f547466216b0a4084b98bee">gist</a></li></ul><h2 id="相互转化"><a href="#相互转化" class="headerlink" title="相互转化"></a>相互转化</h2><h3 id="byte和string的相互转化"><a href="#byte和string的相互转化" class="headerlink" title="[]byte和string的相互转化"></a>[]byte和string的相互转化</h3><h4 id="string-byte"><a href="#string-byte" class="headerlink" title="string -&gt; []byte"></a>string -&gt; []byte</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkStringToByteSlice</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">s := genString(<span class="number">10000</span>)</span><br><span class="line">b.ReportAllocs()</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">bs := []<span class="type">byte</span>(s)</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(bs) != <span class="built_in">len</span>(s) &#123;</span><br><span class="line">b.Error(<span class="string">&quot;error&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkStringToByteSliceUnsafe</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">s := genString(<span class="number">10000</span>)</span><br><span class="line">b.ReportAllocs()</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">l := <span class="built_in">len</span>(s)</span><br><span class="line">bs := *(*[]<span class="type">byte</span>)(unsafe.Pointer(&amp;reflect.SliceHeader&#123;</span><br><span class="line">Data: (*(*reflect.StringHeader)(unsafe.Pointer(&amp;s))).Data,</span><br><span class="line">Len:  l,</span><br><span class="line">Cap:  l,</span><br><span class="line">&#125;))</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(bs) != <span class="built_in">len</span>(s) &#123;</span><br><span class="line">b.Error(<span class="string">&quot;error&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一种使用[]byte这种直接转化，也是我们常用的方式，第二种是使用unsafe的方式。这两种区别就在于一个是重新分配了内存，另一个是复用了原来的内存。</p><p>benchmark的结果也验证了这一点</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">go test  -run=BenchmarkStringToByteSlice -bench=StringToByteSlice</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">go-demo.test</span></span><br><span class="line"></span><br><span class="line">goos: darwin</span><br><span class="line">goarch: amd64</span><br><span class="line">pkg: go-demo</span><br><span class="line">BenchmarkStringToByteSlice-12           1164224       964 ns/op   10285 B/op       1 allocs/op</span><br><span class="line">BenchmarkStringToByteSliceUnsafe-12    1000000000         0.380 ns/op       0 B/op       0 allocs/op</span><br><span class="line">PASS</span><br><span class="line">ok  go-demo2.089s</span><br></pre></td></tr></table></figure><h4 id="byte-string"><a href="#byte-string" class="headerlink" title="[]byte -&gt; string"></a>[]byte -&gt; string</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkSliceByteToString</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">bs := genSliceByte(<span class="number">100</span>)</span><br><span class="line">b.ReportAllocs()</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">s := <span class="type">string</span>(bs)</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(s) != <span class="built_in">len</span>(bs) &#123;</span><br><span class="line">b.Error(<span class="string">&quot;error&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkSliceByteToStringUnsafe</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">bs := genSliceByte(<span class="number">100</span>)</span><br><span class="line">b.ReportAllocs()</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">s := *(*<span class="type">string</span>)(unsafe.Pointer(&amp;bs))</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(s) != <span class="built_in">len</span>(bs) &#123;</span><br><span class="line">b.Log(<span class="string">&quot;slice: &quot;</span>, <span class="built_in">len</span>(bs), <span class="string">&quot; string: &quot;</span>, <span class="built_in">len</span>(s))</span><br><span class="line">b.Error(<span class="string">&quot;error: &quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>benchmark 结果</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">go test  -run=BenchmarkSliceByteToString -bench=SliceByteToString</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">go-demo.test</span></span><br><span class="line"></span><br><span class="line">goos: darwin</span><br><span class="line">goarch: amd64</span><br><span class="line">pkg: go-demo</span><br><span class="line">BenchmarkSliceByteToString-12          35913873        32.4 ns/op     112 B/op       1 allocs/op</span><br><span class="line">BenchmarkSliceByteToStringUnsafe-12    1000000000         0.253 ns/op       0 B/op       0 allocs/op</span><br><span class="line">PASS</span><br><span class="line">ok  go-demo3.796s</span><br></pre></td></tr></table></figure><h3 id="string和-rune的相互转化"><a href="#string和-rune的相互转化" class="headerlink" title="string和[]rune的相互转化"></a>string和[]rune的相互转化</h3><p>string和rune的相互转化其实和上面类似，主要是[]rune对应的[]byte数组长度需要计算下，这里就只贴一个[]rune到string的转化了</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkSliceRuneToStringUnsafe</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">bs := genSliceRune(<span class="number">100</span>)</span><br><span class="line">s1 := <span class="type">string</span>(bs)</span><br><span class="line">b.ReportAllocs()</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line"><span class="keyword">var</span> l <span class="type">int</span></span><br><span class="line"><span class="keyword">for</span> _, r := <span class="keyword">range</span> bs &#123;</span><br><span class="line">l += utf8.RuneLen(r)</span><br><span class="line">&#125;</span><br><span class="line">s := *(*<span class="type">string</span>)(unsafe.Pointer(&amp;reflect.StringHeader&#123;</span><br><span class="line">Data: (*(*reflect.SliceHeader)(unsafe.Pointer(&amp;bs))).Data,</span><br><span class="line">Len:  l,</span><br><span class="line">&#125;))</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(s1) != <span class="built_in">len</span>(s) &#123;</span><br><span class="line">b.Error(<span class="string">&quot;error&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="String和Slice的底层存储分析"><a href="#String和Slice的底层存储分析" class="headerlink" title="String和Slice的底层存储分析"></a>String和Slice的底层存储分析</h2><h4 id="reflect-SliceHeader-和reflect-StringHeader"><a href="#reflect-SliceHeader-和reflect-StringHeader" class="headerlink" title="reflect.SliceHeader 和reflect.StringHeader"></a>reflect.SliceHeader 和reflect.StringHeader</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> StringHeader <span class="keyword">struct</span> &#123;</span><br><span class="line">Data <span class="type">uintptr</span></span><br><span class="line">Len  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> SliceHeader <span class="keyword">struct</span> &#123;</span><br><span class="line">Data <span class="type">uintptr</span></span><br><span class="line">Len  <span class="type">int</span></span><br><span class="line">Cap  <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两者类型基本一样，Slice多了一个Cap，其实这也决定了[]byte可以直接使用指针强转成string，但是反过来却不行</p><h4 id="slice的底层存储"><a href="#slice的底层存储" class="headerlink" title="slice的底层存储"></a>slice的底层存储</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> slice <span class="keyword">struct</span> &#123;</span><br><span class="line">array unsafe.Pointer</span><br><span class="line"><span class="built_in">len</span>   <span class="type">int</span></span><br><span class="line"><span class="built_in">cap</span>   <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="以汇编的形式看下slice的底层结构"><a href="#以汇编的形式看下slice的底层结构" class="headerlink" title="以汇编的形式看下slice的底层结构"></a>以汇编的形式看下slice的底层结构</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> pkg</span><br><span class="line"></span><br><span class="line"><span class="comment">// var data = make([]int, 0, 10)</span></span><br><span class="line"><span class="keyword">var</span> data = []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">go tool compile -S pkg.go</span><br><span class="line">go.cuinfo.packagename. SDWARFINFO dupok size=0</span><br><span class="line">0x0000 70 6b 67                                         pkg</span><br><span class="line">&quot;&quot;.data SDATA size=24</span><br><span class="line">0x0000 00 00 00 00 00 00 00 00 02 00 00 00 00 00 00 00  ................</span><br><span class="line">0x0010 02 00 00 00 00 00 00 00                          ........</span><br><span class="line">rel 0+8 t=1 &quot;&quot;..stmp_0+0</span><br><span class="line">&quot;&quot;..stmp_0 SNOPTRDATA size=16</span><br><span class="line">0x0000 01 00 00 00 00 00 00 00 02 00 00 00 00 00 00 00  ................</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>可以看到””.data 对应的是size是24（8byte的指针，len和cap各自8byte），slice里的内容是两个int对应的就是，””.stmp_0 里的内容</p><p>进一步分析data对应的二进制</p><ul><li>data+8是<code>02 00 ...</code> ，对应len</li><li>data+16是<code>02 00</code> 对应cap</li></ul><p>整个slice struct在内存里是紧凑分布的，所以我们可以进行指针类的强制转化，类似于c++中<code>reinterpret_cast</code></p><h5 id="string的底层结构"><a href="#string的底层结构" class="headerlink" title="string的底层结构"></a>string的底层结构</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> pkg</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> testStr = <span class="string">&quot;abc&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">go.cuinfo.packagename. SDWARFINFO dupok size=0</span><br><span class="line">0x0000 70 6b 67                                         pkg</span><br><span class="line">go.string.&quot;abc&quot; SRODATA dupok size=3</span><br><span class="line">0x0000 61 62 63                                         abc</span><br><span class="line">&quot;&quot;.testStr SDATA size=16</span><br><span class="line">0x0000 00 00 00 00 00 00 00 00 03 00 00 00 00 00 00 00  ................</span><br><span class="line">rel 0+8 t=1 go.string.&quot;abc&quot;+0</span><br></pre></td></tr></table></figure><p>和上文的slice很类似，size变成了16而已</p><h4 id="Fat-Pointer"><a href="#Fat-Pointer" class="headerlink" title="Fat Pointer"></a>Fat Pointer</h4><p>像slice这种结构在c中常被称为fatpointer，感兴趣的同学可以参考<a href="https://nullprogram.com/blog/2019/06/30/">Go Slices are Fat Pointers</a></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>介绍了golang中string，[]byte和[]rune的转化及简单的性能分析</li><li>slice在golang中的底层存储</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> golang slice </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020年度总结</title>
      <link href="/2021/01/10/2020%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"/>
      <url>/2021/01/10/2020%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="2020年终总结"><a href="#2020年终总结" class="headerlink" title="2020年终总结"></a>2020年终总结</h1><p>整体而言2020对我来讲是一个比较跌宕起伏的一年，带给我的影响大到我这种从来不写总结的人也想写一写这一年来的变化。</p><h2 id="整体变化"><a href="#整体变化" class="headerlink" title="整体变化"></a>整体变化</h2><ol><li>老东家解体，工作从杭州来到了上海</li><li>工作的title从前端技术专家变成了普通golang后端开发，但是整体工作内容上感觉没有差多少</li><li>选择了教育行业</li></ol><p>这些变化有些是主动的，有些是被动的，大部分是被动的，就像我一直以来的那样，不是很主动，总认为事情得百分百准备好才能开始，事实上根本就没有这样的情况出现过。</p><p>先说下时间线总结吧，平常会有写日记的习惯，所以整理起来也不是很困难，整理完了明显发现很乱，不够聚焦。</p><h2 id="时间线总结"><a href="#时间线总结" class="headerlink" title="时间线总结"></a>时间线总结</h2><ul><li>1月：rocksdb和level的源码阅读；dynamodb，wisckeydb，hashkv，bigtable论文阅读</li><li>2月：wiskeydb的实现；badger源码学习，titandb的源码阅读，面试的整理；cmu15-445部分学习</li><li>3月：cmu15-445的 concurrency control学习；percolater，tikv，etcd，phxpaxos学习；分布式系统的面试准备</li><li>4月：面试和面试准备，包括rocketmq，redis，libuv，reactor，golang调度模型，websocket server的学习，以及第一次面试的惨败和滴滴kv组面试让我看到了自己欠缺的东西，及时调整了方向为后端开发</li><li>5月：mysql，blackwidow，redis，codis的学习，面试了一家北京的创业公司，和创始人谈的还是比较不错的，准备入职。。。</li><li>6月：通过了另一个部门的面试，加入新公司，开启正式的后端开发生涯</li><li>7月：上线自己的第一个系统</li><li>8月：mysql源码阅读尝试（尝试未果），blackwidow学习，开始yedis zset btree index的实践</li><li>9月：btree index的实践，分裂算法的学习</li><li>10月：btree index的实践</li><li>11月：btree index的并发控制不知道如何解决，选择了cmu15445的课程实践</li><li>12月：bustub实践：完成project0，project1，project2#checkpoint1的测试</li></ul><p>当我整理完时间线后，感觉就是一个字”杂“，年初不停的看论文，但是效果很不好，没有带场景的去看，看bigtable的时候甚至不知道hbase就是bigtable的开源实现。</p><p>理解比较深的就是wisckeydb，leveldb和rocksdb相关源码，但是也没有到达那种高屋建瓴的地步，主要原因就是没有相关的实践，c++的功底太弱（直接导致滴滴kv组的三面被拒）。</p><p>最终在4月份的时候由于感觉在分布式系统，存储引擎方向的积累还不够，就选择了准备后端开发，整体上手还是比较快的，但是感觉经验不够，不像在nodejs方向上游刃有余。</p><p>话说回来为什么要在工作6年后选择换方向，其实主要是感觉nodejs方向上可做的东西比较少，在整个业务上也不是核心的地位，nodejs虽然能做微服务，但是java才是主流。优先选的是分布式系统方向，但是发现积累不够，很多东西学的不够扎实，虽然阿里中间件比赛上能够有所收获，但是在整体上开始差很多，不过总算是入门了吧。</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ol><li>学习不求甚解，贪多而不精（客观上时间来不及，主观上心态出了问题），上半年的时间上就可以看出来，学了那么多东西，但是真正能融汇贯通的很少。</li><li>学习习惯不好，总想一口吃成胖子，不能对自己的实力有客观的评价（时而过高时而过低），根本原因在于实践太少。</li><li>抗压能力不够，很多事情总希望一个人解决，没有把问题及早的抛出来（虽然现在不知道抛出来管不管用），不愿意分享真实想法，心态太容易崩了。</li><li>对业界行情了解不够，算是没有什么眼界吧，跳出来之后感觉自己就像井底之蛙。</li><li>不够目标导向。</li><li>表达能力堪忧，无论是口头的还是文字上的，都显得有些业余。</li></ol><h2 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h2><ol><li>分布式系统和存储引擎的入门让我在新公司的整体技术架构上比较熟悉，能够大致了解基础架构，中间件的原理和使用</li><li>实现yedis的btree和bustub中才感觉真正能用c++写点东西了</li><li>和同学的交流变多，认清了当前自己的水平</li></ol><h2 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h2><ol><li>注重实践，从btree这一个点上突破存储引擎，存储引擎突破了之后再考虑分布式的事情。</li><li>持续改进学习习惯，给自己创造能够持续学习的时间段。</li><li>平衡好工作和自己的学习，优先高标准的完成工作，有余力再投入到自己的学习中，像分布式系统，mysql这种在工作中就可以学习。</li><li>持续产出文章，学习要有阶段性的总结。</li></ol><h2 id="再谈目标"><a href="#再谈目标" class="headerlink" title="再谈目标"></a>再谈目标</h2><ol><li>能够用c++实现yedis，支持分布式架构</li><li>每两周一篇blog</li><li>golang的源码阅读</li><li>熟练使用java和spring</li></ol><h2 id="未来"><a href="#未来" class="headerlink" title="未来"></a>未来</h2><ol><li>道阻且长，全力以赴</li><li>既往不咎，纵情向前</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BTree Leaf Node分裂问题</title>
      <link href="/2020/12/19/btree%20leaf%20node%E7%9A%84%E5%88%86%E8%A3%82%E8%AE%B0%E5%BD%95/"/>
      <url>/2020/12/19/btree%20leaf%20node%E7%9A%84%E5%88%86%E8%A3%82%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h3 id="BTree-Leaf-Node分裂问题记录"><a href="#BTree-Leaf-Node分裂问题记录" class="headerlink" title="BTree Leaf Node分裂问题记录"></a>BTree Leaf Node分裂问题记录</h3><p>这两天在做BTree的实现的时候被一个问题困住了，就是BPlusTreeInternalPage的分裂问题</p><p>cmu15445中，BPlusTreeInternalPage 只提供了一个MoveHalfTo的操作，这在我看来是不够用的</p><ul><li>先看下bustub的api</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MoveAllTo</span><span class="params">(BPlusTreeInternalPage *recipient, <span class="type">const</span> KeyType &amp;middle_key, BufferPoolManager *buffer_pool_manager)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MoveHalfTo</span><span class="params">(BPlusTreeInternalPage *recipient, BufferPoolManager *buffer_pool_manager)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MoveFirstToEndOf</span><span class="params">(BPlusTreeInternalPage *recipient, <span class="type">const</span> KeyType &amp;middle_key,</span></span></span><br><span class="line"><span class="params"><span class="function">                        BufferPoolManager *buffer_pool_manager)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MoveLastToFrontOf</span><span class="params">(BPlusTreeInternalPage *recipient, <span class="type">const</span> KeyType &amp;middle_key,</span></span></span><br><span class="line"><span class="params"><span class="function">                         BufferPoolManager *buffer_pool_manager)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>而我在yedis中写的btree 中internalnode会把midkey提到parent上以保持btree的特性</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BTreeNodePage* <span class="title">index_split</span><span class="params">(BufferPoolManager*, BTreeNodePage* parent, <span class="type">int</span> child_idx)</span></span>;</span><br></pre></td></tr></table></figure><h4 id="解释下两种api的作用"><a href="#解释下两种api的作用" class="headerlink" title="解释下两种api的作用"></a>解释下两种api的作用</h4><ol><li>bustub 分裂之后</li></ol><p><img src="/home/skyitachi/lab/blog/imgs/image-20201219221942147.png" alt="image-20201219221942147"></p><p>bustub中第一个key都是无效的，所以能保证ki &gt; (k in pi)</p><p>这种分裂乍看起来第二页多了一个key，后续在这个page上insert,让我感觉有点不对劲，<strong>事实上只要忽略第一个key就好了，本例子中直接忽略k2</strong></p><ol start="2"><li><p>yedis的分裂</p><p><img src="/home/skyitachi/lab/blog/imgs/image-20201219222511014.png" alt="image-20201219222511014"></p></li></ol><p>我会主动把mid-key剔除出去（要插入到parent中），这样看起来就干净有点了，事实上两者没什么区别。</p><p>这只是一个思维上的转变，bustub的抽象更好些，yedis中的操作api都是太零散了，继续加油</p>]]></content>
      
      
      
        <tags>
            
            <tag> cmu15445 btree cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二分法的两种实现</title>
      <link href="/2020/04/14/%E4%BA%8C%E5%88%86%E6%B3%95%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%AE%9E%E7%8E%B0/"/>
      <url>/2020/04/14/%E4%BA%8C%E5%88%86%E6%B3%95%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>虽然二分搜索很简单（在无重复的有序数组上）,但是也有很多值得注意的地方，而且有两种完全不同的写法（两种完全不同的功能）</p><h4 id="lower-bound"><a href="#lower-bound" class="headerlink" title="lower bound"></a>lower bound</h4><blockquote><p>找出大于等于target的最小数组下标, 不存在的情况下返回-1</p></blockquote><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lower_bound</span><span class="params">(a []<span class="type">int</span>, target <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">  l := <span class="number">0</span></span><br><span class="line">  h := <span class="built_in">len</span>(a) - <span class="number">1</span></span><br><span class="line">  <span class="keyword">for</span> l &lt; h &#123;</span><br><span class="line">    m := l + (h - l) / <span class="number">2</span></span><br><span class="line">    <span class="keyword">if</span> a[m] &gt;= target &#123;</span><br><span class="line">      h = m</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// l肯定可以取到h值，所以不需要使用向上取整计算m值</span></span><br><span class="line">      l += <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> a[l] &gt;= target &#123;</span><br><span class="line">    <span class="keyword">return</span> l</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="upper-bound"><a href="#upper-bound" class="headerlink" title="upper bound"></a>upper bound</h4><blockquote><p>找出小于等于target的最大数组下标</p></blockquote><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">upper_bound</span><span class="params">(a []<span class="type">int</span>, target <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">  l := <span class="number">0</span></span><br><span class="line">h := <span class="built_in">len</span>(a) - <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> l &lt; h &#123;</span><br><span class="line">m := l + (h - l + <span class="number">1</span>) / <span class="number">2</span></span><br><span class="line"><span class="keyword">if</span> a[m] &lt;= target &#123;</span><br><span class="line">      <span class="comment">// l 要能够取到h值，就必须保证m使用向上取整计算, (h - l + 1) / 2 就是这么来的</span></span><br><span class="line">l = m</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">h = m - <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> a[l] &lt;= target &#123;</span><br><span class="line"><span class="keyword">return</span> l</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h4><ul><li>计算mid的时候不能发生溢出</li><li>数组下标不能越界</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>dubbo-go support protobuf</title>
      <link href="/2019/12/30/dubbo-go-protobuf-support/"/>
      <url>/2019/12/30/dubbo-go-protobuf-support/</url>
      
        <content type="html"><![CDATA[<h4 id="主要用法"><a href="#主要用法" class="headerlink" title="主要用法"></a>主要用法</h4><ul><li>和grpc中使用protobuf生成代码基本一致（至少在形式上）,直接看例子吧</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">├── go-client</span><br><span class="line">│   ├── client.go</span><br><span class="line">│   ├── client.yml</span><br><span class="line">├── go-server</span><br><span class="line">│   ├── main.go</span><br><span class="line">│   └── server.yml</span><br><span class="line">└── user</span><br><span class="line">    ├── user.pb.go</span><br><span class="line">    └── user.proto</span><br></pre></td></tr></table></figure><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> user;</span><br><span class="line"></span><br><span class="line"><span class="keyword">service </span><span class="title class_">UserProvider</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">rpc</span> GetUser (UserRequest) <span class="keyword">returns</span> (UserReply) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">UserRequest</span> &#123;</span><br><span class="line">  <span class="type">string</span> id = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">UserReply</span> &#123;</span><br><span class="line">  <span class="type">string</span> id = <span class="number">1</span>;</span><br><span class="line">  <span class="type">string</span> name = <span class="number">2</span>;</span><br><span class="line">  <span class="type">int32</span> age = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用protoc-gen-dubbogo插件生成dubbogo的代理</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protoc --plugin=&#123;plugin_path&#125; --dubbogo_out=plugins=dubbogo:. user/user.proto</span><br></pre></td></tr></table></figure><ul><li>client关键代码</li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">user := user.NewUserProvider()</span><br><span class="line">reply := user.UserReply&#123;&#125;</span><br><span class="line">err := userProvider.GetUser(context.TODO(), &amp;user.UserRequest&#123;Id: <span class="string">&quot;A001&quot;</span>&#125;, &amp;reply)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">  log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;response result: %+v&quot;</span>, reply)</span><br></pre></td></tr></table></figure><p>ps: 一切都是熟悉的味道<br>ps: 生成代理的名称需要和reference里配置的一样</p><ul><li>server关键代码</li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> UserProvider <span class="keyword">struct</span> &#123;</span><br><span class="line">pb.UnimplementedUserProviderServer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*UserProvider)</span></span> GetUser(ctx context.Context, user *pb.UserRequest) (*pb.UserReply, <span class="type">error</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> &amp;pb.UserReply&#123;Id: <span class="string">&quot;001&quot;</span>, Name: <span class="string">&quot;alice&quot;</span>, Age: <span class="number">18</span>&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册</span></span><br><span class="line">pb.RegisterProvider(<span class="built_in">new</span>(UserProvider))</span><br></pre></td></tr></table></figure><h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><ul><li>在dubbogo抽出一层serialization，任何和serialization相关的之后只要实现Serialize接口就行了，这样是为了更好的实现更多序列化的支持，逻辑上会更合理一些，原有的go hessian2中做了一部分dubbo相关的codec工作，这里我也把它抽到dubbogo中了， 当然hessian2的序列化仍然保留了，这次实现是兼容老版本的。</li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Serializer <span class="keyword">interface</span> &#123;</span><br><span class="line">Marshal(p DubboPackage) ([]<span class="type">byte</span>, <span class="type">error</span>)</span><br><span class="line">Unmarshal([]<span class="type">byte</span>, *DubboPackage) <span class="type">error</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>参考了dubbo的protobuf实现，实现了在protobuf层面和java互通（不一定是好事:(）</li><li>其他的就是细节了</li></ul><h4 id="一些注意点"><a href="#一些注意点" class="headerlink" title="一些注意点"></a>一些注意点</h4><ul><li><code>error</code>的处理和java不太一样，java会把详细的java error stack都返回给客户端，go只会把message传过来，生成一个error</li><li>由于java protobuf生成的代理方法名是小写开头(完全搞不明白是为什么)，这在golang中表示私有方法，个人已经提了<a href="https://github.com/apache/dubbo/issues/5536">issue</a>, 所以直接用java的例子是不行的</li><li>java protobuf的代理生成的是内部接口，比如xxx$IDemoService, <code>$</code>是url中的一个特殊字符，正好发现了dubbogo的一个注册url的bug</li></ul><h4 id="我为什么要支持protobuf"><a href="#我为什么要支持protobuf" class="headerlink" title="我为什么要支持protobuf"></a>我为什么要支持protobuf</h4><ul><li>protobuf的语言中立性更好，序列化性能也更好</li><li>更加符合golang的生态</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> dubbo, go, protobuf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++中的传参</title>
      <link href="/2019/08/21/passing-value-in-cpp/"/>
      <url>/2019/08/21/passing-value-in-cpp/</url>
      
        <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>最近在用c++写基于libuv的websocket engine的时候发现, 设置callback的参数是一个很有挑战性的工作, 原来觉得c++的复杂在于其模板，oo范式概念的复杂, 现在发现c++的每个方面都很复杂，因为有太多可以通过编译的方式了，我想从传参这个方面切入，让大家了解下c++的复杂（强大）。</p><p>ps：本文的传参使基于涉及到动态内存分配对象的传参，一般普通对象的传参基本是不需要考虑这么复杂的(至少我目前这么认为)。</p><p>以下是本文中需要传递的参数，一个简单的String, 只保留会讲到的构造函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">String</span>: &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">String</span>(<span class="type">const</span> <span class="type">char</span>* src): <span class="built_in">data_</span>(<span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(src) + <span class="number">1</span>]), <span class="built_in">size_</span>(<span class="built_in">strlen</span>(src)) &#123;</span><br><span class="line">      ::<span class="built_in">strcpy</span>(data_, src);</span><br><span class="line">      data_[size_] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">String</span>(<span class="type">const</span> String&amp; lhs): <span class="built_in">data_</span>(<span class="keyword">new</span> <span class="type">char</span>[lhs.<span class="built_in">size</span>() + <span class="number">1</span>]), <span class="built_in">size_</span>(lhs.<span class="built_in">size</span>()) &#123;</span><br><span class="line">      ::<span class="built_in">strcpy</span>(data_, lhs.<span class="built_in">data</span>());</span><br><span class="line">      data_[size_] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// move</span></span><br><span class="line">    <span class="built_in">String</span>(String &amp;&amp;rhs) <span class="keyword">noexcept</span>: <span class="built_in">data_</span>(rhs.data_), <span class="built_in">size_</span>(rhs.size_) &#123;</span><br><span class="line">      rhs.data_ = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我遇到的一个问题是在MessageCallback中，应该使用<code>const String&amp; message</code>还是<code>String&amp;&amp; message</code>, 这两种形参的区别是什么</p><h5 id="理解std-move-和右值引用"><a href="#理解std-move-和右值引用" class="headerlink" title="理解std::move 和右值引用"></a>理解<code>std::move</code> 和<code>右值引用</code></h5><p>在弄清上述问题之前，还是要从根本上着手，弄清<code>std::move</code>和右值引用。<br>右值引用是c++11中引入的一种新的引用类型，必须要绑定到右值的引用。<br>而std::move的作用是可以把几乎任意值转化成一个右值引用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_passing_value</span><span class="params">(std::string&amp; s1)</span> </span>&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;in the left reference&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_passing_value</span><span class="params">(std::string&amp;&amp; s1)</span> </span>&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;in the right reference&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::string s1 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">std::string &amp;sr = s1;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test_passing_value</span>(s1); <span class="comment">// in the left</span></span><br><span class="line"><span class="built_in">test_passing_value</span>(std::<span class="built_in">move</span>(s1)); <span class="comment">// in the right</span></span><br><span class="line"><span class="built_in">test_passing_value</span>(sr); <span class="comment">// in the left</span></span><br><span class="line"><span class="built_in">test_passing_value</span>(std::<span class="built_in">move</span>(sr)); <span class="comment">// in the right</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以看到无论是左值，还是左值引用，使用std::move之后都可以变成右值引用</span></span><br><span class="line"><span class="comment">// 意外的情况就是const T&amp; 在使用std::move转化时的特殊情况</span></span><br></pre></td></tr></table></figure><h5 id="const-T-vs-T"><a href="#const-T-vs-T" class="headerlink" title="const T&amp; vs T&amp;&amp;"></a><code>const T&amp;</code> vs <code>T&amp;&amp;</code></h5><p>c++11中引入了右值引用和move语义，初学者（比如我）很容易被这种特性吸引（move比copy快）, 两者其实是解决不同场景下的问题，T&amp;&amp; 的确提供了一种更为高效的传参方式, 让我们看下两者的细节和使用场景吧。</p><ul><li><p>仅仅使用<code>const T&amp;</code>并不会发生copy</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">const</span> String&amp; s)</span> </span>&#123;</span><br><span class="line">  std::cout &lt;&lt; s &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">String <span class="title">s0</span><span class="params">(<span class="string">&quot;hello&quot;</span>)</span></span>;</span><br><span class="line">  <span class="built_in">foo</span>(s0); <span class="comment">// 不会发生复制</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>const T&amp;</code> 发生复制的情况是在函数体内用到T的local variable， 比如<code>T local = t</code>, 这时候会发生拷贝控制</p></li><li><p>仅仅使用<code>T&amp;&amp;</code>不会发生move</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f2</span><span class="params">(String &amp;&amp;s2)</span> </span>&#123;</span><br><span class="line">  std::cout &lt;&lt; s2 &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">f2</span>(<span class="built_in">String</span>(<span class="string">&quot;hello&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从以上两种情况来看似乎传参的代价都很低，那么应该如何选择呢，主要还是根据语义来做选择，如果你的实参是个左值自然选择第一种，如果是右值那自然是后者，如果你确定需要第二种那么使用<code>std::move</code>也是可以的</p></li></ul><h5 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h5><ul><li>由于我在传给callback的string是从buffer中复制构造来的，而不是仅仅像stringpiece那样使用，所以使用右值引用更合适，使用者会放心大胆的使用这个string，move之类的更不在话下了</li></ul><h5 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h5><ul><li>可以考虑使用StringPiece类似的技术，不过我感觉StringPiece在这个场景下并不好</li><li>关于std::move的原理其中涉及到了引用折叠这些比较复杂的概念，所以没有深入介绍</li><li>在模板中使用T&amp;&amp; 和实参中的&amp;&amp;还是不一样的，模板中的T&amp;&amp; 在转发参数时要保证不丢失T的信息(T可能是引用) 所以有涉及到了完美转发的概念，std::forward可以解决这个问题</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈 javascript 作用域</title>
      <link href="/2017/04/24/scope/"/>
      <url>/2017/04/24/scope/</url>
      
        <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><ul><li>本文将主要介绍javascript中作用域相关的问题，尽可能多的使用代码举例说明，尽量少涉及动态作用域相关</li></ul><h4 id="词法作用域-核心"><a href="#词法作用域-核心" class="headerlink" title="词法作用域(核心)"></a>词法作用域(核心)</h4><blockquote><p>javascript的作用域是词法作用域（静态作用域）, 不过像<code>eval</code>，<code>with</code>这些具有动态改变作用域的能力, 本文重点在于词法作用域</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">testLexicalScope</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// 由于当前scope中a是由最外层定义的，所以此处的a只能访问到最外层的a</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">b</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">2</span>;</span><br><span class="line">  <span class="title function_">testLexicalScope</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">b</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 另一个例子</span></span><br><span class="line"><span class="keyword">let</span> sameVar1 = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> sameVar2 = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">outerScope</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> sameVar1 = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">innerScope</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;current scope: sameVar1 is &quot;</span>, sameVar1); <span class="comment">// 当前的scope中最近的sameVar1值是2</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;current scope: sameVar2 is &quot;</span>, sameVar2);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">innerScope</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">outerScope</span>();</span><br><span class="line"><span class="comment">// current scope: sameVar1 is  2</span></span><br><span class="line"><span class="comment">// current scope: sameVar2 is  1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//另一个例子</span></span><br><span class="line"><span class="keyword">const</span> f1 = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(outVar);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> outVar = <span class="number">1</span>;</span><br><span class="line"><span class="title function_">f1</span>(); <span class="comment">// 1 why</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>只有在函数声明的时候才会遵循lexical scope的规则, 如果是函数表达式则取决于调用的时机</p></blockquote><h4 id="不同类型的作用域-如何创建scope"><a href="#不同类型的作用域-如何创建scope" class="headerlink" title="不同类型的作用域(如何创建scope)"></a>不同类型的作用域(如何创建scope)</h4><ul><li>函数作用域</li></ul><blockquote><p>属于这个函数的全部变量都可以在整个函数的范围内使用及复用<br>javascript 每个函数都会创建一个scope</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fScope</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> aStr = <span class="string">&quot;function&quot;</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(aStr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">fScope</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(aStr); <span class="comment">// ReferenceError: aStr is not defined</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>块级作用域({…})</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="literal">true</span>;</span><br><span class="line">&#123; <span class="comment">// 这里是使用let，将foo绑定到了&#123;&#125;这个块作用域中</span></span><br><span class="line">  <span class="keyword">let</span> foo = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">let</span> bar = <span class="string">&quot;cannot seen&quot;</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(foo); <span class="comment">// false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(bar); <span class="comment">// ReferenceError</span></span><br></pre></td></tr></table></figure><h4 id="var"><a href="#var" class="headerlink" title="var"></a><code>var</code></h4><ul><li>函数作用域中的<code>var</code>仍然遵循函数作用域相关的</li><li><code>var</code>中没有块级作用域</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="literal">true</span>;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">var</span> foo = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">var</span> bar = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo); <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(bar); <span class="comment">// bar</span></span><br></pre></td></tr></table></figure><h4 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h4><blockquote><p>变量和函数的所有声明多会在任何代码被执行前首先被处理（编译器找到这些变量与合适的作用域关联）</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">hoisting</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">hoisting</span>();</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>又是let</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">hoisting</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// 第一个let之上的区域叫做`temporal dead zone`</span></span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">hoisting</span>(); <span class="comment">// ReferenceError</span></span><br></pre></td></tr></table></figure><p><strong>函数声明的优先级会高于变量声明</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">foo</span>(); <span class="comment">// in the function</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;in the function&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li>关于块级作用域, 可用try{} catch(err) {&#x2F;<em>这里是块级作用域</em>&#x2F;}模拟，更多参考:《你不知道的javascript》上卷中3.4.2节</li><li>使用<code>let</code>，<code>const</code>是最佳实践</li><li>需要区分函数声明和函数表达式</li><li>尽量不要写有提升的代码（声明尽量提前）</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
