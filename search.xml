<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>ann-benchmarks中hnsw简单解读</title>
      <link href="/2024/07/23/hnswlib%E5%92%8Cfaiss_hnsw%E7%9A%84ann-benchmarks%E7%BB%93%E6%9E%9C%E8%A7%A3%E8%AF%BB/"/>
      <url>/2024/07/23/hnswlib%E5%92%8Cfaiss_hnsw%E7%9A%84ann-benchmarks%E7%BB%93%E6%9E%9C%E8%A7%A3%E8%AF%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="hnswlib和faiss-hnsw在ann-benchmark中的参数解读"><a href="#hnswlib和faiss-hnsw在ann-benchmark中的参数解读" class="headerlink" title="hnswlib和faiss_hnsw在ann-benchmark中的参数解读"></a>hnswlib和faiss_hnsw在ann-benchmark中的参数解读</h1><p><a href="https://ann-benchmarks.com/sift-128-euclidean_10_euclidean.html">benchmark链接</a><br>只需要关注hnswlib和hnsw(faiss) 即可</p><h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><ul><li>数据集: sift-128-euclidean数据集(向量的维度是128)</li><li>k-nn的k是10</li><li>hnswlib和faiss_hnsw的benchmark都是基于单线程的</li></ul><h2 id="benchmark的细节点说明"><a href="#benchmark的细节点说明" class="headerlink" title="benchmark的细节点说明"></a>benchmark的细节点说明</h2><ol><li><p>hnswlib中有相同图例的点, eg：<code>Parameters: hnswlib (&#123;&#39;M&#39;: 12, &#39;efConstruction&#39;: 500&#125;)</code> 这样得点标记了好几个，但是QPS和Recall都不相同,<br>原因在于hnswlib的benchmark配置中有query-args参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// ann_benchmarks/algorithms/hnswlib/config.yml</span><br><span class="line">float:</span><br><span class="line">  any:</span><br><span class="line">  - base_args: [&#x27;@metric&#x27;]</span><br><span class="line">    constructor: HnswLib</span><br><span class="line">    disabled: false</span><br><span class="line">    docker_tag: ann-benchmarks-hnswlib</span><br><span class="line">    module: ann_benchmarks.algorithms.hnswlib</span><br><span class="line">    name: hnswlib</span><br><span class="line">    run_groups:</span><br><span class="line">      M-12:</span><br><span class="line">        arg_groups: [&#123;M: 12, efConstruction: 500&#125;]</span><br><span class="line">        args: &#123;&#125;</span><br><span class="line">        query_args: [[10, 20, 40, 80, 120, 200, 400, 600, 800]]</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">// query_args 对应了 hnswlib/module.py中的set_query_arguments函数的参数</span><br><span class="line"></span><br><span class="line">    def set_query_arguments(self, ef):</span><br><span class="line">        self.p.set_ef(ef)</span><br></pre></td></tr></table></figure></li><li><p>hnswlib中set_ef和faiss_hnsw中设置efSearch的效果是一样的, faiss中的图例就标注了efSearch(ef) <code>,&quot;faiss (&#123;&#39;M&#39;: 12, &#39;efConstruction&#39;: 500&#125;, ef: 80)</code></p></li><li><p>efSearch不影响build，所以在Recall&#x2F;Build time的图上hnswlib就没有”重复”的点了</p></li></ol><h1 id="hnswlib和faiss-hnsw的性能表现"><a href="#hnswlib和faiss-hnsw的性能表现" class="headerlink" title="hnswlib和faiss_hnsw的性能表现"></a>hnswlib和faiss_hnsw的性能表现</h1><p>主要看recall和build的表现</p><h2 id="ann-benchmark中的表现"><a href="#ann-benchmark中的表现" class="headerlink" title="ann-benchmark中的表现"></a>ann-benchmark中的表现</h2><p>参考ann-benchmark的论文，他们运行的硬件环境是: Amazon EC2 c5.4xlarge instances that are equipped with Intel Xeon Platinum 8124M CPU (16 cores available, 3.00 GHz, 25.0MB Cache) and 32GB of RAM running Amazon Linux.</p><p>ann-benchmarks网站上的benchmark如下:</p><p><img src="/../../imgs/annb_recall_hnsw.png" alt="Recall"></p><p>说明: </p><ol><li><p>整体QPS随着recall的上升成指数级的下降 (两者都是)</p></li><li><p>相同召回率的情况下，hnswlib的QPS要高一点, 由于faiss标注了ef(efSearch)但是hnswlib没有标注，所以比较起来不太直观，后面我在本地自己跑的时候给hnswlib带上了ef参数，这样就更加直观了</p></li></ol><p><img src="/../../imgs/annb_build_hnsw.png" alt="Build Index Time"></p><p>说明: 1. Build Index Time也是hnswlib占优</p><h2 id="本地的表现"><a href="#本地的表现" class="headerlink" title="本地的表现"></a>本地的表现</h2><p>硬件环境: AMD Ryzen 5 3600 (3.6G Hz), 6 core 12 threads, 32GB of RAM running Ubuntu 24.04</p><p>这里我修改了ann-benchmarks中hnswlib的环境和在efConstruction&#x3D;200和500的情况下比较hnswlib的表现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// ann_benchmarks/algorithms/hnswlib/config.yml</span><br><span class="line">FROM ann-benchmarks</span><br><span class="line"></span><br><span class="line"># RUN apt-get install -y python-setuptools python-pip</span><br><span class="line">RUN pip3 install pybind11 numpy setuptools hnswlib==0.8.0</span><br><span class="line"></span><br><span class="line"># RUN cd hnsw/python_bindings; python3 setup.py install</span><br><span class="line"></span><br><span class="line">RUN python3 -c &#x27;import hnswlib&#x27;</span><br></pre></td></tr></table></figure><h3 id="Recall-QPS-表现"><a href="#Recall-QPS-表现" class="headerlink" title="Recall &amp; QPS 表现"></a>Recall &amp; QPS 表现</h3><p>关于recall 我们更需要关注是否通过参数配置到足够高的精度，我这里以0.99的recall作为基础，主要比较在0.99以上的召回率条件下(qps &gt; 2000)，两种算法实现的qps及其对应的参数</p><table><thead><tr><th>algorithm</th><th>parameters</th><th>k-nn(recall)</th><th>qps</th><th>build(s)</th><th>indexsize(kb)</th></tr></thead><tbody><tr><td>faiss_hnsw</td><td>faiss ({‘M’: 24, ‘efConstruction’: 500}, ef: 80)</td><td>0.99031</td><td>2561.923162412995</td><td>1458.773098230362</td><td>794864.0</td></tr><tr><td>faiss_hnsw</td><td>faiss ({‘M’: 16, ‘efConstruction’: 500}, ef: 120)</td><td>0.99347</td><td>2194.419076982479</td><td>1285.849939107895</td><td>732492.0</td></tr><tr><td>faiss_hnsw</td><td>faiss ({‘M’: 36, ‘efConstruction’: 500}, ef: 80)</td><td>0.99314</td><td>2191.7604350595634</td><td>1585.1033165454865</td><td>888936.0</td></tr><tr><td>faiss_hnsw</td><td>faiss ({‘M’: 48, ‘efConstruction’: 500}, ef: 80)</td><td>0.99411</td><td>2077.6779248107487</td><td>1667.5446255207062</td><td>982148.0</td></tr><tr><td>hnswlib</td><td>hnswlib ({‘M’: 64, ‘efConstruction’: 200}, ef: 80)</td><td>0.9901500000000001</td><td>3731.2651844102425</td><td>496.65849924087524</td><td>1150800.0</td></tr><tr><td>hnswlib</td><td>hnswlib ({‘M’: 96, ‘efConstruction’: 200}, ef: 80)</td><td>0.9902599999999999</td><td>3616.44180507205</td><td>513.7249546051025</td><td>1400632.0</td></tr><tr><td>hnswlib</td><td>hnswlib ({‘M’: 36, ‘efConstruction’: 500}, ef: 80)</td><td>0.99308</td><td>3571.6658501707066</td><td>1156.385510444641</td><td>931660.0</td></tr><tr><td>hnswlib</td><td>hnswlib ({‘M’: 24, ‘efConstruction’: 200}, ef: 120)</td><td>0.9939</td><td>3314.9200264352426</td><td>426.75320744514465</td><td>838564.0</td></tr><tr><td>hnswlib</td><td>hnswlib ({‘M’: 48, ‘efConstruction’: 500}, ef: 80)</td><td>0.99433</td><td>3290.7135482210724</td><td>1246.9214706420898</td><td>1026148.0</td></tr><tr><td>hnswlib</td><td>hnswlib ({‘M’: 64, ‘efConstruction’: 500}, ef: 80)</td><td>0.9946999999999999</td><td>3153.6867226554614</td><td>1276.8294219970703</td><td>1146332.0</td></tr><tr><td>hnswlib</td><td>hnswlib ({‘M’: 24, ‘efConstruction’: 500}, ef: 120)</td><td>0.9955999999999999</td><td>3139.927141602247</td><td>1008.0483357906342</td><td>838676.0</td></tr><tr><td>hnswlib</td><td>hnswlib ({‘M’: 12, ‘efConstruction’: 200}, ef: 200)</td><td>0.9920199999999999</td><td>3100.2119285498034</td><td>313.95580410957336</td><td>745664.0</td></tr><tr><td>hnswlib</td><td>hnswlib ({‘M’: 12, ‘efConstruction’: 500}, ef: 200)</td><td>0.99271</td><td>3040.3355289720653</td><td>709.9178235530853</td><td>745132.0</td></tr><tr><td>hnswlib</td><td>hnswlib ({‘M’: 96, ‘efConstruction’: 500}, ef: 80)</td><td>0.9949</td><td>3036.296166689699</td><td>1317.8283751010895</td><td>1400940.0</td></tr><tr><td>hnswlib</td><td>hnswlib ({‘M’: 36, ‘efConstruction’: 200}, ef: 120)</td><td>0.99544</td><td>2873.9128879689624</td><td>466.08784890174866</td><td>931436.0</td></tr><tr><td>hnswlib</td><td>hnswlib ({‘M’: 48, ‘efConstruction’: 200}, ef: 120)</td><td>0.9956799999999999</td><td>2690.4460742892884</td><td>482.9417383670807</td><td>1025096.0</td></tr><tr><td>hnswlib</td><td>hnswlib ({‘M’: 64, ‘efConstruction’: 200}, ef: 120)</td><td>0.99576</td><td>2671.663602183599</td><td>496.65849924087524</td><td>1150800.0</td></tr><tr><td>hnswlib</td><td>hnswlib ({‘M’: 36, ‘efConstruction’: 500}, ef: 120)</td><td>0.99753</td><td>2612.247989122775</td><td>1156.385510444641</td><td>931660.0</td></tr><tr><td>hnswlib</td><td>hnswlib ({‘M’: 96, ‘efConstruction’: 200}, ef: 120)</td><td>0.99588</td><td>2581.161300550079</td><td>513.7249546051025</td><td>1400632.0</td></tr><tr><td>hnswlib</td><td>hnswlib ({‘M’: 16, ‘efConstruction’: 200}, ef: 200)</td><td>0.9962</td><td>2565.1980331237614</td><td>364.242990732193</td><td>778360.0</td></tr><tr><td>hnswlib</td><td>hnswlib ({‘M’: 48, ‘efConstruction’: 500}, ef: 120)</td><td>0.9979100000000001</td><td>2394.6802442922076</td><td>1246.9214706420898</td><td>1026148.0</td></tr><tr><td>hnswlib</td><td>hnswlib ({‘M’: 64, ‘efConstruction’: 500}, ef: 120)</td><td>0.9980800000000001</td><td>2282.691070497442</td><td>1276.8294219970703</td><td>1146332.0</td></tr><tr><td>hnswlib</td><td>hnswlib ({‘M’: 96, ‘efConstruction’: 500}, ef: 120)</td><td>0.99821</td><td>2188.4360442789643</td><td>1317.8283751010895</td><td>1400940.0</td></tr><tr><td>hnswlib</td><td>hnswlib ({‘M’: 24, ‘efConstruction’: 200}, ef: 200)</td><td>0.99818</td><td>2166.896152958348</td><td>426.75320744514465</td><td>838564.0</td></tr><tr><td>hnswlib</td><td>hnswlib ({‘M’: 8, ‘efConstruction’: 200}, ef: 400)</td><td>0.99244</td><td>2138.951169866413</td><td>256.2939279079437</td><td>715140.0</td></tr><tr><td>hnswlib</td><td>hnswlib ({‘M’: 8, ‘efConstruction’: 500}, ef: 400)</td><td>0.9936</td><td>2124.6338197635687</td><td>588.7308986186981</td><td>715372.0</td></tr><tr><td>hnswlib</td><td>hnswlib ({‘M’: 24, ‘efConstruction’: 500}, ef: 200)</td><td>0.9989100000000001</td><td>2017.995520316913</td><td>1008.0483357906342</td><td>838676.0</td></tr></tbody></table><h3 id="Build-Index-Time"><a href="#Build-Index-Time" class="headerlink" title="Build Index Time"></a>Build Index Time</h3><table><thead><tr><th>algorithm</th><th>parameters</th><th>indexsize</th><th>build</th></tr></thead><tbody><tr><td>hnswlib</td><td>hnswlib ({‘M’: 8, ‘efConstruction’: 200}, ef: 400)</td><td>715140.0</td><td>256.2939279079437</td></tr><tr><td>hnswlib</td><td>hnswlib ({‘M’: 12, ‘efConstruction’: 200}, ef: 200)</td><td>745664.0</td><td>313.95580410957336</td></tr><tr><td>hnswlib</td><td>hnswlib ({‘M’: 16, ‘efConstruction’: 200}, ef: 200)</td><td>778360.0</td><td>364.242990732193</td></tr><tr><td>hnswlib</td><td>hnswlib ({‘M’: 24, ‘efConstruction’: 200}, ef: 120)</td><td>838564.0</td><td>426.75320744514465</td></tr><tr><td>hnswlib</td><td>hnswlib ({‘M’: 36, ‘efConstruction’: 200}, ef: 120)</td><td>931436.0</td><td>466.08784890174866</td></tr><tr><td>hnswlib</td><td>hnswlib ({‘M’: 48, ‘efConstruction’: 200}, ef: 120)</td><td>1025096.0</td><td>482.9417383670807</td></tr><tr><td>hnswlib</td><td>hnswlib ({‘M’: 64, ‘efConstruction’: 200}, ef: 120)</td><td>1150800.0</td><td>496.65849924087524</td></tr><tr><td>hnswlib</td><td>hnswlib ({‘M’: 96, ‘efConstruction’: 200}, ef: 80)</td><td>1400632.0</td><td>513.7249546051025</td></tr><tr><td>hnswlib</td><td>hnswlib ({‘M’: 8, ‘efConstruction’: 500}, ef: 400)</td><td>715372.0</td><td>588.7308986186981</td></tr><tr><td>hnswlib</td><td>hnswlib ({‘M’: 12, ‘efConstruction’: 500}, ef: 200)</td><td>745132.0</td><td>709.9178235530853</td></tr><tr><td>hnswlib</td><td>hnswlib ({‘M’: 24, ‘efConstruction’: 500}, ef: 120)</td><td>838676.0</td><td>1008.0483357906342</td></tr><tr><td>hnswlib</td><td>hnswlib ({‘M’: 36, ‘efConstruction’: 500}, ef: 120)</td><td>931660.0</td><td>1156.385510444641</td></tr><tr><td>hnswlib</td><td>hnswlib ({‘M’: 48, ‘efConstruction’: 500}, ef: 120)</td><td>1026148.0</td><td>1246.9214706420898</td></tr><tr><td>hnswlib</td><td>hnswlib ({‘M’: 64, ‘efConstruction’: 500}, ef: 120)</td><td>1146332.0</td><td>1276.8294219970703</td></tr><tr><td>faiss_hnsw</td><td>faiss ({‘M’: 16, ‘efConstruction’: 500}, ef: 120)</td><td>732492.0</td><td>1285.849939107895</td></tr><tr><td>hnswlib</td><td>hnswlib ({‘M’: 96, ‘efConstruction’: 500}, ef: 120)</td><td>1400940.0</td><td>1317.8283751010895</td></tr><tr><td>faiss_hnsw</td><td>faiss ({‘M’: 24, ‘efConstruction’: 500}, ef: 80)</td><td>794864.0</td><td>1458.773098230362</td></tr><tr><td>faiss_hnsw</td><td>faiss ({‘M’: 36, ‘efConstruction’: 500}, ef: 80)</td><td>888936.0</td><td>1585.1033165454865</td></tr><tr><td>faiss_hnsw</td><td>faiss ({‘M’: 48, ‘efConstruction’: 500}, ef: 80)</td><td>982148.0</td><td>1667.5446255207062</td></tr></tbody></table><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>1.efConstruction越小，build 耗费时间越小，牺牲的精确性可以通过加大ef来弥补, 要想获取最佳性能需要对M，efConstruction, ef这三个参数进行平衡<br>2.indexsize 只和M有关系<br>3.整体而言，hnswlib的性能仍然要比faiss的hnsw的要好一点, 两者差距不大<br>4.efConstruction&#x3D;200的情况下通过适当调大ef也能实现较高的召回率，也不会带来性能损失，但是对Build Index Time 会有较大的提升</p><h1 id="其他细节指标解读"><a href="#其他细节指标解读" class="headerlink" title="其他细节指标解读"></a>其他细节指标解读</h1><ol><li>ann-benchmarks中通过python data_export.py可以得出详细的指标数据, 其中有两列<code>epsilon</code>, <code>largeepsilon</code><br>这里其实对应得是在算recall的时候，允许的距离误差大小(使用euclidean距离，就是向量召回的点和实际的knn的点距离误差), <code>epsilon</code> 是0.01， <code>largeepsilon</code>, 允许的误差越大，对应的recall 就越高, 论文中的实际公式如下:</li></ol><p><img src="/../../imgs/recall_epsilon.png"></p><ol start="2"><li>indexsize在graph base的算法中都挺大的，不过整体上hnswlib的更小一点</li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol><li><p>这里列举都是在特定数据集下的表现，事实上不同数据集下不同类型的算法表现不尽相同，hnswlib不是在任何情况下的表现都由于faiss_hnsw， 那在实际的生产环境中，还是需要对不同的算法进行benchmark，从而得出更好的参数和选出更好的算法</p></li><li><p>ann-benchmarks的论文指出虽然graph-based的算法在rand-euclidean的数据集下性能还不如faiss-ivf，但是在实际的数据集上，往往会有所谓的global structure出现，graph based的算法一般都是更好的选择，graph based中的hnsw也是更好的选择</p></li><li><p>ann-benchmarks也指出如果使用GPU的话，graph based的算法不如ivf这种简单的算法</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> algorithm hnsw 向量数据库 faiss hnswlib </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HNSW算法原理及其实现</title>
      <link href="/2024/07/22/HNSW%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/"/>
      <url>/2024/07/22/HNSW%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h1><ul><li>介绍HNSW的算法原理</li><li>介绍hnswlib和faiss中的实现，以及他们之间的区别</li><li>介绍HNSW中每个参数的实际影响</li></ul><h1 id="HNSW的算法原理"><a href="#HNSW的算法原理" class="headerlink" title="HNSW的算法原理"></a>HNSW的算法原理</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ol><li>HNSW的算法大致原理很像skplist，区别在于hnsw每层维护的是节点直接的链接（links）,每一层都是graph的结构，相同点就是每下一层的节点数更多,维护的图也越大，到了0层维护了所有节点的链接信息</li><li>无论是插入还是查找，都是从上往下找enter point（当前层和插入或者查询点最接近的点）,到了下一层时候，通过在enter point的链接的点中早出指定数量的候选集，并选出和目标点最接近的指定数量的点，建立连接</li><li>插入算法还需要维护当前的enter point</li></ol><h2 id="具体算法"><a href="#具体算法" class="headerlink" title="具体算法"></a>具体算法</h2><p>论文中有提到一些最佳参数设置，mL &#x3D; 1&#x2F;ln(M), Mmax &#x3D; M, Mmax0 &#x3D; M * 2 可以直接带入算法中的参数，减少未知量，看起来会清晰一点，其中hnswlib的实现就是按照这组参数来的</p><h3 id="SEARCH-LAYER算法"><a href="#SEARCH-LAYER算法" class="headerlink" title="SEARCH-LAYER算法"></a>SEARCH-LAYER算法</h3><p>SEARCH-LAYER(q, ep, ef, lc)</p><p>Input: query element q, enter points ep, number of nearest to q elements to return ef, layer number lc</p><p>Output: ef closest neighbors to q</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">v ← ep // set of visited elements</span><br><span class="line">C ← ep // set of candidates</span><br><span class="line">W ← ep // dynamic list of found nearest neighbors</span><br><span class="line"></span><br><span class="line">while │C│ &gt; 0</span><br><span class="line">  c ← extract nearest element from C to q</span><br><span class="line">  f ← get furthest element from W to q</span><br><span class="line"></span><br><span class="line">  if distance(c, q) &gt; distance(f, q)</span><br><span class="line">break // all elements in W are evaluated</span><br><span class="line">  for each e ∈ neighbourhood(c) at layer lc // update C and W</span><br><span class="line">if e ∉ v</span><br><span class="line">  v ← v ⋃ e</span><br><span class="line">f ← get furthest element from W to q</span><br><span class="line">if distance(e, q) &lt; distance(f, q) or │W│ &lt; ef</span><br><span class="line">  C ← C ⋃ e</span><br><span class="line">  W ← W ⋃ e</span><br><span class="line">  if │W│ &gt; ef</span><br><span class="line">remove furthest element from W to q</span><br><span class="line"></span><br><span class="line">return W</span><br></pre></td></tr></table></figure><h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><ul><li>ep可以是由多个点组成的集合，也可以是单个点</li></ul><h3 id="插入算法"><a href="#插入算法" class="headerlink" title="插入算法"></a>插入算法</h3><p>INSERT(hnsw, q, M, Mmax, efConstruction, mL)</p><p>Input: multilayer graph hnsw, new element q, number of established connections M, maximum number of connections for each element per layer Mmax, size of the dynamic candidate list efConstruction, normalization factor for level generation mL</p><p>Output: update hnsw inserting element q</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">W ← ∅ // list for the currently found nearest elements</span><br><span class="line">ep ← get enter point for hnsw</span><br><span class="line">L ← level of ep // top layer for hnsw</span><br><span class="line">l ← ⌊-ln(unif(0..1))∙mL⌋ // new element’s level</span><br><span class="line"></span><br><span class="line">for lc ← L … l+1</span><br><span class="line">  W ← SEARCH-LAYER(q, ep, ef=1, lc)</span><br><span class="line">  ep ← get the nearest element from W to q</span><br><span class="line">for lc ← min(L, l) … 0</span><br><span class="line">  W ← SEARCH-LAYER(q, ep, efConstruction, lc)</span><br><span class="line">  neighbors ← SELECT-NEIGHBORS(q, W, M, lc) // alg. 3 or alg. 4 </span><br><span class="line"> add bidirectionall connectionts from neighbors to q at layer lc</span><br><span class="line">for each e ∈ neighbors // shrink connections if needed</span><br><span class="line">  eConn ← neighbourhood(e) at layer lc</span><br><span class="line">  if │eConn│ &gt; Mmax // shrink connections of e</span><br><span class="line">if lc = 0 then Mmax = Mmax0</span><br><span class="line">eNewConn ← SELECT-NEIGHBORS(e, eConn, Mmax, lc)</span><br><span class="line">  // alg. 3 or alg. 4</span><br><span class="line">  set neighbourhood(e) at layer lc to eNewConn</span><br><span class="line">ep ← W</span><br><span class="line"></span><br><span class="line">if l &gt; L</span><br><span class="line">  set enter point for hnsw to q</span><br></pre></td></tr></table></figure><h4 id="entry-point的更新"><a href="#entry-point的更新" class="headerlink" title="entry point的更新"></a>entry point的更新</h4><ul><li>新插入的节点最终会变为全局的enter pointer</li><li>level0会维护2*M的链接</li></ul><h3 id="搜索算法"><a href="#搜索算法" class="headerlink" title="搜索算法"></a>搜索算法</h3><p>K-NN-SEARCH(hnsw, q, K, ef)</p><p>Input: multilayer graph hnsw, query element q, number of nearest neighbors to return K, size of the dynamic candidate list ef</p><p>Output: K nearest elements to q</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">W ← ∅ // set for the current nearest elements</span><br><span class="line">ep ← get enter point for hnsw</span><br><span class="line">L ← level of ep // top layer for hnsw</span><br><span class="line">for lc ← L … 1</span><br><span class="line">  W ← SEARCH-LAYER(q, ep, ef=1, lc)</span><br><span class="line">  ep ← get nearest element from W to q</span><br><span class="line"></span><br><span class="line">W ← SEARCH-LAYER(q, ep, ef, lc =0)</span><br><span class="line">return K nearest elements from W to q</span><br></pre></td></tr></table></figure><h4 id="说明-1"><a href="#说明-1" class="headerlink" title="说明"></a>说明</h4><ul><li><p>搜索过程从L-&gt;1 层每层只搜和query最近的enter point, 这就要求数据集是要有一定结构的，这样才能保证在最后一层搜索的时候质量不至于太差，如果是随机的数据集可能结果会不太好</p></li><li><p>efSearch要大于K才行(faiss里会保证efSearch最少是k)</p></li></ul><h3 id="SELECT-NEIGHBORS-算法"><a href="#SELECT-NEIGHBORS-算法" class="headerlink" title="SELECT-NEIGHBORS 算法"></a>SELECT-NEIGHBORS 算法</h3><h4 id="简单算法"><a href="#简单算法" class="headerlink" title="简单算法"></a>简单算法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT-NEIGHBORS-SIMPLE(q, C, M)</span><br><span class="line">Input: base element q, candidate elements C, number of neighbors to return M</span><br><span class="line"></span><br><span class="line">Output: M nearest elements to q</span><br><span class="line">return M nearest elements from C to q</span><br><span class="line">// 实际的实现就是一个优先权队列</span><br></pre></td></tr></table></figure><h4 id="启发式方法"><a href="#启发式方法" class="headerlink" title="启发式方法"></a>启发式方法</h4><p>SELECT-NEIGHBORS-HEURISTIC(q, C, M, lc, extendCandidates, keepPrunedConnections)</p><p>Input: base element q, candidate elements C, number of neighbors to return M, layer number lc, flag indicating whether or not to extend<br>candidate list extendCandidates, flag indicating whether or not to add discarded elements keepPrunedConnections</p><p>Output: M elements selected by the heuristic</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">R ← ∅</span><br><span class="line">W ← C // working queue for the candidates</span><br><span class="line">if extendCandidates // extend candidates by their neighbors</span><br><span class="line">  for each e ∈ C</span><br><span class="line">    for each eadj ∈ neighbourhood(e) at layer lc</span><br><span class="line">      if eadj ∉ W</span><br><span class="line">    W ← W ⋃ eadj</span><br><span class="line"></span><br><span class="line">Wd ← ∅ // queue for the discarded candidates</span><br><span class="line">while │W│ &gt; 0 and │R│&lt; M</span><br><span class="line">  e ← extract nearest element from W to q</span><br><span class="line">    if e is closer to q compared to any element from R</span><br><span class="line">  R ← R ⋃ e</span><br><span class="line">else</span><br><span class="line">  Wd ← Wd ⋃ e</span><br><span class="line"></span><br><span class="line">if keepPrunedConnections // add some of the discarded </span><br><span class="line">  // connections from Wd</span><br><span class="line">  while │Wd│&gt; 0 and │R│&lt; M</span><br><span class="line">    R ← R ⋃ extract nearest element from Wd to q</span><br><span class="line"></span><br><span class="line">return R</span><br></pre></td></tr></table></figure><h4 id="说明-2"><a href="#说明-2" class="headerlink" title="说明"></a>说明</h4><ul><li>第一种方法只从candidates选择，第二种方法从candidates里的邻接的点里选择（选择范围更大, 可能受数据集的影响较小）</li><li>hnswlib和faiss_hnsw都相当于用了第一种方法</li><li>启发式方法适合中维数据和多clustering的数据( mid-dimensional data and for the case of highly clustered data)</li></ul><h1 id="HNSW每个参数实际的影响"><a href="#HNSW每个参数实际的影响" class="headerlink" title="HNSW每个参数实际的影响"></a>HNSW每个参数实际的影响</h1><ul><li>dim: 数据维度，dim 越大计算量越大</li><li>max_elements: 数据总量</li><li>M: 每个向量的最大链接数, M越大占用的内存越大, 构建和搜索也是越慢（精度更高） </li><li>efConstruction: 每个向量构建或者搜索时的候选集大小，efConstruction越大，构建和搜索速度越慢 (不会影响内存消耗)</li></ul><h2 id="M-应该如何选择"><a href="#M-应该如何选择" class="headerlink" title="M 应该如何选择"></a>M 应该如何选择</h2><ul><li>论文中指出<code>A reasonable range of M is from 5 to 48</code></li></ul><h2 id="efConstruction"><a href="#efConstruction" class="headerlink" title="efConstruction"></a>efConstruction</h2><ul><li>efConstruction 对speed&#x2F;index quality有显著影响</li><li>论文中指出10M的sift dataset，用efConstruction&#x3D;100就能达到不错的召回率(0.95), 适用多线程并发构建的话速度也不错 </li><li>进一步提升efConstruction带来的收益并不明显，反而会较大影响构建速度</li></ul><h2 id="efSearch"><a href="#efSearch" class="headerlink" title="efSearch"></a>efSearch</h2><ul><li>搜索时候用到ef值，hnswlib和faiss_hnsw都可以单独设置</li><li>合适的efSearch能保证recall</li><li>efSearch也不是越高越好，边际效应越来越小，也会影响到搜索速度</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>关于详细的性能数据可以参考论文</li><li>测试性能的时候关键指标是 <code>Distance Computations</code>, <code>Query Time</code></li><li>可以使用PQ（乘积量化）的方式优化memory</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> algorithm hnsw 向量数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ES和Lucene之间的CRUD操作映射</title>
      <link href="/2024/05/11/ES%E5%92%8CLucene%E4%B9%8B%E9%97%B4%E7%9A%84CRUD%E6%93%8D%E4%BD%9C%E6%98%A0%E5%B0%84/"/>
      <url>/2024/05/11/ES%E5%92%8CLucene%E4%B9%8B%E9%97%B4%E7%9A%84CRUD%E6%93%8D%E4%BD%9C%E6%98%A0%E5%B0%84/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在ES中我们经常使用的数据格式json，ES也支持常见的CRUD操作，这里我们主要介绍写入相关的操作（创建，更新，删除），ES的底层存储引擎是Lucene，Lucene也有相关创建更新删除的操作，但是Lucene是没有显示的根据主键更新文档的api的，本文主要介绍的是在ES有_id的情况下，ES是如何基于Lucene实现增删改的操作的，其中的数据模型又是如何映射的.</p><p>ps: 本文不考虑ES中的数据类型到Lucene中的数据类型的映射（Field），所有的代码片段都是基于以下给定的类型映射</p><table><thead><tr><th>Name</th><th>ES type</th><th>Lucene Field</th></tr></thead><tbody><tr><td>item_id</td><td>keyword</td><td>StringField</td></tr><tr><td>name</td><td>keyword</td><td>StringField</td></tr><tr><td>color</td><td>keyword</td><td>StringField</td></tr></tbody></table><h3 id="lucene-如何基于id（主键）部分更新文档-基于lucene-9-7-0"><a href="#lucene-如何基于id（主键）部分更新文档-基于lucene-9-7-0" class="headerlink" title="lucene 如何基于id（主键）部分更新文档 (基于lucene 9.7.0)"></a>lucene 如何基于id（主键）部分更新文档 (基于lucene 9.7.0)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> &lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.apache.lucene&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;lucene-core&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;9.7.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h4 id="1-创建文档"><a href="#1-创建文档" class="headerlink" title="1. 创建文档"></a>1. 创建文档</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public static void createDocuments(IndexWriter indexWriter) throws IOException &#123;</span><br><span class="line">Document doc1 = new Document();</span><br><span class="line">doc1.add(new StringField(&quot;item_id&quot;, &quot;1&quot;, Field.Store.YES ));</span><br><span class="line">doc1.add(new StringField(&quot;name&quot;, &quot;item1&quot;, Field.Store.YES));</span><br><span class="line">doc1.add(new StringField(&quot;color&quot;, &quot;red&quot;, Field.Store.YES));</span><br><span class="line"></span><br><span class="line">Document doc2 = new Document();</span><br><span class="line">doc2.add(new StringField(&quot;item_id&quot;, &quot;2&quot;, Field.Store.YES));</span><br><span class="line">doc2.add(new StringField(&quot;name&quot;, &quot;item2&quot;, Field.Store.YES));</span><br><span class="line">doc2.add(new StringField(&quot;color&quot;, &quot;blue&quot;, Field.Store.YES));</span><br><span class="line"></span><br><span class="line">indexWriter.addDocument(doc1);</span><br><span class="line">indexWriter.addDocument(doc2);</span><br><span class="line"></span><br><span class="line">indexWriter.commit();</span><br><span class="line">indexWriter.flush();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-读取文档验证写入"><a href="#2-读取文档验证写入" class="headerlink" title="2. 读取文档验证写入"></a>2. 读取文档验证写入</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public static void getDocumentById(IndexReader reader, IndexSearcher searcher, String itemId) throws IOException &#123;</span><br><span class="line">Query query = new TermQuery(new Term(&quot;item_id&quot;, itemId));</span><br><span class="line">TopDocs topdocs = searcher.search(query, 10);</span><br><span class="line">assert topdocs.totalHits.value == 1;</span><br><span class="line"></span><br><span class="line">for (ScoreDoc doc: topdocs.scoreDocs) &#123;</span><br><span class="line">int docId = doc.doc;</span><br><span class="line">Document fullDoc = getDocumentByDocId(reader, docId);</span><br><span class="line"></span><br><span class="line">fullDoc.getFields().forEach(field -&gt; &#123;</span><br><span class="line">System.out.println(&quot;  &quot; + field.name() + &quot;: &quot; + field.stringValue());</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// item_id = &quot;1&quot;</span><br><span class="line">getDocumentById(reader, searcher, &quot;1&quot;);</span><br><span class="line">//  item_id: 1</span><br><span class="line">//  name: item1</span><br><span class="line">//  color: red</span><br><span class="line">getDocumentById(reader, searcher, &quot;2&quot;);</span><br><span class="line">//  item_id: 2</span><br><span class="line">//  name: item2</span><br><span class="line">//  color: blue</span><br></pre></td></tr></table></figure><h4 id="3-部分更新文档"><a href="#3-部分更新文档" class="headerlink" title="3. 部分更新文档"></a>3. 部分更新文档</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static void partialUpdateDocumentNameByItemId(IndexWriter writer, String itemId, String newName) throws IOException &#123;</span><br><span class="line">Document doc = new Document();</span><br><span class="line">doc.add(new StringField(&quot;name&quot;, newName, Field.Store.YES));</span><br><span class="line">// important: 这个作为主键的Term一定要带上</span><br><span class="line">doc.add(new StringField(&quot;item_id&quot;, itemId, Field.Store.YES));</span><br><span class="line">Term mainTerm = new Term(&quot;item_id&quot;, itemId);</span><br><span class="line">writer.updateDocument(mainTerm, doc);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="4-验证更新文档"><a href="#4-验证更新文档" class="headerlink" title="4. 验证更新文档"></a>4. 验证更新文档</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">partialUpdateDocumentNameByItemId(indexWriter, &quot;1&quot;, &quot;item1_updated&quot;);</span><br><span class="line">partialUpdateDocumentNameByItemId(indexWriter, &quot;2&quot;, &quot;item2_updated&quot;);</span><br><span class="line">indexWriter.commit();</span><br><span class="line">indexWriter.flush();</span><br><span class="line"></span><br><span class="line">indexReader = DirectoryReader.open(readDirectory);</span><br><span class="line">indexSearcher = new IndexSearcher(indexReader);</span><br><span class="line">getDocumentById(indexSearcher, &quot;1&quot;);</span><br><span class="line"></span><br><span class="line">indexReader = DirectoryReader.open(readDirectory);</span><br><span class="line">indexSearcher = new IndexSearcher(indexReader);</span><br><span class="line">getDocumentById(indexSearcher, &quot;2&quot;);</span><br><span class="line">//</span><br><span class="line">//  name: item1_updated</span><br><span class="line">//  item_id: 1</span><br><span class="line">//  name: item2_updated</span><br><span class="line">//  item_id: 2</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>结论： 由于在partialUpdateDocumentNameByItemId 中只写了item_id和name属性（符合update的直觉），但是可以看出Lucene把updateDocument中的doc对象当成了最新且完整的mainTerm对应的doc，这就导致了虽然我们目的是部分更新，但是会丢失没有写入（没有变化）的那些属性，这个例子也可以看出Lucene本质上是用新文档覆盖旧文档的形式，用一个可以代表主键的Term做关联，来实现部分更新字段的目的，这个和一般RDBMS的存储模型有点区别.</p><h4 id="5-完全更新所有字段（不变的field也要加入将要更新的document中）"><a href="#5-完全更新所有字段（不变的field也要加入将要更新的document中）" class="headerlink" title="5. 完全更新所有字段（不变的field也要加入将要更新的document中）"></a>5. 完全更新所有字段（不变的field也要加入将要更新的document中）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static void fullUpdateDocumentNameByItemId(IndexWriter writer, String itemId, String newName, String oldColor) throws IOException &#123;</span><br><span class="line">Document doc = new Document();</span><br><span class="line">doc.add(new StringField(&quot;name&quot;, newName, Field.Store.YES));</span><br><span class="line">doc.add(new StringField(&quot;item_id&quot;, itemId, Field.Store.YES));</span><br><span class="line">doc.add(new StringField(&quot;color&quot;, oldColor, Field.Store.YES));</span><br><span class="line"></span><br><span class="line">Term mainTerm = new Term(&quot;item_id&quot;, itemId);</span><br><span class="line">writer.updateDocument(mainTerm, doc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-验证完全更新"><a href="#6-验证完全更新" class="headerlink" title="6. 验证完全更新"></a>6. 验证完全更新</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">fullUpdateDocumentNameByItemId(indexWriter, &quot;1&quot;, &quot;item1_updated&quot;, &quot;red&quot;);</span><br><span class="line">fullUpdateDocumentNameByItemId(indexWriter, &quot;2&quot;, &quot;item2_updated&quot;, &quot;blue&quot;);</span><br><span class="line"></span><br><span class="line">indexWriter.commit();</span><br><span class="line">indexWriter.flush();</span><br><span class="line"></span><br><span class="line">indexReader = DirectoryReader.open(readDirectory);</span><br><span class="line">indexSearcher = new IndexSearcher(indexReader);</span><br><span class="line">getDocumentById(indexSearcher, &quot;1&quot;);</span><br><span class="line"></span><br><span class="line">indexReader = DirectoryReader.open(readDirectory);</span><br><span class="line">indexSearcher = new IndexSearcher(indexReader);</span><br><span class="line">getDocumentById(indexSearcher, &quot;2&quot;);</span><br><span class="line"></span><br><span class="line">// output</span><br><span class="line">//  name: item1_updated</span><br><span class="line">//  item_id: 1</span><br><span class="line">//  color: red</span><br><span class="line">//  name: item2_updated</span><br><span class="line">//  item_id: 2</span><br><span class="line">//  color: blue</span><br></pre></td></tr></table></figure><h4 id="7-删除文档"><a href="#7-删除文档" class="headerlink" title="7. 删除文档"></a>7. 删除文档</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static void deleteDocument(IndexWriter writer, String itemId) throws IOException &#123;</span><br><span class="line">    Term mainTerm = new Term(&quot;item_id&quot;, itemId);</span><br><span class="line">    writer.deleteDocuments(mainTerm);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-验证删除文档"><a href="#8-验证删除文档" class="headerlink" title="8. 验证删除文档"></a>8. 验证删除文档</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">getDocumentById(indexSearcher, &quot;1&quot;);</span><br><span class="line">getDocumentById(indexSearcher, &quot;2&quot;);</span><br><span class="line"></span><br><span class="line">// cannot found 1</span><br><span class="line">// cannot found 2</span><br></pre></td></tr></table></figure><p>结论： </p><ol><li>必须将原始文档的所有字段全部获取到再用updateDocument的方式更新，才能实现我们预期中部分更新字段的目的，可以看到成本还是比较高的</li><li>由于Lucene的这种机制也导致了，ES的CRUD模型中需要实现一些额外的机制才能使用到Lucene的能力</li></ol><h3 id="ES中的操作"><a href="#ES中的操作" class="headerlink" title="ES中的操作"></a>ES中的操作</h3><h4 id="ES-mapping"><a href="#ES-mapping" class="headerlink" title="ES mapping"></a>ES mapping</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">PUT /my_index</span><br><span class="line">&#123;</span><br><span class="line">  &quot;mappings&quot;: &#123;</span><br><span class="line">    &quot;properties&quot;: &#123;</span><br><span class="line">      &quot;item_id&quot;: &#123;</span><br><span class="line">        &quot;type&quot;: &quot;keyword&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;name&quot;: &#123;</span><br><span class="line">        &quot;type&quot;: &quot;keyword&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;color&quot;: &#123;</span><br><span class="line">        &quot;type&quot;: &quot;keyword&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-创建文档-1"><a href="#1-创建文档-1" class="headerlink" title="1. 创建文档"></a>1. 创建文档</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">PUT my_index/_doc/1</span><br><span class="line">&#123;</span><br><span class="line">  &quot;item_id&quot;: &quot;1&quot;,</span><br><span class="line">  &quot;name&quot;:&quot;item1&quot;,</span><br><span class="line">  &quot;color&quot;: &quot;red&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT my_index/_doc/2</span><br><span class="line">&#123;</span><br><span class="line">  &quot;item_id&quot;: &quot;2&quot;,</span><br><span class="line">  &quot;name&quot;:&quot;item2&quot;,</span><br><span class="line">  &quot;color&quot;: &quot;blue&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-获取文档"><a href="#2-获取文档" class="headerlink" title="2. 获取文档"></a>2. 获取文档</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">GET my_index/_search</span><br><span class="line">// output</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">&quot;hits&quot;: [</span><br><span class="line">&#123;</span><br><span class="line">&quot;_index&quot;: &quot;my_index&quot;,</span><br><span class="line">&quot;_id&quot;: &quot;1&quot;,</span><br><span class="line">&quot;_score&quot;: 1,</span><br><span class="line">&quot;_source&quot;: &#123;</span><br><span class="line">&quot;item_id&quot;: &quot;1&quot;,</span><br><span class="line">&quot;name&quot;: &quot;item1&quot;,</span><br><span class="line">&quot;color&quot;: &quot;red&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">&quot;_index&quot;: &quot;my_index&quot;,</span><br><span class="line">&quot;_id&quot;: &quot;2&quot;,</span><br><span class="line">&quot;_score&quot;: 1,</span><br><span class="line">&quot;_source&quot;: &#123;</span><br><span class="line">&quot;item_id&quot;: &quot;2&quot;,</span><br><span class="line">&quot;name&quot;: &quot;item2&quot;,</span><br><span class="line">&quot;color&quot;: &quot;blue&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-部分更新"><a href="#3-部分更新" class="headerlink" title="3.部分更新"></a>3.部分更新</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">POST my_index/_update/1</span><br><span class="line">&#123;</span><br><span class="line">  &quot;doc&quot;: &#123;</span><br><span class="line">    &quot;name&quot;: &quot;item1_updated&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">POST my_index/_update/2</span><br><span class="line">&#123;</span><br><span class="line">  &quot;doc&quot;: &#123;</span><br><span class="line">    &quot;name&quot;: &quot;item2_updated&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-获取部分更新后的文档"><a href="#4-获取部分更新后的文档" class="headerlink" title="4.获取部分更新后的文档"></a>4.获取部分更新后的文档</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">GET my_index/_search</span><br><span class="line">// output</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">&quot;hits&quot;: [</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;_index&quot;: &quot;my_index&quot;,</span><br><span class="line">        &quot;_id&quot;: &quot;1&quot;,</span><br><span class="line">        &quot;_score&quot;: 1,</span><br><span class="line">        &quot;_source&quot;: &#123;</span><br><span class="line">          &quot;item_id&quot;: &quot;1&quot;,</span><br><span class="line">          &quot;name&quot;: &quot;item1_updated&quot;,</span><br><span class="line">          &quot;color&quot;: &quot;red&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;_index&quot;: &quot;my_index&quot;,</span><br><span class="line">        &quot;_id&quot;: &quot;2&quot;,</span><br><span class="line">        &quot;_score&quot;: 1,</span><br><span class="line">        &quot;_source&quot;: &#123;</span><br><span class="line">          &quot;item_id&quot;: &quot;2&quot;,</span><br><span class="line">          &quot;name&quot;: &quot;item2_updated&quot;,</span><br><span class="line">          &quot;color&quot;: &quot;blue&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明: 可以看ES中部分更新是可以正常的工作的, 原因就在于ES在处理update的时候会自动拉取原始文档的所有字段和新的更新的字段组合成一份完整的新的全量字段的文档，再去更新Lucene</p><h4 id="5-完整更新所有字段"><a href="#5-完整更新所有字段" class="headerlink" title="5. 完整更新所有字段"></a>5. 完整更新所有字段</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 方式一</span><br><span class="line">POST my_index/_update/1</span><br><span class="line">&#123;</span><br><span class="line">  &quot;doc&quot;: &#123;</span><br><span class="line">    &quot;name&quot;: &quot;item1_updated&quot;,</span><br><span class="line">    &quot;item_id&quot;: &quot;1&quot;,</span><br><span class="line">    &quot;color&quot;: &quot;red&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 方式二</span><br><span class="line">PUT my_index/_doc/1</span><br><span class="line">&#123;</span><br><span class="line">  &quot;item_id&quot;: &quot;1&quot;,</span><br><span class="line">  &quot;name&quot;:&quot;item1_update_by_put&quot;,</span><br><span class="line">  &quot;color&quot;: &quot;red&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-验证完全更新-1"><a href="#6-验证完全更新-1" class="headerlink" title="6. 验证完全更新"></a>6. 验证完全更新</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">GET my_index/_search</span><br><span class="line">// output</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line"> &quot;hits&quot;: [</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;_index&quot;: &quot;my_index&quot;,</span><br><span class="line">        &quot;_id&quot;: &quot;1&quot;,</span><br><span class="line">        &quot;_score&quot;: 1,</span><br><span class="line">        &quot;_source&quot;: &#123;</span><br><span class="line">          &quot;item_id&quot;: &quot;1&quot;,</span><br><span class="line">          &quot;name&quot;: &quot;item1_update_by_put&quot;,</span><br><span class="line">          &quot;color&quot;: &quot;red&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;_index&quot;: &quot;my_index&quot;,</span><br><span class="line">        &quot;_id&quot;: &quot;2&quot;,</span><br><span class="line">        &quot;_score&quot;: 1,</span><br><span class="line">        &quot;_source&quot;: &#123;</span><br><span class="line">          &quot;item_id&quot;: &quot;2&quot;,</span><br><span class="line">          &quot;name&quot;: &quot;item2_updated&quot;,</span><br><span class="line">          &quot;color&quot;: &quot;blue&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-删除文档-1"><a href="#7-删除文档-1" class="headerlink" title="7. 删除文档"></a>7. 删除文档</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DELETE my_index/_doc/1</span><br><span class="line">DELETE my_index/_doc/2</span><br></pre></td></tr></table></figure><h4 id="8-验证删除文档-1"><a href="#8-验证删除文档-1" class="headerlink" title="8. 验证删除文档"></a>8. 验证删除文档</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET my_index/_search</span><br><span class="line"></span><br><span class="line">// output</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">&quot;hits&quot;: []</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="ES如何在Lucene的基础上实现基于主键-id-的删改"><a href="#ES如何在Lucene的基础上实现基于主键-id-的删改" class="headerlink" title="ES如何在Lucene的基础上实现基于主键(_id)的删改"></a>ES如何在Lucene的基础上实现基于主键(_id)的删改</h3><ol><li>ES 使用<code>_id</code>的内部字段作为文档的主键，这个<code>_id</code>可以用户指定，上面的例子中item_id就是对应了<code>_id</code>，Lucene中没有主键的概念，所以需要使用_id 作为一个独特的Term的维持文档的唯一性, 后续的更新, 删除也是和<code>_id</code>对应的Term绑定. Lucene的创建操作不具备幂等性（addDocument）指定了Term之后，这个Term下可以关联N个document，不具备唯一性.</li><li>ES 在部分字段的更新中，自己封装了一层获取原始文档的操作，之后使用update的方式更新Lucene.</li><li>ES 在删除文档操作中，使用<code>_id</code>对应的Term 去调用Lucene的API.</li><li>ES 在创建文档操作中，PUT 相同<code>_id</code>的文档 同样能保持唯一性, 通常情况下ES也是用Lucene update的方式实现创建的请求.</li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li>Lucene整体是一个Append Only的存储引擎，且没有主键的概念.</li><li>ES 本身封装了一系列的操作使得整个CRUD操作更加方便使用，这也不可避免的带了一些额外的开销，通过理解这些操作的底层原理，有助于我们做出一些最佳实践的选择.</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> ES, Lucene, elasticsearch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang 中[]byte, string和[]rune的相互转化的底层原理和剖析</title>
      <link href="/2021/02/21/golang_slice/"/>
      <url>/2021/02/21/golang_slice/</url>
      
        <content type="html"><![CDATA[<h1 id="Golang-中-byte-string和-rune的相互转化的底层原理和剖析"><a href="#Golang-中-byte-string和-rune的相互转化的底层原理和剖析" class="headerlink" title="Golang 中[]byte, string和[]rune的相互转化的底层原理和剖析"></a>Golang 中<code>[]byte</code>, <code>string</code>和<code>[]rune</code>的相互转化的底层原理和剖析</h1><p>在golang中有些场景经常会用到[]byte和string的相互转化，尤其是在使用json.Marshal和json.Unmarshal的时候，经常会遇到需要这种转化。</p><p>本文主要说明以下内容：</p><ul><li>几种类型相互转化的方法和性能分析</li><li>这些类型的底层存储</li><li>代码<a href="https://gist.github.com/skyitachi/f8f22a390f547466216b0a4084b98bee">gist</a></li></ul><h2 id="相互转化"><a href="#相互转化" class="headerlink" title="相互转化"></a>相互转化</h2><h3 id="byte和string的相互转化"><a href="#byte和string的相互转化" class="headerlink" title="[]byte和string的相互转化"></a>[]byte和string的相互转化</h3><h4 id="string-byte"><a href="#string-byte" class="headerlink" title="string -&gt; []byte"></a>string -&gt; []byte</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkStringToByteSlice</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">s := genString(<span class="number">10000</span>)</span><br><span class="line">b.ReportAllocs()</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">bs := []<span class="type">byte</span>(s)</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(bs) != <span class="built_in">len</span>(s) &#123;</span><br><span class="line">b.Error(<span class="string">&quot;error&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkStringToByteSliceUnsafe</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">s := genString(<span class="number">10000</span>)</span><br><span class="line">b.ReportAllocs()</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">l := <span class="built_in">len</span>(s)</span><br><span class="line">bs := *(*[]<span class="type">byte</span>)(unsafe.Pointer(&amp;reflect.SliceHeader&#123;</span><br><span class="line">Data: (*(*reflect.StringHeader)(unsafe.Pointer(&amp;s))).Data,</span><br><span class="line">Len:  l,</span><br><span class="line">Cap:  l,</span><br><span class="line">&#125;))</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(bs) != <span class="built_in">len</span>(s) &#123;</span><br><span class="line">b.Error(<span class="string">&quot;error&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一种使用[]byte这种直接转化，也是我们常用的方式，第二种是使用unsafe的方式。这两种区别就在于一个是重新分配了内存，另一个是复用了原来的内存。</p><p>benchmark的结果也验证了这一点</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">go test  -run=BenchmarkStringToByteSlice -bench=StringToByteSlice</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">go-demo.test</span></span><br><span class="line"></span><br><span class="line">goos: darwin</span><br><span class="line">goarch: amd64</span><br><span class="line">pkg: go-demo</span><br><span class="line">BenchmarkStringToByteSlice-12           1164224       964 ns/op   10285 B/op       1 allocs/op</span><br><span class="line">BenchmarkStringToByteSliceUnsafe-12    1000000000         0.380 ns/op       0 B/op       0 allocs/op</span><br><span class="line">PASS</span><br><span class="line">ok  go-demo2.089s</span><br></pre></td></tr></table></figure><h4 id="byte-string"><a href="#byte-string" class="headerlink" title="[]byte -&gt; string"></a>[]byte -&gt; string</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkSliceByteToString</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">bs := genSliceByte(<span class="number">100</span>)</span><br><span class="line">b.ReportAllocs()</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">s := <span class="type">string</span>(bs)</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(s) != <span class="built_in">len</span>(bs) &#123;</span><br><span class="line">b.Error(<span class="string">&quot;error&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkSliceByteToStringUnsafe</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">bs := genSliceByte(<span class="number">100</span>)</span><br><span class="line">b.ReportAllocs()</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">s := *(*<span class="type">string</span>)(unsafe.Pointer(&amp;bs))</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(s) != <span class="built_in">len</span>(bs) &#123;</span><br><span class="line">b.Log(<span class="string">&quot;slice: &quot;</span>, <span class="built_in">len</span>(bs), <span class="string">&quot; string: &quot;</span>, <span class="built_in">len</span>(s))</span><br><span class="line">b.Error(<span class="string">&quot;error: &quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>benchmark 结果</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">go test  -run=BenchmarkSliceByteToString -bench=SliceByteToString</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">go-demo.test</span></span><br><span class="line"></span><br><span class="line">goos: darwin</span><br><span class="line">goarch: amd64</span><br><span class="line">pkg: go-demo</span><br><span class="line">BenchmarkSliceByteToString-12          35913873        32.4 ns/op     112 B/op       1 allocs/op</span><br><span class="line">BenchmarkSliceByteToStringUnsafe-12    1000000000         0.253 ns/op       0 B/op       0 allocs/op</span><br><span class="line">PASS</span><br><span class="line">ok  go-demo3.796s</span><br></pre></td></tr></table></figure><h3 id="string和-rune的相互转化"><a href="#string和-rune的相互转化" class="headerlink" title="string和[]rune的相互转化"></a>string和[]rune的相互转化</h3><p>string和rune的相互转化其实和上面类似，主要是[]rune对应的[]byte数组长度需要计算下，这里就只贴一个[]rune到string的转化了</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkSliceRuneToStringUnsafe</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">bs := genSliceRune(<span class="number">100</span>)</span><br><span class="line">s1 := <span class="type">string</span>(bs)</span><br><span class="line">b.ReportAllocs()</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line"><span class="keyword">var</span> l <span class="type">int</span></span><br><span class="line"><span class="keyword">for</span> _, r := <span class="keyword">range</span> bs &#123;</span><br><span class="line">l += utf8.RuneLen(r)</span><br><span class="line">&#125;</span><br><span class="line">s := *(*<span class="type">string</span>)(unsafe.Pointer(&amp;reflect.StringHeader&#123;</span><br><span class="line">Data: (*(*reflect.SliceHeader)(unsafe.Pointer(&amp;bs))).Data,</span><br><span class="line">Len:  l,</span><br><span class="line">&#125;))</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(s1) != <span class="built_in">len</span>(s) &#123;</span><br><span class="line">b.Error(<span class="string">&quot;error&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="String和Slice的底层存储分析"><a href="#String和Slice的底层存储分析" class="headerlink" title="String和Slice的底层存储分析"></a>String和Slice的底层存储分析</h2><h4 id="reflect-SliceHeader-和reflect-StringHeader"><a href="#reflect-SliceHeader-和reflect-StringHeader" class="headerlink" title="reflect.SliceHeader 和reflect.StringHeader"></a>reflect.SliceHeader 和reflect.StringHeader</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> StringHeader <span class="keyword">struct</span> &#123;</span><br><span class="line">Data <span class="type">uintptr</span></span><br><span class="line">Len  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> SliceHeader <span class="keyword">struct</span> &#123;</span><br><span class="line">Data <span class="type">uintptr</span></span><br><span class="line">Len  <span class="type">int</span></span><br><span class="line">Cap  <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两者类型基本一样，Slice多了一个Cap，其实这也决定了[]byte可以直接使用指针强转成string，但是反过来却不行</p><h4 id="slice的底层存储"><a href="#slice的底层存储" class="headerlink" title="slice的底层存储"></a>slice的底层存储</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> slice <span class="keyword">struct</span> &#123;</span><br><span class="line">array unsafe.Pointer</span><br><span class="line"><span class="built_in">len</span>   <span class="type">int</span></span><br><span class="line"><span class="built_in">cap</span>   <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="以汇编的形式看下slice的底层结构"><a href="#以汇编的形式看下slice的底层结构" class="headerlink" title="以汇编的形式看下slice的底层结构"></a>以汇编的形式看下slice的底层结构</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> pkg</span><br><span class="line"></span><br><span class="line"><span class="comment">// var data = make([]int, 0, 10)</span></span><br><span class="line"><span class="keyword">var</span> data = []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">go tool compile -S pkg.go</span><br><span class="line">go.cuinfo.packagename. SDWARFINFO dupok size=0</span><br><span class="line">0x0000 70 6b 67                                         pkg</span><br><span class="line">&quot;&quot;.data SDATA size=24</span><br><span class="line">0x0000 00 00 00 00 00 00 00 00 02 00 00 00 00 00 00 00  ................</span><br><span class="line">0x0010 02 00 00 00 00 00 00 00                          ........</span><br><span class="line">rel 0+8 t=1 &quot;&quot;..stmp_0+0</span><br><span class="line">&quot;&quot;..stmp_0 SNOPTRDATA size=16</span><br><span class="line">0x0000 01 00 00 00 00 00 00 00 02 00 00 00 00 00 00 00  ................</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>可以看到””.data 对应的是size是24（8byte的指针，len和cap各自8byte），slice里的内容是两个int对应的就是，””.stmp_0 里的内容</p><p>进一步分析data对应的二进制</p><ul><li>data+8是<code>02 00 ...</code> ，对应len</li><li>data+16是<code>02 00</code> 对应cap</li></ul><p>整个slice struct在内存里是紧凑分布的，所以我们可以进行指针类的强制转化，类似于c++中<code>reinterpret_cast</code></p><h5 id="string的底层结构"><a href="#string的底层结构" class="headerlink" title="string的底层结构"></a>string的底层结构</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> pkg</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> testStr = <span class="string">&quot;abc&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">go.cuinfo.packagename. SDWARFINFO dupok size=0</span><br><span class="line">0x0000 70 6b 67                                         pkg</span><br><span class="line">go.string.&quot;abc&quot; SRODATA dupok size=3</span><br><span class="line">0x0000 61 62 63                                         abc</span><br><span class="line">&quot;&quot;.testStr SDATA size=16</span><br><span class="line">0x0000 00 00 00 00 00 00 00 00 03 00 00 00 00 00 00 00  ................</span><br><span class="line">rel 0+8 t=1 go.string.&quot;abc&quot;+0</span><br></pre></td></tr></table></figure><p>和上文的slice很类似，size变成了16而已</p><h4 id="Fat-Pointer"><a href="#Fat-Pointer" class="headerlink" title="Fat Pointer"></a>Fat Pointer</h4><p>像slice这种结构在c中常被称为fatpointer，感兴趣的同学可以参考<a href="https://nullprogram.com/blog/2019/06/30/">Go Slices are Fat Pointers</a></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>介绍了golang中string，[]byte和[]rune的转化及简单的性能分析</li><li>slice在golang中的底层存储</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> golang slice </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二分法的两种实现</title>
      <link href="/2020/04/14/%E4%BA%8C%E5%88%86%E6%B3%95%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%AE%9E%E7%8E%B0/"/>
      <url>/2020/04/14/%E4%BA%8C%E5%88%86%E6%B3%95%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>虽然二分搜索很简单（在无重复的有序数组上）,但是也有很多值得注意的地方，而且有两种完全不同的写法（两种完全不同的功能）</p><h4 id="lower-bound"><a href="#lower-bound" class="headerlink" title="lower bound"></a>lower bound</h4><blockquote><p>找出大于等于target的最小数组下标, 不存在的情况下返回-1</p></blockquote><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lower_bound</span><span class="params">(a []<span class="type">int</span>, target <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">  l := <span class="number">0</span></span><br><span class="line">  h := <span class="built_in">len</span>(a) - <span class="number">1</span></span><br><span class="line">  <span class="keyword">for</span> l &lt; h &#123;</span><br><span class="line">    m := l + (h - l) / <span class="number">2</span></span><br><span class="line">    <span class="keyword">if</span> a[m] &gt;= target &#123;</span><br><span class="line">      h = m</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// l肯定可以取到h值，所以不需要使用向上取整计算m值</span></span><br><span class="line">      l += <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> a[l] &gt;= target &#123;</span><br><span class="line">    <span class="keyword">return</span> l</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="upper-bound"><a href="#upper-bound" class="headerlink" title="upper bound"></a>upper bound</h4><blockquote><p>找出小于等于target的最大数组下标</p></blockquote><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">upper_bound</span><span class="params">(a []<span class="type">int</span>, target <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">  l := <span class="number">0</span></span><br><span class="line">h := <span class="built_in">len</span>(a) - <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> l &lt; h &#123;</span><br><span class="line">m := l + (h - l + <span class="number">1</span>) / <span class="number">2</span></span><br><span class="line"><span class="keyword">if</span> a[m] &lt;= target &#123;</span><br><span class="line">      <span class="comment">// l 要能够取到h值，就必须保证m使用向上取整计算, (h - l + 1) / 2 就是这么来的</span></span><br><span class="line">l = m</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">h = m - <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> a[l] &lt;= target &#123;</span><br><span class="line"><span class="keyword">return</span> l</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h4><ul><li>计算mid的时候不能发生溢出</li><li>数组下标不能越界</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>dubbo-go support protobuf</title>
      <link href="/2019/12/30/dubbo-go-protobuf-support/"/>
      <url>/2019/12/30/dubbo-go-protobuf-support/</url>
      
        <content type="html"><![CDATA[<h4 id="主要用法"><a href="#主要用法" class="headerlink" title="主要用法"></a>主要用法</h4><ul><li>和grpc中使用protobuf生成代码基本一致（至少在形式上）,直接看例子吧</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">├── go-client</span><br><span class="line">│   ├── client.go</span><br><span class="line">│   ├── client.yml</span><br><span class="line">├── go-server</span><br><span class="line">│   ├── main.go</span><br><span class="line">│   └── server.yml</span><br><span class="line">└── user</span><br><span class="line">    ├── user.pb.go</span><br><span class="line">    └── user.proto</span><br></pre></td></tr></table></figure><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> user;</span><br><span class="line"></span><br><span class="line"><span class="keyword">service </span><span class="title class_">UserProvider</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">rpc</span> GetUser (UserRequest) <span class="keyword">returns</span> (UserReply) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">UserRequest</span> &#123;</span><br><span class="line">  <span class="type">string</span> id = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">UserReply</span> &#123;</span><br><span class="line">  <span class="type">string</span> id = <span class="number">1</span>;</span><br><span class="line">  <span class="type">string</span> name = <span class="number">2</span>;</span><br><span class="line">  <span class="type">int32</span> age = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用protoc-gen-dubbogo插件生成dubbogo的代理</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protoc --plugin=&#123;plugin_path&#125; --dubbogo_out=plugins=dubbogo:. user/user.proto</span><br></pre></td></tr></table></figure><ul><li>client关键代码</li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">user := user.NewUserProvider()</span><br><span class="line">reply := user.UserReply&#123;&#125;</span><br><span class="line">err := userProvider.GetUser(context.TODO(), &amp;user.UserRequest&#123;Id: <span class="string">&quot;A001&quot;</span>&#125;, &amp;reply)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">  log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;response result: %+v&quot;</span>, reply)</span><br></pre></td></tr></table></figure><p>ps: 一切都是熟悉的味道<br>ps: 生成代理的名称需要和reference里配置的一样</p><ul><li>server关键代码</li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> UserProvider <span class="keyword">struct</span> &#123;</span><br><span class="line">pb.UnimplementedUserProviderServer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*UserProvider)</span></span> GetUser(ctx context.Context, user *pb.UserRequest) (*pb.UserReply, <span class="type">error</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> &amp;pb.UserReply&#123;Id: <span class="string">&quot;001&quot;</span>, Name: <span class="string">&quot;alice&quot;</span>, Age: <span class="number">18</span>&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册</span></span><br><span class="line">pb.RegisterProvider(<span class="built_in">new</span>(UserProvider))</span><br></pre></td></tr></table></figure><h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><ul><li>在dubbogo抽出一层serialization，任何和serialization相关的之后只要实现Serialize接口就行了，这样是为了更好的实现更多序列化的支持，逻辑上会更合理一些，原有的go hessian2中做了一部分dubbo相关的codec工作，这里我也把它抽到dubbogo中了， 当然hessian2的序列化仍然保留了，这次实现是兼容老版本的。</li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Serializer <span class="keyword">interface</span> &#123;</span><br><span class="line">Marshal(p DubboPackage) ([]<span class="type">byte</span>, <span class="type">error</span>)</span><br><span class="line">Unmarshal([]<span class="type">byte</span>, *DubboPackage) <span class="type">error</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>参考了dubbo的protobuf实现，实现了在protobuf层面和java互通（不一定是好事:(）</li><li>其他的就是细节了</li></ul><h4 id="一些注意点"><a href="#一些注意点" class="headerlink" title="一些注意点"></a>一些注意点</h4><ul><li><code>error</code>的处理和java不太一样，java会把详细的java error stack都返回给客户端，go只会把message传过来，生成一个error</li><li>由于java protobuf生成的代理方法名是小写开头(完全搞不明白是为什么)，这在golang中表示私有方法，个人已经提了<a href="https://github.com/apache/dubbo/issues/5536">issue</a>, 所以直接用java的例子是不行的</li><li>java protobuf的代理生成的是内部接口，比如xxx$IDemoService, <code>$</code>是url中的一个特殊字符，正好发现了dubbogo的一个注册url的bug</li></ul><h4 id="我为什么要支持protobuf"><a href="#我为什么要支持protobuf" class="headerlink" title="我为什么要支持protobuf"></a>我为什么要支持protobuf</h4><ul><li>protobuf的语言中立性更好，序列化性能也更好</li><li>更加符合golang的生态</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> dubbo, go, protobuf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++中的传参</title>
      <link href="/2019/08/21/passing-value-in-cpp/"/>
      <url>/2019/08/21/passing-value-in-cpp/</url>
      
        <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>最近在用c++写基于libuv的websocket engine的时候发现, 设置callback的参数是一个很有挑战性的工作, 原来觉得c++的复杂在于其模板，oo范式概念的复杂, 现在发现c++的每个方面都很复杂，因为有太多可以通过编译的方式了，我想从传参这个方面切入，让大家了解下c++的复杂（强大）。</p><p>ps：本文的传参使基于涉及到动态内存分配对象的传参，一般普通对象的传参基本是不需要考虑这么复杂的(至少我目前这么认为)。</p><p>以下是本文中需要传递的参数，一个简单的String, 只保留会讲到的构造函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">String</span>: &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">String</span>(<span class="type">const</span> <span class="type">char</span>* src): <span class="built_in">data_</span>(<span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(src) + <span class="number">1</span>]), <span class="built_in">size_</span>(<span class="built_in">strlen</span>(src)) &#123;</span><br><span class="line">      ::<span class="built_in">strcpy</span>(data_, src);</span><br><span class="line">      data_[size_] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">String</span>(<span class="type">const</span> String&amp; lhs): <span class="built_in">data_</span>(<span class="keyword">new</span> <span class="type">char</span>[lhs.<span class="built_in">size</span>() + <span class="number">1</span>]), <span class="built_in">size_</span>(lhs.<span class="built_in">size</span>()) &#123;</span><br><span class="line">      ::<span class="built_in">strcpy</span>(data_, lhs.<span class="built_in">data</span>());</span><br><span class="line">      data_[size_] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// move</span></span><br><span class="line">    <span class="built_in">String</span>(String &amp;&amp;rhs) <span class="keyword">noexcept</span>: <span class="built_in">data_</span>(rhs.data_), <span class="built_in">size_</span>(rhs.size_) &#123;</span><br><span class="line">      rhs.data_ = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我遇到的一个问题是在MessageCallback中，应该使用<code>const String&amp; message</code>还是<code>String&amp;&amp; message</code>, 这两种形参的区别是什么</p><h5 id="理解std-move-和右值引用"><a href="#理解std-move-和右值引用" class="headerlink" title="理解std::move 和右值引用"></a>理解<code>std::move</code> 和<code>右值引用</code></h5><p>在弄清上述问题之前，还是要从根本上着手，弄清<code>std::move</code>和右值引用。<br>右值引用是c++11中引入的一种新的引用类型，必须要绑定到右值的引用。<br>而std::move的作用是可以把几乎任意值转化成一个右值引用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_passing_value</span><span class="params">(std::string&amp; s1)</span> </span>&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;in the left reference&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_passing_value</span><span class="params">(std::string&amp;&amp; s1)</span> </span>&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;in the right reference&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::string s1 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">std::string &amp;sr = s1;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test_passing_value</span>(s1); <span class="comment">// in the left</span></span><br><span class="line"><span class="built_in">test_passing_value</span>(std::<span class="built_in">move</span>(s1)); <span class="comment">// in the right</span></span><br><span class="line"><span class="built_in">test_passing_value</span>(sr); <span class="comment">// in the left</span></span><br><span class="line"><span class="built_in">test_passing_value</span>(std::<span class="built_in">move</span>(sr)); <span class="comment">// in the right</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以看到无论是左值，还是左值引用，使用std::move之后都可以变成右值引用</span></span><br><span class="line"><span class="comment">// 意外的情况就是const T&amp; 在使用std::move转化时的特殊情况</span></span><br></pre></td></tr></table></figure><h5 id="const-T-vs-T"><a href="#const-T-vs-T" class="headerlink" title="const T&amp; vs T&amp;&amp;"></a><code>const T&amp;</code> vs <code>T&amp;&amp;</code></h5><p>c++11中引入了右值引用和move语义，初学者（比如我）很容易被这种特性吸引（move比copy快）, 两者其实是解决不同场景下的问题，T&amp;&amp; 的确提供了一种更为高效的传参方式, 让我们看下两者的细节和使用场景吧。</p><ul><li><p>仅仅使用<code>const T&amp;</code>并不会发生copy</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">const</span> String&amp; s)</span> </span>&#123;</span><br><span class="line">  std::cout &lt;&lt; s &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">String <span class="title">s0</span><span class="params">(<span class="string">&quot;hello&quot;</span>)</span></span>;</span><br><span class="line">  <span class="built_in">foo</span>(s0); <span class="comment">// 不会发生复制</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>const T&amp;</code> 发生复制的情况是在函数体内用到T的local variable， 比如<code>T local = t</code>, 这时候会发生拷贝控制</p></li><li><p>仅仅使用<code>T&amp;&amp;</code>不会发生move</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f2</span><span class="params">(String &amp;&amp;s2)</span> </span>&#123;</span><br><span class="line">  std::cout &lt;&lt; s2 &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">f2</span>(<span class="built_in">String</span>(<span class="string">&quot;hello&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从以上两种情况来看似乎传参的代价都很低，那么应该如何选择呢，主要还是根据语义来做选择，如果你的实参是个左值自然选择第一种，如果是右值那自然是后者，如果你确定需要第二种那么使用<code>std::move</code>也是可以的</p></li></ul><h5 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h5><ul><li>由于我在传给callback的string是从buffer中复制构造来的，而不是仅仅像stringpiece那样使用，所以使用右值引用更合适，使用者会放心大胆的使用这个string，move之类的更不在话下了</li></ul><h5 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h5><ul><li>可以考虑使用StringPiece类似的技术，不过我感觉StringPiece在这个场景下并不好</li><li>关于std::move的原理其中涉及到了引用折叠这些比较复杂的概念，所以没有深入介绍</li><li>在模板中使用T&amp;&amp; 和实参中的&amp;&amp;还是不一样的，模板中的T&amp;&amp; 在转发参数时要保证不丢失T的信息(T可能是引用) 所以有涉及到了完美转发的概念，std::forward可以解决这个问题</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈 javascript 作用域</title>
      <link href="/2017/04/24/scope/"/>
      <url>/2017/04/24/scope/</url>
      
        <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><ul><li>本文将主要介绍javascript中作用域相关的问题，尽可能多的使用代码举例说明，尽量少涉及动态作用域相关</li></ul><h4 id="词法作用域-核心"><a href="#词法作用域-核心" class="headerlink" title="词法作用域(核心)"></a>词法作用域(核心)</h4><blockquote><p>javascript的作用域是词法作用域（静态作用域）, 不过像<code>eval</code>，<code>with</code>这些具有动态改变作用域的能力, 本文重点在于词法作用域</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">testLexicalScope</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// 由于当前scope中a是由最外层定义的，所以此处的a只能访问到最外层的a</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">b</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">2</span>;</span><br><span class="line">  <span class="title function_">testLexicalScope</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">b</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 另一个例子</span></span><br><span class="line"><span class="keyword">let</span> sameVar1 = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> sameVar2 = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">outerScope</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> sameVar1 = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">innerScope</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;current scope: sameVar1 is &quot;</span>, sameVar1); <span class="comment">// 当前的scope中最近的sameVar1值是2</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;current scope: sameVar2 is &quot;</span>, sameVar2);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">innerScope</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">outerScope</span>();</span><br><span class="line"><span class="comment">// current scope: sameVar1 is  2</span></span><br><span class="line"><span class="comment">// current scope: sameVar2 is  1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//另一个例子</span></span><br><span class="line"><span class="keyword">const</span> f1 = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(outVar);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> outVar = <span class="number">1</span>;</span><br><span class="line"><span class="title function_">f1</span>(); <span class="comment">// 1 why</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>只有在函数声明的时候才会遵循lexical scope的规则, 如果是函数表达式则取决于调用的时机</p></blockquote><h4 id="不同类型的作用域-如何创建scope"><a href="#不同类型的作用域-如何创建scope" class="headerlink" title="不同类型的作用域(如何创建scope)"></a>不同类型的作用域(如何创建scope)</h4><ul><li>函数作用域</li></ul><blockquote><p>属于这个函数的全部变量都可以在整个函数的范围内使用及复用<br>javascript 每个函数都会创建一个scope</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fScope</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> aStr = <span class="string">&quot;function&quot;</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(aStr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">fScope</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(aStr); <span class="comment">// ReferenceError: aStr is not defined</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>块级作用域({…})</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="literal">true</span>;</span><br><span class="line">&#123; <span class="comment">// 这里是使用let，将foo绑定到了&#123;&#125;这个块作用域中</span></span><br><span class="line">  <span class="keyword">let</span> foo = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">let</span> bar = <span class="string">&quot;cannot seen&quot;</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(foo); <span class="comment">// false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(bar); <span class="comment">// ReferenceError</span></span><br></pre></td></tr></table></figure><h4 id="var"><a href="#var" class="headerlink" title="var"></a><code>var</code></h4><ul><li>函数作用域中的<code>var</code>仍然遵循函数作用域相关的</li><li><code>var</code>中没有块级作用域</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="literal">true</span>;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">var</span> foo = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">var</span> bar = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo); <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(bar); <span class="comment">// bar</span></span><br></pre></td></tr></table></figure><h4 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h4><blockquote><p>变量和函数的所有声明多会在任何代码被执行前首先被处理（编译器找到这些变量与合适的作用域关联）</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">hoisting</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">hoisting</span>();</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>又是let</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">hoisting</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// 第一个let之上的区域叫做`temporal dead zone`</span></span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">hoisting</span>(); <span class="comment">// ReferenceError</span></span><br></pre></td></tr></table></figure><p><strong>函数声明的优先级会高于变量声明</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">foo</span>(); <span class="comment">// in the function</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;in the function&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li>关于块级作用域, 可用try{} catch(err) {&#x2F;<em>这里是块级作用域</em>&#x2F;}模拟，更多参考:《你不知道的javascript》上卷中3.4.2节</li><li>使用<code>let</code>，<code>const</code>是最佳实践</li><li>需要区分函数声明和函数表达式</li><li>尽量不要写有提升的代码（声明尽量提前）</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
