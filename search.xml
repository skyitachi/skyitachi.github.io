<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>ES和Lucene之间的CRUD操作映射</title>
      <link href="/2024/05/11/ES%E5%92%8CLucene%E4%B9%8B%E9%97%B4%E7%9A%84CRUD%E6%93%8D%E4%BD%9C%E6%98%A0%E5%B0%84/"/>
      <url>/2024/05/11/ES%E5%92%8CLucene%E4%B9%8B%E9%97%B4%E7%9A%84CRUD%E6%93%8D%E4%BD%9C%E6%98%A0%E5%B0%84/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在ES中我们经常使用的数据格式json，ES也支持常见的CRUD操作，这里我们主要介绍写入相关的操作（创建，更新，删除），ES的底层存储引擎是Lucene，Lucene也有相关创建更新删除的操作，但是Lucene是没有显示的根据主键更新文档的api的，本文主要介绍的是在ES有_id的情况下，ES是如何基于Lucene实现增删改的操作的，其中的数据模型又是如何映射的.</p><p>ps: 本文不考虑ES中的数据类型到Lucene中的数据类型的映射（Field），所有的代码片段都是基于以下给定的类型映射</p><table><thead><tr><th>Name</th><th>ES type</th><th>Lucene Field</th></tr></thead><tbody><tr><td>item_id</td><td>keyword</td><td>StringField</td></tr><tr><td>name</td><td>keyword</td><td>StringField</td></tr><tr><td>color</td><td>keyword</td><td>StringField</td></tr></tbody></table><h3 id="lucene-如何基于id（主键）部分更新文档-基于lucene-9-7-0"><a href="#lucene-如何基于id（主键）部分更新文档-基于lucene-9-7-0" class="headerlink" title="lucene 如何基于id（主键）部分更新文档 (基于lucene 9.7.0)"></a>lucene 如何基于id（主键）部分更新文档 (基于lucene 9.7.0)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> &lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.apache.lucene&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;lucene-core&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;9.7.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h4 id="1-创建文档"><a href="#1-创建文档" class="headerlink" title="1. 创建文档"></a>1. 创建文档</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public static void createDocuments(IndexWriter indexWriter) throws IOException &#123;</span><br><span class="line">Document doc1 = new Document();</span><br><span class="line">doc1.add(new StringField(&quot;item_id&quot;, &quot;1&quot;, Field.Store.YES ));</span><br><span class="line">doc1.add(new StringField(&quot;name&quot;, &quot;item1&quot;, Field.Store.YES));</span><br><span class="line">doc1.add(new StringField(&quot;color&quot;, &quot;red&quot;, Field.Store.YES));</span><br><span class="line"></span><br><span class="line">Document doc2 = new Document();</span><br><span class="line">doc2.add(new StringField(&quot;item_id&quot;, &quot;2&quot;, Field.Store.YES));</span><br><span class="line">doc2.add(new StringField(&quot;name&quot;, &quot;item2&quot;, Field.Store.YES));</span><br><span class="line">doc2.add(new StringField(&quot;color&quot;, &quot;blue&quot;, Field.Store.YES));</span><br><span class="line"></span><br><span class="line">indexWriter.addDocument(doc1);</span><br><span class="line">indexWriter.addDocument(doc2);</span><br><span class="line"></span><br><span class="line">indexWriter.commit();</span><br><span class="line">indexWriter.flush();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-读取文档验证写入"><a href="#2-读取文档验证写入" class="headerlink" title="2. 读取文档验证写入"></a>2. 读取文档验证写入</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public static void getDocumentById(IndexReader reader, IndexSearcher searcher, String itemId) throws IOException &#123;</span><br><span class="line">Query query = new TermQuery(new Term(&quot;item_id&quot;, itemId));</span><br><span class="line">TopDocs topdocs = searcher.search(query, 10);</span><br><span class="line">assert topdocs.totalHits.value == 1;</span><br><span class="line"></span><br><span class="line">for (ScoreDoc doc: topdocs.scoreDocs) &#123;</span><br><span class="line">int docId = doc.doc;</span><br><span class="line">Document fullDoc = getDocumentByDocId(reader, docId);</span><br><span class="line"></span><br><span class="line">fullDoc.getFields().forEach(field -&gt; &#123;</span><br><span class="line">System.out.println(&quot;  &quot; + field.name() + &quot;: &quot; + field.stringValue());</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// item_id = &quot;1&quot;</span><br><span class="line">getDocumentById(reader, searcher, &quot;1&quot;);</span><br><span class="line">//  item_id: 1</span><br><span class="line">//  name: item1</span><br><span class="line">//  color: red</span><br><span class="line">getDocumentById(reader, searcher, &quot;2&quot;);</span><br><span class="line">//  item_id: 2</span><br><span class="line">//  name: item2</span><br><span class="line">//  color: blue</span><br></pre></td></tr></table></figure><h4 id="3-部分更新文档"><a href="#3-部分更新文档" class="headerlink" title="3. 部分更新文档"></a>3. 部分更新文档</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static void partialUpdateDocumentNameByItemId(IndexWriter writer, String itemId, String newName) throws IOException &#123;</span><br><span class="line">Document doc = new Document();</span><br><span class="line">doc.add(new StringField(&quot;name&quot;, newName, Field.Store.YES));</span><br><span class="line">// important: 这个作为主键的Term一定要带上</span><br><span class="line">doc.add(new StringField(&quot;item_id&quot;, itemId, Field.Store.YES));</span><br><span class="line">Term mainTerm = new Term(&quot;item_id&quot;, itemId);</span><br><span class="line">writer.updateDocument(mainTerm, doc);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="4-验证更新文档"><a href="#4-验证更新文档" class="headerlink" title="4. 验证更新文档"></a>4. 验证更新文档</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">partialUpdateDocumentNameByItemId(indexWriter, &quot;1&quot;, &quot;item1_updated&quot;);</span><br><span class="line">partialUpdateDocumentNameByItemId(indexWriter, &quot;2&quot;, &quot;item2_updated&quot;);</span><br><span class="line">indexWriter.commit();</span><br><span class="line">indexWriter.flush();</span><br><span class="line"></span><br><span class="line">indexReader = DirectoryReader.open(readDirectory);</span><br><span class="line">indexSearcher = new IndexSearcher(indexReader);</span><br><span class="line">getDocumentById(indexSearcher, &quot;1&quot;);</span><br><span class="line"></span><br><span class="line">indexReader = DirectoryReader.open(readDirectory);</span><br><span class="line">indexSearcher = new IndexSearcher(indexReader);</span><br><span class="line">getDocumentById(indexSearcher, &quot;2&quot;);</span><br><span class="line">//</span><br><span class="line">//  name: item1_updated</span><br><span class="line">//  item_id: 1</span><br><span class="line">//  name: item2_updated</span><br><span class="line">//  item_id: 2</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>结论： 由于在partialUpdateDocumentNameByItemId 中只写了item_id和name属性（符合update的直觉），但是可以看出Lucene把updateDocument中的doc对象当成了最新且完整的mainTerm对应的doc，这就导致了虽然我们目的是部分更新，但是会丢失没有写入（没有变化）的那些属性，这个例子也可以看出Lucene本质上是用新文档覆盖旧文档的形式，用一个可以代表主键的Term做关联，来实现部分更新字段的目的，这个和一般RDBMS的存储模型有点区别.</p><h4 id="5-完全更新所有字段（不变的field也要加入将要更新的document中）"><a href="#5-完全更新所有字段（不变的field也要加入将要更新的document中）" class="headerlink" title="5. 完全更新所有字段（不变的field也要加入将要更新的document中）"></a>5. 完全更新所有字段（不变的field也要加入将要更新的document中）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static void fullUpdateDocumentNameByItemId(IndexWriter writer, String itemId, String newName, String oldColor) throws IOException &#123;</span><br><span class="line">Document doc = new Document();</span><br><span class="line">doc.add(new StringField(&quot;name&quot;, newName, Field.Store.YES));</span><br><span class="line">doc.add(new StringField(&quot;item_id&quot;, itemId, Field.Store.YES));</span><br><span class="line">doc.add(new StringField(&quot;color&quot;, oldColor, Field.Store.YES));</span><br><span class="line"></span><br><span class="line">Term mainTerm = new Term(&quot;item_id&quot;, itemId);</span><br><span class="line">writer.updateDocument(mainTerm, doc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-验证完全更新"><a href="#6-验证完全更新" class="headerlink" title="6. 验证完全更新"></a>6. 验证完全更新</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">fullUpdateDocumentNameByItemId(indexWriter, &quot;1&quot;, &quot;item1_updated&quot;, &quot;red&quot;);</span><br><span class="line">fullUpdateDocumentNameByItemId(indexWriter, &quot;2&quot;, &quot;item2_updated&quot;, &quot;blue&quot;);</span><br><span class="line"></span><br><span class="line">indexWriter.commit();</span><br><span class="line">indexWriter.flush();</span><br><span class="line"></span><br><span class="line">indexReader = DirectoryReader.open(readDirectory);</span><br><span class="line">indexSearcher = new IndexSearcher(indexReader);</span><br><span class="line">getDocumentById(indexSearcher, &quot;1&quot;);</span><br><span class="line"></span><br><span class="line">indexReader = DirectoryReader.open(readDirectory);</span><br><span class="line">indexSearcher = new IndexSearcher(indexReader);</span><br><span class="line">getDocumentById(indexSearcher, &quot;2&quot;);</span><br><span class="line"></span><br><span class="line">// output</span><br><span class="line">//  name: item1_updated</span><br><span class="line">//  item_id: 1</span><br><span class="line">//  color: red</span><br><span class="line">//  name: item2_updated</span><br><span class="line">//  item_id: 2</span><br><span class="line">//  color: blue</span><br></pre></td></tr></table></figure><h4 id="7-删除文档"><a href="#7-删除文档" class="headerlink" title="7. 删除文档"></a>7. 删除文档</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static void deleteDocument(IndexWriter writer, String itemId) throws IOException &#123;</span><br><span class="line">    Term mainTerm = new Term(&quot;item_id&quot;, itemId);</span><br><span class="line">    writer.deleteDocuments(mainTerm);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-验证删除文档"><a href="#8-验证删除文档" class="headerlink" title="8. 验证删除文档"></a>8. 验证删除文档</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">getDocumentById(indexSearcher, &quot;1&quot;);</span><br><span class="line">getDocumentById(indexSearcher, &quot;2&quot;);</span><br><span class="line"></span><br><span class="line">// cannot found 1</span><br><span class="line">// cannot found 2</span><br></pre></td></tr></table></figure><p>结论： </p><ol><li>必须将原始文档的所有字段全部获取到再用updateDocument的方式更新，才能实现我们预期中部分更新字段的目的，可以看到成本还是比较高的</li><li>由于Lucene的这种机制也导致了，ES的CRUD模型中需要实现一些额外的机制才能使用到Lucene的能力</li></ol><h3 id="ES中的操作"><a href="#ES中的操作" class="headerlink" title="ES中的操作"></a>ES中的操作</h3><h4 id="ES-mapping"><a href="#ES-mapping" class="headerlink" title="ES mapping"></a>ES mapping</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">PUT /my_index</span><br><span class="line">&#123;</span><br><span class="line">  &quot;mappings&quot;: &#123;</span><br><span class="line">    &quot;properties&quot;: &#123;</span><br><span class="line">      &quot;item_id&quot;: &#123;</span><br><span class="line">        &quot;type&quot;: &quot;keyword&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;name&quot;: &#123;</span><br><span class="line">        &quot;type&quot;: &quot;keyword&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;color&quot;: &#123;</span><br><span class="line">        &quot;type&quot;: &quot;keyword&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-创建文档-1"><a href="#1-创建文档-1" class="headerlink" title="1. 创建文档"></a>1. 创建文档</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">PUT my_index/_doc/1</span><br><span class="line">&#123;</span><br><span class="line">  &quot;item_id&quot;: &quot;1&quot;,</span><br><span class="line">  &quot;name&quot;:&quot;item1&quot;,</span><br><span class="line">  &quot;color&quot;: &quot;red&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT my_index/_doc/2</span><br><span class="line">&#123;</span><br><span class="line">  &quot;item_id&quot;: &quot;2&quot;,</span><br><span class="line">  &quot;name&quot;:&quot;item2&quot;,</span><br><span class="line">  &quot;color&quot;: &quot;blue&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-获取文档"><a href="#2-获取文档" class="headerlink" title="2. 获取文档"></a>2. 获取文档</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">GET my_index/_search</span><br><span class="line">// output</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">&quot;hits&quot;: [</span><br><span class="line">&#123;</span><br><span class="line">&quot;_index&quot;: &quot;my_index&quot;,</span><br><span class="line">&quot;_id&quot;: &quot;1&quot;,</span><br><span class="line">&quot;_score&quot;: 1,</span><br><span class="line">&quot;_source&quot;: &#123;</span><br><span class="line">&quot;item_id&quot;: &quot;1&quot;,</span><br><span class="line">&quot;name&quot;: &quot;item1&quot;,</span><br><span class="line">&quot;color&quot;: &quot;red&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">&quot;_index&quot;: &quot;my_index&quot;,</span><br><span class="line">&quot;_id&quot;: &quot;2&quot;,</span><br><span class="line">&quot;_score&quot;: 1,</span><br><span class="line">&quot;_source&quot;: &#123;</span><br><span class="line">&quot;item_id&quot;: &quot;2&quot;,</span><br><span class="line">&quot;name&quot;: &quot;item2&quot;,</span><br><span class="line">&quot;color&quot;: &quot;blue&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-部分更新"><a href="#3-部分更新" class="headerlink" title="3.部分更新"></a>3.部分更新</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">POST my_index/_update/1</span><br><span class="line">&#123;</span><br><span class="line">  &quot;doc&quot;: &#123;</span><br><span class="line">    &quot;name&quot;: &quot;item1_updated&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">POST my_index/_update/2</span><br><span class="line">&#123;</span><br><span class="line">  &quot;doc&quot;: &#123;</span><br><span class="line">    &quot;name&quot;: &quot;item2_updated&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-获取部分更新后的文档"><a href="#4-获取部分更新后的文档" class="headerlink" title="4.获取部分更新后的文档"></a>4.获取部分更新后的文档</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">GET my_index/_search</span><br><span class="line">// output</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">&quot;hits&quot;: [</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;_index&quot;: &quot;my_index&quot;,</span><br><span class="line">        &quot;_id&quot;: &quot;1&quot;,</span><br><span class="line">        &quot;_score&quot;: 1,</span><br><span class="line">        &quot;_source&quot;: &#123;</span><br><span class="line">          &quot;item_id&quot;: &quot;1&quot;,</span><br><span class="line">          &quot;name&quot;: &quot;item1_updated&quot;,</span><br><span class="line">          &quot;color&quot;: &quot;red&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;_index&quot;: &quot;my_index&quot;,</span><br><span class="line">        &quot;_id&quot;: &quot;2&quot;,</span><br><span class="line">        &quot;_score&quot;: 1,</span><br><span class="line">        &quot;_source&quot;: &#123;</span><br><span class="line">          &quot;item_id&quot;: &quot;2&quot;,</span><br><span class="line">          &quot;name&quot;: &quot;item2_updated&quot;,</span><br><span class="line">          &quot;color&quot;: &quot;blue&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明: 可以看ES中部分更新是可以正常的工作的, 原因就在于ES在处理update的时候会自动拉取原始文档的所有字段和新的更新的字段组合成一份完整的新的全量字段的文档，再去更新Lucene</p><h4 id="5-完整更新所有字段"><a href="#5-完整更新所有字段" class="headerlink" title="5. 完整更新所有字段"></a>5. 完整更新所有字段</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 方式一</span><br><span class="line">POST my_index/_update/1</span><br><span class="line">&#123;</span><br><span class="line">  &quot;doc&quot;: &#123;</span><br><span class="line">    &quot;name&quot;: &quot;item1_updated&quot;,</span><br><span class="line">    &quot;item_id&quot;: &quot;1&quot;,</span><br><span class="line">    &quot;color&quot;: &quot;red&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 方式二</span><br><span class="line">PUT my_index/_doc/1</span><br><span class="line">&#123;</span><br><span class="line">  &quot;item_id&quot;: &quot;1&quot;,</span><br><span class="line">  &quot;name&quot;:&quot;item1_update_by_put&quot;,</span><br><span class="line">  &quot;color&quot;: &quot;red&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-验证完全更新-1"><a href="#6-验证完全更新-1" class="headerlink" title="6. 验证完全更新"></a>6. 验证完全更新</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">GET my_index/_search</span><br><span class="line">// output</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line"> &quot;hits&quot;: [</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;_index&quot;: &quot;my_index&quot;,</span><br><span class="line">        &quot;_id&quot;: &quot;1&quot;,</span><br><span class="line">        &quot;_score&quot;: 1,</span><br><span class="line">        &quot;_source&quot;: &#123;</span><br><span class="line">          &quot;item_id&quot;: &quot;1&quot;,</span><br><span class="line">          &quot;name&quot;: &quot;item1_update_by_put&quot;,</span><br><span class="line">          &quot;color&quot;: &quot;red&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;_index&quot;: &quot;my_index&quot;,</span><br><span class="line">        &quot;_id&quot;: &quot;2&quot;,</span><br><span class="line">        &quot;_score&quot;: 1,</span><br><span class="line">        &quot;_source&quot;: &#123;</span><br><span class="line">          &quot;item_id&quot;: &quot;2&quot;,</span><br><span class="line">          &quot;name&quot;: &quot;item2_updated&quot;,</span><br><span class="line">          &quot;color&quot;: &quot;blue&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-删除文档-1"><a href="#7-删除文档-1" class="headerlink" title="7. 删除文档"></a>7. 删除文档</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DELETE my_index/_doc/1</span><br><span class="line">DELETE my_index/_doc/2</span><br></pre></td></tr></table></figure><h4 id="8-验证删除文档-1"><a href="#8-验证删除文档-1" class="headerlink" title="8. 验证删除文档"></a>8. 验证删除文档</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET my_index/_search</span><br><span class="line"></span><br><span class="line">// output</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">&quot;hits&quot;: []</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="ES如何在Lucene的基础上实现基于主键-id-的删改"><a href="#ES如何在Lucene的基础上实现基于主键-id-的删改" class="headerlink" title="ES如何在Lucene的基础上实现基于主键(_id)的删改"></a>ES如何在Lucene的基础上实现基于主键(_id)的删改</h3><ol><li>ES 使用<code>_id</code>的内部字段作为文档的主键，这个<code>_id</code>可以用户指定，上面的例子中item_id就是对应了<code>_id</code>，Lucene中没有主键的概念，所以需要使用_id 作为一个独特的Term的维持文档的唯一性, 后续的更新, 删除也是和<code>_id</code>对应的Term绑定. Lucene的创建操作不具备幂等性（addDocument）指定了Term之后，这个Term下可以关联N个document，不具备唯一性.</li><li>ES 在部分字段的更新中，自己封装了一层获取原始文档的操作，之后使用update的方式更新Lucene.</li><li>ES 在删除文档操作中，使用<code>_id</code>对应的Term 去调用Lucene的API.</li><li>ES 在创建文档操作中，PUT 相同<code>_id</code>的文档 同样能保持唯一性, 通常情况下ES也是用Lucene update的方式实现创建的请求.</li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li>Lucene整体是一个Append Only的存储引擎，且没有主键的概念.</li><li>ES 本身封装了一系列的操作使得整个CRUD操作更加方便使用，这也不可避免的带了一些额外的开销，通过理解这些操作的底层原理，有助于我们做出一些最佳实践的选择.</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> ES, Lucene, elasticsearch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java ByteBuffer实践</title>
      <link href="/2021/08/14/bytebuffer%E5%AE%9E%E8%B7%B5/"/>
      <url>/2021/08/14/bytebuffer%E5%AE%9E%E8%B7%B5/</url>
      
        <content type="html"><![CDATA[<h1 id="Java-bytebuffer实践"><a href="#Java-bytebuffer实践" class="headerlink" title="Java bytebuffer实践"></a>Java bytebuffer实践</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近在使用java做文件io相关的代码时，不可避免的使用的filechannel和bytebuffer，其中bytebuffer有些地方容易让初学者产生困扰，这里记录一下我的一些实践</p><h2 id="类结构"><a href="#类结构" class="headerlink" title="类结构"></a>类结构</h2><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/64970207be0849109cffe25ec6028838~tplv-k3u1fbpfcp-zoom-1.image"></p><h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p>我们解释下Buffer类和ByteBuffer中的字段</p><ul><li>hb：这个就是实际的byte数组</li><li>capacity：就是这个hb实际容量，绝大部分场景下都不可改变，无法增大</li><li>offset：内置的偏移量，每次读写buffer都必须加上offset，默认ByteBuffer.allocate的偏移量是0</li><li>position: 当前buffer 读写的位置，类似于cursor的概念，默认是0</li><li>limit: 当前buffer读写位置的上限，默认是capacity</li><li>mark：用来记录某个时刻position的位置，默认值是-1</li></ul><blockquote><p><em>&#x2F;&#x2F; Invariants: mark &lt;&#x3D; position &lt;&#x3D; limit &lt;&#x3D; capacity</em></p></blockquote><ol><li>向buffer中写入内容: position变大</li><li>读取buffer中的内容：当写入完成时此时相当于0到position之间的内容都是刚刚写入的，那应该如何读取呢, 因为读写都是根据position来的，此时需要做一次flip操作，position需要被清零，limit换成之前的position</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public final Buffer flip() &#123;</span><br><span class="line"></span><br><span class="line">    limit = position;</span><br><span class="line"></span><br><span class="line">    position = 0;</span><br><span class="line"></span><br><span class="line">    mark = -1;</span><br><span class="line"></span><br><span class="line">    return this;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>flip操作完之后会发现，limit和capacity之前有可能不一样了，下次在写入buffer的时候能写入的数据变小了</p><h3 id="为什么要在写buffer完之后使用flip呢"><a href="#为什么要在写buffer完之后使用flip呢" class="headerlink" title="为什么要在写buffer完之后使用flip呢"></a>为什么要在写buffer完之后使用flip呢</h3><p>因为写入到buffer中的只有0到position之间的数据，而position和就limit之间的数据是未定义的，不应该被应用程序读到，所以需要将最新的写入position设置为新的limit，这样应用程序读到limit就不读取数据了。</p><h3 id="读完之后再写应该怎么处理"><a href="#读完之后再写应该怎么处理" class="headerlink" title="读完之后再写应该怎么处理"></a>读完之后再写应该怎么处理</h3><ul><li>假设完全读完了buffer，此时position和limit相等，对于这个buffer来说它的remaining是0了，不存在可写入的空间了，此时可以继续使用flip，当然更好的处理是使用rewind</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public final Buffer rewind() &#123;</span><br><span class="line"></span><br><span class="line">    position = 0;</span><br><span class="line"></span><br><span class="line">    mark = -1;</span><br><span class="line"></span><br><span class="line">    return this;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="具体的使用场景"><a href="#具体的使用场景" class="headerlink" title="具体的使用场景"></a>具体的使用场景</h2><ol><li><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 初始化</span><br><span class="line"></span><br><span class="line">ByteBuffer buf = ByteBuffer.allocate(4096);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public static ByteBuffer allocate(int capacity) &#123;</span><br><span class="line"></span><br><span class="line">    if (capacity &lt; 0)</span><br><span class="line"></span><br><span class="line">        throw new IllegalArgumentException();</span><br><span class="line"></span><br><span class="line">    return new HeapByteBuffer(capacity, capacity);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到实际初始化的是HeapByteBuffer实例，因为还有DirectBuffer，不过本文不会涉及</p><ol start="2"><li><h3 id="读写buffer"><a href="#读写buffer" class="headerlink" title="读写buffer"></a>读写buffer</h3></li></ol><p>因为Filechannel配合在一起使用，而且经常和文件系统的读写在一个语境中使用，不免有些容易混淆的地方。</p><ul><li>从文件系统读取数据到buffer中，即使用<code>fileChannel.read(buf)</code>这个对于buffer来说其实是写入，<strong>当然该read会尽可能读满buffer</strong></li><li>通过filechannel和bytebuffer读取文件中第一个long number</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fileChannel.read(buf);   // buf会被读满，即position==limit</span><br><span class="line"></span><br><span class="line">buf.flip();              // position = 0; limit = old position</span><br><span class="line"></span><br><span class="line">buf.getLong();           // position += 8;</span><br></pre></td></tr></table></figure><p>所以我们看到从文件系统中读完之后要flip一下，在使用buf读写的时候要注意尽量读满再使用flip，否则应该使用rewind</p><ul><li>通过bytebuffer和filechannel写入一个long number到文件系统中</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">buf.putLong(1L);</span><br><span class="line"></span><br><span class="line">buf.flip(); // 未写满的情况下，必须使用flip，写满的情况下flip和rewind是等价的</span><br><span class="line"></span><br><span class="line">fileChannel.write(buf);</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>容易让人混淆的就是flip使用的时机，理解position和limit的关系之后就会简单不少</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 实践 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang 中[]byte, string和[]rune的相互转化的底层原理和剖析</title>
      <link href="/2021/02/21/golang_slice/"/>
      <url>/2021/02/21/golang_slice/</url>
      
        <content type="html"><![CDATA[<h1 id="Golang-中-byte-string和-rune的相互转化的底层原理和剖析"><a href="#Golang-中-byte-string和-rune的相互转化的底层原理和剖析" class="headerlink" title="Golang 中[]byte, string和[]rune的相互转化的底层原理和剖析"></a>Golang 中<code>[]byte</code>, <code>string</code>和<code>[]rune</code>的相互转化的底层原理和剖析</h1><p>在golang中有些场景经常会用到[]byte和string的相互转化，尤其是在使用json.Marshal和json.Unmarshal的时候，经常会遇到需要这种转化。</p><p>本文主要说明以下内容：</p><ul><li>几种类型相互转化的方法和性能分析</li><li>这些类型的底层存储</li><li>代码<a href="https://gist.github.com/skyitachi/f8f22a390f547466216b0a4084b98bee">gist</a></li></ul><h2 id="相互转化"><a href="#相互转化" class="headerlink" title="相互转化"></a>相互转化</h2><h3 id="byte和string的相互转化"><a href="#byte和string的相互转化" class="headerlink" title="[]byte和string的相互转化"></a>[]byte和string的相互转化</h3><h4 id="string-byte"><a href="#string-byte" class="headerlink" title="string -&gt; []byte"></a>string -&gt; []byte</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkStringToByteSlice</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">s := genString(<span class="number">10000</span>)</span><br><span class="line">b.ReportAllocs()</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">bs := []<span class="type">byte</span>(s)</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(bs) != <span class="built_in">len</span>(s) &#123;</span><br><span class="line">b.Error(<span class="string">&quot;error&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkStringToByteSliceUnsafe</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">s := genString(<span class="number">10000</span>)</span><br><span class="line">b.ReportAllocs()</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">l := <span class="built_in">len</span>(s)</span><br><span class="line">bs := *(*[]<span class="type">byte</span>)(unsafe.Pointer(&amp;reflect.SliceHeader&#123;</span><br><span class="line">Data: (*(*reflect.StringHeader)(unsafe.Pointer(&amp;s))).Data,</span><br><span class="line">Len:  l,</span><br><span class="line">Cap:  l,</span><br><span class="line">&#125;))</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(bs) != <span class="built_in">len</span>(s) &#123;</span><br><span class="line">b.Error(<span class="string">&quot;error&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一种使用[]byte这种直接转化，也是我们常用的方式，第二种是使用unsafe的方式。这两种区别就在于一个是重新分配了内存，另一个是复用了原来的内存。</p><p>benchmark的结果也验证了这一点</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">go test  -run=BenchmarkStringToByteSlice -bench=StringToByteSlice</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">go-demo.test</span></span><br><span class="line"></span><br><span class="line">goos: darwin</span><br><span class="line">goarch: amd64</span><br><span class="line">pkg: go-demo</span><br><span class="line">BenchmarkStringToByteSlice-12           1164224       964 ns/op   10285 B/op       1 allocs/op</span><br><span class="line">BenchmarkStringToByteSliceUnsafe-12    1000000000         0.380 ns/op       0 B/op       0 allocs/op</span><br><span class="line">PASS</span><br><span class="line">ok  go-demo2.089s</span><br></pre></td></tr></table></figure><h4 id="byte-string"><a href="#byte-string" class="headerlink" title="[]byte -&gt; string"></a>[]byte -&gt; string</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkSliceByteToString</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">bs := genSliceByte(<span class="number">100</span>)</span><br><span class="line">b.ReportAllocs()</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">s := <span class="type">string</span>(bs)</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(s) != <span class="built_in">len</span>(bs) &#123;</span><br><span class="line">b.Error(<span class="string">&quot;error&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkSliceByteToStringUnsafe</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">bs := genSliceByte(<span class="number">100</span>)</span><br><span class="line">b.ReportAllocs()</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">s := *(*<span class="type">string</span>)(unsafe.Pointer(&amp;bs))</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(s) != <span class="built_in">len</span>(bs) &#123;</span><br><span class="line">b.Log(<span class="string">&quot;slice: &quot;</span>, <span class="built_in">len</span>(bs), <span class="string">&quot; string: &quot;</span>, <span class="built_in">len</span>(s))</span><br><span class="line">b.Error(<span class="string">&quot;error: &quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>benchmark 结果</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">go test  -run=BenchmarkSliceByteToString -bench=SliceByteToString</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">go-demo.test</span></span><br><span class="line"></span><br><span class="line">goos: darwin</span><br><span class="line">goarch: amd64</span><br><span class="line">pkg: go-demo</span><br><span class="line">BenchmarkSliceByteToString-12          35913873        32.4 ns/op     112 B/op       1 allocs/op</span><br><span class="line">BenchmarkSliceByteToStringUnsafe-12    1000000000         0.253 ns/op       0 B/op       0 allocs/op</span><br><span class="line">PASS</span><br><span class="line">ok  go-demo3.796s</span><br></pre></td></tr></table></figure><h3 id="string和-rune的相互转化"><a href="#string和-rune的相互转化" class="headerlink" title="string和[]rune的相互转化"></a>string和[]rune的相互转化</h3><p>string和rune的相互转化其实和上面类似，主要是[]rune对应的[]byte数组长度需要计算下，这里就只贴一个[]rune到string的转化了</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkSliceRuneToStringUnsafe</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">bs := genSliceRune(<span class="number">100</span>)</span><br><span class="line">s1 := <span class="type">string</span>(bs)</span><br><span class="line">b.ReportAllocs()</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line"><span class="keyword">var</span> l <span class="type">int</span></span><br><span class="line"><span class="keyword">for</span> _, r := <span class="keyword">range</span> bs &#123;</span><br><span class="line">l += utf8.RuneLen(r)</span><br><span class="line">&#125;</span><br><span class="line">s := *(*<span class="type">string</span>)(unsafe.Pointer(&amp;reflect.StringHeader&#123;</span><br><span class="line">Data: (*(*reflect.SliceHeader)(unsafe.Pointer(&amp;bs))).Data,</span><br><span class="line">Len:  l,</span><br><span class="line">&#125;))</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(s1) != <span class="built_in">len</span>(s) &#123;</span><br><span class="line">b.Error(<span class="string">&quot;error&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="String和Slice的底层存储分析"><a href="#String和Slice的底层存储分析" class="headerlink" title="String和Slice的底层存储分析"></a>String和Slice的底层存储分析</h2><h4 id="reflect-SliceHeader-和reflect-StringHeader"><a href="#reflect-SliceHeader-和reflect-StringHeader" class="headerlink" title="reflect.SliceHeader 和reflect.StringHeader"></a>reflect.SliceHeader 和reflect.StringHeader</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> StringHeader <span class="keyword">struct</span> &#123;</span><br><span class="line">Data <span class="type">uintptr</span></span><br><span class="line">Len  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> SliceHeader <span class="keyword">struct</span> &#123;</span><br><span class="line">Data <span class="type">uintptr</span></span><br><span class="line">Len  <span class="type">int</span></span><br><span class="line">Cap  <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两者类型基本一样，Slice多了一个Cap，其实这也决定了[]byte可以直接使用指针强转成string，但是反过来却不行</p><h4 id="slice的底层存储"><a href="#slice的底层存储" class="headerlink" title="slice的底层存储"></a>slice的底层存储</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> slice <span class="keyword">struct</span> &#123;</span><br><span class="line">array unsafe.Pointer</span><br><span class="line"><span class="built_in">len</span>   <span class="type">int</span></span><br><span class="line"><span class="built_in">cap</span>   <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="以汇编的形式看下slice的底层结构"><a href="#以汇编的形式看下slice的底层结构" class="headerlink" title="以汇编的形式看下slice的底层结构"></a>以汇编的形式看下slice的底层结构</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> pkg</span><br><span class="line"></span><br><span class="line"><span class="comment">// var data = make([]int, 0, 10)</span></span><br><span class="line"><span class="keyword">var</span> data = []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">go tool compile -S pkg.go</span><br><span class="line">go.cuinfo.packagename. SDWARFINFO dupok size=0</span><br><span class="line">0x0000 70 6b 67                                         pkg</span><br><span class="line">&quot;&quot;.data SDATA size=24</span><br><span class="line">0x0000 00 00 00 00 00 00 00 00 02 00 00 00 00 00 00 00  ................</span><br><span class="line">0x0010 02 00 00 00 00 00 00 00                          ........</span><br><span class="line">rel 0+8 t=1 &quot;&quot;..stmp_0+0</span><br><span class="line">&quot;&quot;..stmp_0 SNOPTRDATA size=16</span><br><span class="line">0x0000 01 00 00 00 00 00 00 00 02 00 00 00 00 00 00 00  ................</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>可以看到””.data 对应的是size是24（8byte的指针，len和cap各自8byte），slice里的内容是两个int对应的就是，””.stmp_0 里的内容</p><p>进一步分析data对应的二进制</p><ul><li>data+8是<code>02 00 ...</code> ，对应len</li><li>data+16是<code>02 00</code> 对应cap</li></ul><p>整个slice struct在内存里是紧凑分布的，所以我们可以进行指针类的强制转化，类似于c++中<code>reinterpret_cast</code></p><h5 id="string的底层结构"><a href="#string的底层结构" class="headerlink" title="string的底层结构"></a>string的底层结构</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> pkg</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> testStr = <span class="string">&quot;abc&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">go.cuinfo.packagename. SDWARFINFO dupok size=0</span><br><span class="line">0x0000 70 6b 67                                         pkg</span><br><span class="line">go.string.&quot;abc&quot; SRODATA dupok size=3</span><br><span class="line">0x0000 61 62 63                                         abc</span><br><span class="line">&quot;&quot;.testStr SDATA size=16</span><br><span class="line">0x0000 00 00 00 00 00 00 00 00 03 00 00 00 00 00 00 00  ................</span><br><span class="line">rel 0+8 t=1 go.string.&quot;abc&quot;+0</span><br></pre></td></tr></table></figure><p>和上文的slice很类似，size变成了16而已</p><h4 id="Fat-Pointer"><a href="#Fat-Pointer" class="headerlink" title="Fat Pointer"></a>Fat Pointer</h4><p>像slice这种结构在c中常被称为fatpointer，感兴趣的同学可以参考<a href="https://nullprogram.com/blog/2019/06/30/">Go Slices are Fat Pointers</a></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>介绍了golang中string，[]byte和[]rune的转化及简单的性能分析</li><li>slice在golang中的底层存储</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> golang slice </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二分法的两种实现</title>
      <link href="/2020/04/14/%E4%BA%8C%E5%88%86%E6%B3%95%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%AE%9E%E7%8E%B0/"/>
      <url>/2020/04/14/%E4%BA%8C%E5%88%86%E6%B3%95%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>虽然二分搜索很简单（在无重复的有序数组上）,但是也有很多值得注意的地方，而且有两种完全不同的写法（两种完全不同的功能）</p><h4 id="lower-bound"><a href="#lower-bound" class="headerlink" title="lower bound"></a>lower bound</h4><blockquote><p>找出大于等于target的最小数组下标, 不存在的情况下返回-1</p></blockquote><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lower_bound</span><span class="params">(a []<span class="type">int</span>, target <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">  l := <span class="number">0</span></span><br><span class="line">  h := <span class="built_in">len</span>(a) - <span class="number">1</span></span><br><span class="line">  <span class="keyword">for</span> l &lt; h &#123;</span><br><span class="line">    m := l + (h - l) / <span class="number">2</span></span><br><span class="line">    <span class="keyword">if</span> a[m] &gt;= target &#123;</span><br><span class="line">      h = m</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// l肯定可以取到h值，所以不需要使用向上取整计算m值</span></span><br><span class="line">      l += <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> a[l] &gt;= target &#123;</span><br><span class="line">    <span class="keyword">return</span> l</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="upper-bound"><a href="#upper-bound" class="headerlink" title="upper bound"></a>upper bound</h4><blockquote><p>找出小于等于target的最大数组下标</p></blockquote><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">upper_bound</span><span class="params">(a []<span class="type">int</span>, target <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">  l := <span class="number">0</span></span><br><span class="line">h := <span class="built_in">len</span>(a) - <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> l &lt; h &#123;</span><br><span class="line">m := l + (h - l + <span class="number">1</span>) / <span class="number">2</span></span><br><span class="line"><span class="keyword">if</span> a[m] &lt;= target &#123;</span><br><span class="line">      <span class="comment">// l 要能够取到h值，就必须保证m使用向上取整计算, (h - l + 1) / 2 就是这么来的</span></span><br><span class="line">l = m</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">h = m - <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> a[l] &lt;= target &#123;</span><br><span class="line"><span class="keyword">return</span> l</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h4><ul><li>计算mid的时候不能发生溢出</li><li>数组下标不能越界</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>dubbo-go support protobuf</title>
      <link href="/2019/12/30/dubbo-go-protobuf-support/"/>
      <url>/2019/12/30/dubbo-go-protobuf-support/</url>
      
        <content type="html"><![CDATA[<h4 id="主要用法"><a href="#主要用法" class="headerlink" title="主要用法"></a>主要用法</h4><ul><li>和grpc中使用protobuf生成代码基本一致（至少在形式上）,直接看例子吧</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">├── go-client</span><br><span class="line">│   ├── client.go</span><br><span class="line">│   ├── client.yml</span><br><span class="line">├── go-server</span><br><span class="line">│   ├── main.go</span><br><span class="line">│   └── server.yml</span><br><span class="line">└── user</span><br><span class="line">    ├── user.pb.go</span><br><span class="line">    └── user.proto</span><br></pre></td></tr></table></figure><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> user;</span><br><span class="line"></span><br><span class="line"><span class="keyword">service </span><span class="title class_">UserProvider</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">rpc</span> GetUser (UserRequest) <span class="keyword">returns</span> (UserReply) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">UserRequest</span> &#123;</span><br><span class="line">  <span class="type">string</span> id = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">UserReply</span> &#123;</span><br><span class="line">  <span class="type">string</span> id = <span class="number">1</span>;</span><br><span class="line">  <span class="type">string</span> name = <span class="number">2</span>;</span><br><span class="line">  <span class="type">int32</span> age = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用protoc-gen-dubbogo插件生成dubbogo的代理</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protoc --plugin=&#123;plugin_path&#125; --dubbogo_out=plugins=dubbogo:. user/user.proto</span><br></pre></td></tr></table></figure><ul><li>client关键代码</li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">user := user.NewUserProvider()</span><br><span class="line">reply := user.UserReply&#123;&#125;</span><br><span class="line">err := userProvider.GetUser(context.TODO(), &amp;user.UserRequest&#123;Id: <span class="string">&quot;A001&quot;</span>&#125;, &amp;reply)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">  log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;response result: %+v&quot;</span>, reply)</span><br></pre></td></tr></table></figure><p>ps: 一切都是熟悉的味道<br>ps: 生成代理的名称需要和reference里配置的一样</p><ul><li>server关键代码</li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> UserProvider <span class="keyword">struct</span> &#123;</span><br><span class="line">pb.UnimplementedUserProviderServer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*UserProvider)</span></span> GetUser(ctx context.Context, user *pb.UserRequest) (*pb.UserReply, <span class="type">error</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> &amp;pb.UserReply&#123;Id: <span class="string">&quot;001&quot;</span>, Name: <span class="string">&quot;alice&quot;</span>, Age: <span class="number">18</span>&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册</span></span><br><span class="line">pb.RegisterProvider(<span class="built_in">new</span>(UserProvider))</span><br></pre></td></tr></table></figure><h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><ul><li>在dubbogo抽出一层serialization，任何和serialization相关的之后只要实现Serialize接口就行了，这样是为了更好的实现更多序列化的支持，逻辑上会更合理一些，原有的go hessian2中做了一部分dubbo相关的codec工作，这里我也把它抽到dubbogo中了， 当然hessian2的序列化仍然保留了，这次实现是兼容老版本的。</li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Serializer <span class="keyword">interface</span> &#123;</span><br><span class="line">Marshal(p DubboPackage) ([]<span class="type">byte</span>, <span class="type">error</span>)</span><br><span class="line">Unmarshal([]<span class="type">byte</span>, *DubboPackage) <span class="type">error</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>参考了dubbo的protobuf实现，实现了在protobuf层面和java互通（不一定是好事:(）</li><li>其他的就是细节了</li></ul><h4 id="一些注意点"><a href="#一些注意点" class="headerlink" title="一些注意点"></a>一些注意点</h4><ul><li><code>error</code>的处理和java不太一样，java会把详细的java error stack都返回给客户端，go只会把message传过来，生成一个error</li><li>由于java protobuf生成的代理方法名是小写开头(完全搞不明白是为什么)，这在golang中表示私有方法，个人已经提了<a href="https://github.com/apache/dubbo/issues/5536">issue</a>, 所以直接用java的例子是不行的</li><li>java protobuf的代理生成的是内部接口，比如xxx$IDemoService, <code>$</code>是url中的一个特殊字符，正好发现了dubbogo的一个注册url的bug</li></ul><h4 id="我为什么要支持protobuf"><a href="#我为什么要支持protobuf" class="headerlink" title="我为什么要支持protobuf"></a>我为什么要支持protobuf</h4><ul><li>protobuf的语言中立性更好，序列化性能也更好</li><li>更加符合golang的生态</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> dubbo, go, protobuf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++中的传参</title>
      <link href="/2019/08/21/passing-value-in-cpp/"/>
      <url>/2019/08/21/passing-value-in-cpp/</url>
      
        <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>最近在用c++写基于libuv的websocket engine的时候发现, 设置callback的参数是一个很有挑战性的工作, 原来觉得c++的复杂在于其模板，oo范式概念的复杂, 现在发现c++的每个方面都很复杂，因为有太多可以通过编译的方式了，我想从传参这个方面切入，让大家了解下c++的复杂（强大）。</p><p>ps：本文的传参使基于涉及到动态内存分配对象的传参，一般普通对象的传参基本是不需要考虑这么复杂的(至少我目前这么认为)。</p><p>以下是本文中需要传递的参数，一个简单的String, 只保留会讲到的构造函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">String</span>: &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">String</span>(<span class="type">const</span> <span class="type">char</span>* src): <span class="built_in">data_</span>(<span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(src) + <span class="number">1</span>]), <span class="built_in">size_</span>(<span class="built_in">strlen</span>(src)) &#123;</span><br><span class="line">      ::<span class="built_in">strcpy</span>(data_, src);</span><br><span class="line">      data_[size_] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">String</span>(<span class="type">const</span> String&amp; lhs): <span class="built_in">data_</span>(<span class="keyword">new</span> <span class="type">char</span>[lhs.<span class="built_in">size</span>() + <span class="number">1</span>]), <span class="built_in">size_</span>(lhs.<span class="built_in">size</span>()) &#123;</span><br><span class="line">      ::<span class="built_in">strcpy</span>(data_, lhs.<span class="built_in">data</span>());</span><br><span class="line">      data_[size_] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// move</span></span><br><span class="line">    <span class="built_in">String</span>(String &amp;&amp;rhs) <span class="keyword">noexcept</span>: <span class="built_in">data_</span>(rhs.data_), <span class="built_in">size_</span>(rhs.size_) &#123;</span><br><span class="line">      rhs.data_ = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我遇到的一个问题是在MessageCallback中，应该使用<code>const String&amp; message</code>还是<code>String&amp;&amp; message</code>, 这两种形参的区别是什么</p><h5 id="理解std-move-和右值引用"><a href="#理解std-move-和右值引用" class="headerlink" title="理解std::move 和右值引用"></a>理解<code>std::move</code> 和<code>右值引用</code></h5><p>在弄清上述问题之前，还是要从根本上着手，弄清<code>std::move</code>和右值引用。<br>右值引用是c++11中引入的一种新的引用类型，必须要绑定到右值的引用。<br>而std::move的作用是可以把几乎任意值转化成一个右值引用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_passing_value</span><span class="params">(std::string&amp; s1)</span> </span>&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;in the left reference&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_passing_value</span><span class="params">(std::string&amp;&amp; s1)</span> </span>&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;in the right reference&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::string s1 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">std::string &amp;sr = s1;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test_passing_value</span>(s1); <span class="comment">// in the left</span></span><br><span class="line"><span class="built_in">test_passing_value</span>(std::<span class="built_in">move</span>(s1)); <span class="comment">// in the right</span></span><br><span class="line"><span class="built_in">test_passing_value</span>(sr); <span class="comment">// in the left</span></span><br><span class="line"><span class="built_in">test_passing_value</span>(std::<span class="built_in">move</span>(sr)); <span class="comment">// in the right</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以看到无论是左值，还是左值引用，使用std::move之后都可以变成右值引用</span></span><br><span class="line"><span class="comment">// 意外的情况就是const T&amp; 在使用std::move转化时的特殊情况</span></span><br></pre></td></tr></table></figure><h5 id="const-T-vs-T"><a href="#const-T-vs-T" class="headerlink" title="const T&amp; vs T&amp;&amp;"></a><code>const T&amp;</code> vs <code>T&amp;&amp;</code></h5><p>c++11中引入了右值引用和move语义，初学者（比如我）很容易被这种特性吸引（move比copy快）, 两者其实是解决不同场景下的问题，T&amp;&amp; 的确提供了一种更为高效的传参方式, 让我们看下两者的细节和使用场景吧。</p><ul><li><p>仅仅使用<code>const T&amp;</code>并不会发生copy</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">const</span> String&amp; s)</span> </span>&#123;</span><br><span class="line">  std::cout &lt;&lt; s &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">String <span class="title">s0</span><span class="params">(<span class="string">&quot;hello&quot;</span>)</span></span>;</span><br><span class="line">  <span class="built_in">foo</span>(s0); <span class="comment">// 不会发生复制</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>const T&amp;</code> 发生复制的情况是在函数体内用到T的local variable， 比如<code>T local = t</code>, 这时候会发生拷贝控制</p></li><li><p>仅仅使用<code>T&amp;&amp;</code>不会发生move</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f2</span><span class="params">(String &amp;&amp;s2)</span> </span>&#123;</span><br><span class="line">  std::cout &lt;&lt; s2 &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">f2</span>(<span class="built_in">String</span>(<span class="string">&quot;hello&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从以上两种情况来看似乎传参的代价都很低，那么应该如何选择呢，主要还是根据语义来做选择，如果你的实参是个左值自然选择第一种，如果是右值那自然是后者，如果你确定需要第二种那么使用<code>std::move</code>也是可以的</p></li></ul><h5 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h5><ul><li>由于我在传给callback的string是从buffer中复制构造来的，而不是仅仅像stringpiece那样使用，所以使用右值引用更合适，使用者会放心大胆的使用这个string，move之类的更不在话下了</li></ul><h5 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h5><ul><li>可以考虑使用StringPiece类似的技术，不过我感觉StringPiece在这个场景下并不好</li><li>关于std::move的原理其中涉及到了引用折叠这些比较复杂的概念，所以没有深入介绍</li><li>在模板中使用T&amp;&amp; 和实参中的&amp;&amp;还是不一样的，模板中的T&amp;&amp; 在转发参数时要保证不丢失T的信息(T可能是引用) 所以有涉及到了完美转发的概念，std::forward可以解决这个问题</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈 javascript 作用域</title>
      <link href="/2017/04/24/scope/"/>
      <url>/2017/04/24/scope/</url>
      
        <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><ul><li>本文将主要介绍javascript中作用域相关的问题，尽可能多的使用代码举例说明，尽量少涉及动态作用域相关</li></ul><h4 id="词法作用域-核心"><a href="#词法作用域-核心" class="headerlink" title="词法作用域(核心)"></a>词法作用域(核心)</h4><blockquote><p>javascript的作用域是词法作用域（静态作用域）, 不过像<code>eval</code>，<code>with</code>这些具有动态改变作用域的能力, 本文重点在于词法作用域</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">testLexicalScope</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// 由于当前scope中a是由最外层定义的，所以此处的a只能访问到最外层的a</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">b</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">2</span>;</span><br><span class="line">  <span class="title function_">testLexicalScope</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">b</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 另一个例子</span></span><br><span class="line"><span class="keyword">let</span> sameVar1 = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> sameVar2 = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">outerScope</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> sameVar1 = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">innerScope</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;current scope: sameVar1 is &quot;</span>, sameVar1); <span class="comment">// 当前的scope中最近的sameVar1值是2</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;current scope: sameVar2 is &quot;</span>, sameVar2);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">innerScope</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">outerScope</span>();</span><br><span class="line"><span class="comment">// current scope: sameVar1 is  2</span></span><br><span class="line"><span class="comment">// current scope: sameVar2 is  1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//另一个例子</span></span><br><span class="line"><span class="keyword">const</span> f1 = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(outVar);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> outVar = <span class="number">1</span>;</span><br><span class="line"><span class="title function_">f1</span>(); <span class="comment">// 1 why</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>只有在函数声明的时候才会遵循lexical scope的规则, 如果是函数表达式则取决于调用的时机</p></blockquote><h4 id="不同类型的作用域-如何创建scope"><a href="#不同类型的作用域-如何创建scope" class="headerlink" title="不同类型的作用域(如何创建scope)"></a>不同类型的作用域(如何创建scope)</h4><ul><li>函数作用域</li></ul><blockquote><p>属于这个函数的全部变量都可以在整个函数的范围内使用及复用<br>javascript 每个函数都会创建一个scope</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fScope</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> aStr = <span class="string">&quot;function&quot;</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(aStr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">fScope</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(aStr); <span class="comment">// ReferenceError: aStr is not defined</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>块级作用域({…})</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="literal">true</span>;</span><br><span class="line">&#123; <span class="comment">// 这里是使用let，将foo绑定到了&#123;&#125;这个块作用域中</span></span><br><span class="line">  <span class="keyword">let</span> foo = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">let</span> bar = <span class="string">&quot;cannot seen&quot;</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(foo); <span class="comment">// false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(bar); <span class="comment">// ReferenceError</span></span><br></pre></td></tr></table></figure><h4 id="var"><a href="#var" class="headerlink" title="var"></a><code>var</code></h4><ul><li>函数作用域中的<code>var</code>仍然遵循函数作用域相关的</li><li><code>var</code>中没有块级作用域</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="literal">true</span>;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">var</span> foo = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">var</span> bar = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo); <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(bar); <span class="comment">// bar</span></span><br></pre></td></tr></table></figure><h4 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h4><blockquote><p>变量和函数的所有声明多会在任何代码被执行前首先被处理（编译器找到这些变量与合适的作用域关联）</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">hoisting</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">hoisting</span>();</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>又是let</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">hoisting</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// 第一个let之上的区域叫做`temporal dead zone`</span></span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">hoisting</span>(); <span class="comment">// ReferenceError</span></span><br></pre></td></tr></table></figure><p><strong>函数声明的优先级会高于变量声明</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">foo</span>(); <span class="comment">// in the function</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;in the function&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li>关于块级作用域, 可用try{} catch(err) {&#x2F;<em>这里是块级作用域</em>&#x2F;}模拟，更多参考:《你不知道的javascript》上卷中3.4.2节</li><li>使用<code>let</code>，<code>const</code>是最佳实践</li><li>需要区分函数声明和函数表达式</li><li>尽量不要写有提升的代码（声明尽量提前）</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
