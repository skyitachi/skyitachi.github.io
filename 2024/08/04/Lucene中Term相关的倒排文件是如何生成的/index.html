<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Lucene中Term相关的倒排文件是如何生成的 | skyitachi&#39;s blog</title>
  <meta name="author" content="skyitachi">
  
  <meta name="description" content="一定要有输出">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="Lucene中Term相关的倒排文件是如何生成的"/>
  <meta property="og:site_name" content="skyitachi&#39;s blog"/>

  
    <meta property="og:image" content=""/>
  

  
    <link rel="alternative" href="/atom.xml" title="skyitachi&#39;s blog" type="application/atom+xml">
  
  
    <link href="/favicon.png" rel="icon">
  
  
  <link rel="stylesheet" href="/css/bootstrap.min.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/font-awesome.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/highlight.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/google-fonts.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/responsive.css" media="screen" type="text/css">  
  <link rel="stylesheet" href="/css/sidenav.css" media="screen" type="text/css">  
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->

  <script src="/js/jquery-2.0.3.min.js"></script>

  <!-- analytics -->
  

<meta name="generator" content="Hexo 7.1.1"></head>

<body id="body" data-spy="scroll" data-target=".toc">
  <div class="container" id="container">
	<div class="content">
	  <div class="page-header">		
  <h1><a class="brand" href="/">skyitachi&#39;s blog</a><span class="split"></span><span class="title">Lucene中Term相关的倒排文件是如何生成的</span><span class="date" id="title-date"><i class="fa fa-clock-o"></i> 2024-08-04</span></h1>
</div>		

<div class="row page">
  <!-- cols -->	
  
  

  
	<div class="col-md-12">
	  

	  <!-- content -->
	  <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Lucene中Term代表了一个原子粒度的索引和搜索单位，ES中keyword和text类型经过分词之后都会以Term的形式被Lucene索引并落入磁盘持久化，与Term相关的索引文件有Term Dictionary（.tim），Term Index(.tip), 还有与之关联的倒排索引相关的文件(.doc, .pos, .pay)，本文重点关注在如何将内存中已经生成好的Term相关的数据结构落入磁盘的这一过程.</p>
<p>本文以<a href="https://github.com/apache/lucene.git">Lucene</a> tag <code>releases/lucene/9.1.0</code> 代码为准, commit: 5b522487ba8e0f1002b50a136817ca037aec9686, 只关注posting list中docId的写入，freq, position和payload 将会忽略</p>
<h1 id="调用链路"><a href="#调用链路" class="headerlink" title="调用链路"></a>调用链路</h1><p><img src="/../../imgs/lucene.jpg" alt="function"></p>
<h1 id="相关源码分析"><a href="#相关源码分析" class="headerlink" title="相关源码分析"></a>相关源码分析</h1><p>主要分析<code>Lucene90BlockTreeTermsWriter</code>的写入过程, 核心函数是<code>TermsWriter.write</code></p>
<ol>
<li>Lucene90BlockTreeTermsWriter.write -&gt; TermsWriter.write</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Lucene90BlockTreeTermsWriter.TermsWriter.write</span></span><br><span class="line"><span class="comment">// TermsEnum 代表了这个Field关联的所有terms</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(BytesRef text, TermsEnum termsEnum, NormsProducer norms)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 首先写入倒排索引相关的问题, postingWriter是Lucene90PostingWriter的实例, 包括了docId和skip List相关的数据</span></span><br><span class="line">	<span class="type">BlockTermState</span> <span class="variable">state</span> <span class="operator">=</span> postingsWriter.writeTerm(text, termsEnum, docsSeen, norms);</span><br><span class="line">	<span class="keyword">if</span> (state != <span class="literal">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">assert</span> state.docFreq != <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">assert</span> fieldInfo.getIndexOptions() == IndexOptions.DOCS</span><br><span class="line">                || state.totalTermFreq &gt;= state.docFreq</span><br><span class="line">            : <span class="string">&quot;postingsWriter=&quot;</span> + postingsWriter;</span><br><span class="line">        pushTerm(text);</span><br><span class="line"></span><br><span class="line">        <span class="type">PendingTerm</span> <span class="variable">term</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PendingTerm</span>(text, state);</span><br><span class="line">        pending.add(term);</span><br><span class="line">        <span class="comment">// if (DEBUG) System.out.println(&quot;    add pending term = &quot; + text + &quot; pending.size()=&quot; +</span></span><br><span class="line">        <span class="comment">// pending.size());</span></span><br><span class="line"></span><br><span class="line">        sumDocFreq += state.docFreq;</span><br><span class="line">        sumTotalTermFreq += state.totalTermFreq;</span><br><span class="line">        numTerms++;</span><br><span class="line">        <span class="keyword">if</span> (firstPendingTerm == <span class="literal">null</span>) &#123;</span><br><span class="line">          firstPendingTerm = term;</span><br><span class="line">        &#125;</span><br><span class="line">        lastPendingTerm = term;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><code>PushPostingsWriterBase.writeTerm</code> 抽象了writeTerm的整体流程，<code>Lucene90PostingWriter</code> extends <code>PushPostingsWriterBase</code></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">final</span> BlockTermState <span class="title function_">writeTerm</span><span class="params">(</span></span><br><span class="line"><span class="params">      BytesRef term, TermsEnum termsEnum, FixedBitSet docsSeen, NormsProducer norms)</span></span><br><span class="line">      <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">	<span class="comment">// 本文不涉及</span></span><br><span class="line">    NumericDocValues normValues;</span><br><span class="line">    <span class="keyword">if</span> (fieldInfo.hasNorms() == <span class="literal">false</span>) &#123;</span><br><span class="line">      normValues = <span class="literal">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      normValues = norms.getNorms(fieldInfo);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 写入这个Term的一些初始化，包括lastDocId和skipList的初始化, 调用的实例方法是Lucene90PostingWriter.startTerm</span></span><br><span class="line">    startTerm(normValues);</span><br><span class="line">	<span class="comment">// 从term中取出对应的posting list的iterator，本文主要关注posting中的docId</span></span><br><span class="line">    postingsEnum = termsEnum.postings(postingsEnum, enumFlags);</span><br><span class="line">    <span class="keyword">assert</span> postingsEnum != <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">docFreq</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">long</span> <span class="variable">totalTermFreq</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">      <span class="type">int</span> <span class="variable">docID</span> <span class="operator">=</span> postingsEnum.nextDoc();</span><br><span class="line">      <span class="keyword">if</span> (docID == PostingsEnum.NO_MORE_DOCS) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      docFreq++;</span><br><span class="line">      docsSeen.set(docID);</span><br><span class="line">      <span class="type">int</span> freq;</span><br><span class="line">      <span class="keyword">if</span> (writeFreqs) &#123;</span><br><span class="line">        freq = postingsEnum.freq();</span><br><span class="line">        totalTermFreq += freq;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        freq = -<span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">	  <span class="comment">// posting相关的核心函数, Lucene90PostingsWriter.startDoc</span></span><br><span class="line">      startDoc(docID, freq);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (writePositions) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; freq; i++) &#123;</span><br><span class="line">          <span class="type">int</span> <span class="variable">pos</span> <span class="operator">=</span> postingsEnum.nextPosition();</span><br><span class="line">          <span class="type">BytesRef</span> <span class="variable">payload</span> <span class="operator">=</span> writePayloads ? postingsEnum.getPayload() : <span class="literal">null</span>;</span><br><span class="line">          <span class="type">int</span> startOffset;</span><br><span class="line">          <span class="type">int</span> endOffset;</span><br><span class="line">          <span class="keyword">if</span> (writeOffsets) &#123;</span><br><span class="line">            startOffset = postingsEnum.startOffset();</span><br><span class="line">            endOffset = postingsEnum.endOffset();</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            startOffset = -<span class="number">1</span>;</span><br><span class="line">            endOffset = -<span class="number">1</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          addPosition(pos, payload, startOffset, endOffset);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      finishDoc();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (docFreq == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="type">BlockTermState</span> <span class="variable">state</span> <span class="operator">=</span> newTermState();</span><br><span class="line">      state.docFreq = docFreq;</span><br><span class="line">      state.totalTermFreq = writeFreqs ? totalTermFreq : -<span class="number">1</span>;</span><br><span class="line">      finishTerm(state);</span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><code>Lucene90PostingsWriter.startDoc</code></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">startDoc</span><span class="params">(<span class="type">int</span> docID, <span class="type">int</span> termDocFreq)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"><span class="comment">// 为新的posting block创建(初始化)skipList </span></span><br><span class="line">   <span class="keyword">if</span> (lastBlockDocID != -<span class="number">1</span> &amp;&amp; docBufferUpto == <span class="number">0</span>) &#123;</span><br><span class="line">     skipWriter.bufferSkip(</span><br><span class="line">         lastBlockDocID,</span><br><span class="line">         competitiveFreqNormAccumulator,</span><br><span class="line">         docCount,</span><br><span class="line">         lastBlockPosFP,</span><br><span class="line">         lastBlockPayFP,</span><br><span class="line">         lastBlockPosBufferUpto,</span><br><span class="line">         lastBlockPayloadByteUpto);</span><br><span class="line">     competitiveFreqNormAccumulator.clear();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// posting 存储的docId 都是差值，且要求所有docId都是严格升序排列，隐含条件docId不会重复(相同Term在posting中只会出现一次)</span></span><br><span class="line">   <span class="keyword">final</span> <span class="type">int</span> <span class="variable">docDelta</span> <span class="operator">=</span> docID - lastDocID;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (docID &lt; <span class="number">0</span> || (docCount &gt; <span class="number">0</span> &amp;&amp; docDelta &lt;= <span class="number">0</span>)) &#123;</span><br><span class="line">     <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">CorruptIndexException</span>(</span><br><span class="line">         <span class="string">&quot;docs out of order (&quot;</span> + docID + <span class="string">&quot; &lt;= &quot;</span> + lastDocID + <span class="string">&quot; )&quot;</span>, docOut);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   docDeltaBuffer[docBufferUpto] = docDelta;</span><br><span class="line">   <span class="keyword">if</span> (writeFreqs) &#123;</span><br><span class="line">     freqBuffer[docBufferUpto] = termDocFreq;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">// block内docCount的计数</span></span><br><span class="line">   docBufferUpto++;</span><br><span class="line"><span class="comment">// 整体的docCount 计数</span></span><br><span class="line">   docCount++;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以128的BLOCK_SIZE写入docOut(.doc)文件中</span></span><br><span class="line">   <span class="keyword">if</span> (docBufferUpto == BLOCK_SIZE) &#123;</span><br><span class="line">     pforUtil.encode(docDeltaBuffer, docOut);</span><br><span class="line">     <span class="keyword">if</span> (writeFreqs) &#123;</span><br><span class="line">       pforUtil.encode(freqBuffer, docOut);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// <span class="doctag">NOTE:</span> don&#x27;t set docBufferUpto back to 0 here;</span></span><br><span class="line">     <span class="comment">// finishDoc will do so (because it needs to see that</span></span><br><span class="line">     <span class="comment">// the block was filled so it can save skip data)</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新lastDocID</span></span><br><span class="line">   lastDocID = docID;</span><br><span class="line">   lastPosition = <span class="number">0</span>;</span><br><span class="line">   lastStartOffset = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">   <span class="type">long</span> norm;</span><br><span class="line">   <span class="keyword">if</span> (fieldHasNorms) &#123;</span><br><span class="line">     <span class="type">boolean</span> <span class="variable">found</span> <span class="operator">=</span> norms.advanceExact(docID);</span><br><span class="line">     <span class="keyword">if</span> (found == <span class="literal">false</span>) &#123;</span><br><span class="line">       <span class="comment">// This can happen if indexing hits a problem after adding a doc to the</span></span><br><span class="line">       <span class="comment">// postings but before buffering the norm. Such documents are written</span></span><br><span class="line">       <span class="comment">// deleted and will go away on the first merge.</span></span><br><span class="line">       norm = <span class="number">1L</span>;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       norm = norms.longValue();</span><br><span class="line">       <span class="keyword">assert</span> norm != <span class="number">0</span> : docID;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     norm = <span class="number">1L</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   competitiveFreqNormAccumulator.add(writeFreqs ? termDocFreq : <span class="number">1</span>, norm);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><code>Lucene90PostingsWriter.finishDoc</code></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">finishDoc</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">   <span class="comment">// Since we don&#x27;t know df for current term, we had to buffer</span></span><br><span class="line">   <span class="comment">// those skip data for each block, and when a new doc comes,</span></span><br><span class="line">   <span class="comment">// write them to skip file.</span></span><br><span class="line">   <span class="keyword">if</span> (docBufferUpto == BLOCK_SIZE) &#123;</span><br><span class="line">  <span class="comment">// skip data是针对block的，block对应的docId 是该block中最大的docId</span></span><br><span class="line">     lastBlockDocID = lastDocID;</span><br><span class="line">     <span class="keyword">if</span> (posOut != <span class="literal">null</span>) &#123;</span><br><span class="line">       <span class="keyword">if</span> (payOut != <span class="literal">null</span>) &#123;</span><br><span class="line">         lastBlockPayFP = payOut.getFilePointer();</span><br><span class="line">       &#125;</span><br><span class="line">       lastBlockPosFP = posOut.getFilePointer();</span><br><span class="line">       lastBlockPosBufferUpto = posBufferUpto;</span><br><span class="line">       lastBlockPayloadByteUpto = payloadByteUpto;</span><br><span class="line">     &#125;</span><br><span class="line">     docBufferUpto = <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ol start="5">
<li><code>Lucene90PostingsWriter.finishTerm</code></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">finishTerm</span><span class="params">(BlockTermState _state)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">IntBlockTermState</span> <span class="variable">state</span> <span class="operator">=</span> (IntBlockTermState) _state;</span><br><span class="line">    <span class="keyword">assert</span> state.docFreq &gt; <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> wasteful we are counting this (counting # docs</span></span><br><span class="line">    <span class="comment">// for this term) in two places?</span></span><br><span class="line">    <span class="keyword">assert</span> state.docFreq == docCount : state.docFreq + <span class="string">&quot; vs &quot;</span> + docCount;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// docFreq == 1, don&#x27;t write the single docid/freq to a separate file along with a pointer to</span></span><br><span class="line">    <span class="comment">// it.</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> singletonDocID;</span><br><span class="line">    <span class="keyword">if</span> (state.docFreq == <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="comment">// pulse the singleton docid into the term dictionary, freq is implicitly totalTermFreq</span></span><br><span class="line">      singletonDocID = (<span class="type">int</span>) docDeltaBuffer[<span class="number">0</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      singletonDocID = -<span class="number">1</span>;</span><br><span class="line">      <span class="comment">// vInt encode the remaining doc deltas and freqs:</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; docBufferUpto; i++) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">docDelta</span> <span class="operator">=</span> (<span class="type">int</span>) docDeltaBuffer[i];</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">freq</span> <span class="operator">=</span> (<span class="type">int</span>) freqBuffer[i];</span><br><span class="line">        <span class="keyword">if</span> (!writeFreqs) &#123;</span><br><span class="line">		  <span class="comment">// 将最后一个未满BLOCK_SIZE的block的docDelta 写入到doc文件中</span></span><br><span class="line">          docOut.writeVInt(docDelta);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (freq == <span class="number">1</span>) &#123;</span><br><span class="line">          docOut.writeVInt((docDelta &lt;&lt; <span class="number">1</span>) | <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          docOut.writeVInt(docDelta &lt;&lt; <span class="number">1</span>);</span><br><span class="line">          docOut.writeVInt(freq);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">long</span> lastPosBlockOffset;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (writePositions) &#123;</span><br><span class="line">      <span class="comment">// totalTermFreq is just total number of positions(or payloads, or offsets)</span></span><br><span class="line">      <span class="comment">// associated with current term.</span></span><br><span class="line">      <span class="keyword">assert</span> state.totalTermFreq != -<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span> (state.totalTermFreq &gt; BLOCK_SIZE) &#123;</span><br><span class="line">        <span class="comment">// record file offset for last pos in last block</span></span><br><span class="line">        lastPosBlockOffset = posOut.getFilePointer() - posStartFP;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        lastPosBlockOffset = -<span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (posBufferUpto &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> should we send offsets/payloads to</span></span><br><span class="line">        <span class="comment">// .pay...?  seems wasteful (have to store extra</span></span><br><span class="line">        <span class="comment">// vLong for low (&lt; BLOCK_SIZE) DF terms = vast vast</span></span><br><span class="line">        <span class="comment">// majority)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// vInt encode the remaining positions/payloads/offsets:</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">lastPayloadLength</span> <span class="operator">=</span> -<span class="number">1</span>; <span class="comment">// force first payload length to be written</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">lastOffsetLength</span> <span class="operator">=</span> -<span class="number">1</span>; <span class="comment">// force first offset length to be written</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">payloadBytesReadUpto</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; posBufferUpto; i++) &#123;</span><br><span class="line">          <span class="keyword">final</span> <span class="type">int</span> <span class="variable">posDelta</span> <span class="operator">=</span> (<span class="type">int</span>) posDeltaBuffer[i];</span><br><span class="line">          <span class="keyword">if</span> (writePayloads) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">payloadLength</span> <span class="operator">=</span> (<span class="type">int</span>) payloadLengthBuffer[i];</span><br><span class="line">            <span class="keyword">if</span> (payloadLength != lastPayloadLength) &#123;</span><br><span class="line">              lastPayloadLength = payloadLength;</span><br><span class="line">              posOut.writeVInt((posDelta &lt;&lt; <span class="number">1</span>) | <span class="number">1</span>);</span><br><span class="line">              posOut.writeVInt(payloadLength);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              posOut.writeVInt(posDelta &lt;&lt; <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (payloadLength != <span class="number">0</span>) &#123;</span><br><span class="line">              posOut.writeBytes(payloadBytes, payloadBytesReadUpto, payloadLength);</span><br><span class="line">              payloadBytesReadUpto += payloadLength;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            posOut.writeVInt(posDelta);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (writeOffsets) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">delta</span> <span class="operator">=</span> (<span class="type">int</span>) offsetStartDeltaBuffer[i];</span><br><span class="line">            <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> (<span class="type">int</span>) offsetLengthBuffer[i];</span><br><span class="line">            <span class="keyword">if</span> (length == lastOffsetLength) &#123;</span><br><span class="line">              posOut.writeVInt(delta &lt;&lt; <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              posOut.writeVInt(delta &lt;&lt; <span class="number">1</span> | <span class="number">1</span>);</span><br><span class="line">              posOut.writeVInt(length);</span><br><span class="line">              lastOffsetLength = length;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (writePayloads) &#123;</span><br><span class="line">          <span class="keyword">assert</span> payloadBytesReadUpto == payloadByteUpto;</span><br><span class="line">          payloadByteUpto = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      lastPosBlockOffset = -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> skipOffset;</span><br><span class="line">	<span class="comment">// 写入skipList的data, 可以看到skipList的数据是写完posting之后再写入的</span></span><br><span class="line">    <span class="keyword">if</span> (docCount &gt; BLOCK_SIZE) &#123;</span><br><span class="line">      skipOffset = skipWriter.writeSkip(docOut) - docStartFP;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      skipOffset = -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    state.docStartFP = docStartFP;</span><br><span class="line">    state.posStartFP = posStartFP;</span><br><span class="line">    state.payStartFP = payStartFP;</span><br><span class="line">    state.singletonDocID = singletonDocID;</span><br><span class="line">    state.skipOffset = skipOffset;</span><br><span class="line">    state.lastPosBlockOffset = lastPosBlockOffset;</span><br><span class="line">    docBufferUpto = <span class="number">0</span>;</span><br><span class="line">    posBufferUpto = <span class="number">0</span>;</span><br><span class="line">    lastDocID = <span class="number">0</span>;</span><br><span class="line">    docCount = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li><code>Lucene90BlockTreeTermsWriter.TermsWriter.pushTerm</code></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pushTerm</span><span class="params">(BytesRef text)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">      <span class="comment">// Find common prefix between last term and current term:</span></span><br><span class="line">      <span class="type">int</span> <span class="variable">prefixLength</span> <span class="operator">=</span></span><br><span class="line">          Arrays.mismatch(</span><br><span class="line">              lastTerm.bytes(),</span><br><span class="line">              <span class="number">0</span>,</span><br><span class="line">              lastTerm.length(),</span><br><span class="line">              text.bytes,</span><br><span class="line">              text.offset,</span><br><span class="line">              text.offset + text.length);</span><br><span class="line">      <span class="keyword">if</span> (prefixLength == -<span class="number">1</span>) &#123; <span class="comment">// Only happens for the first term, if it is empty</span></span><br><span class="line">        <span class="keyword">assert</span> lastTerm.length() == <span class="number">0</span>;</span><br><span class="line">        prefixLength = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// if (DEBUG) System.out.println(&quot;  shared=&quot; + pos + &quot;  lastTerm.length=&quot; + lastTerm.length);</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// Close the &quot;abandoned&quot; suffix now:</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> lastTerm.length() - <span class="number">1</span>; i &gt;= prefixLength; i--) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// How many items on top of the stack share the current suffix</span></span><br><span class="line">        <span class="comment">// we are closing:</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">prefixTopSize</span> <span class="operator">=</span> pending.size() - prefixStarts[i];</span><br><span class="line">        <span class="keyword">if</span> (prefixTopSize &gt;= minItemsInBlock) &#123;</span><br><span class="line">          <span class="comment">// if (DEBUG) System.out.println(&quot;pushTerm i=&quot; + i + &quot; prefixTopSize=&quot; + prefixTopSize + &quot;</span></span><br><span class="line">          <span class="comment">// minItemsInBlock=&quot; + minItemsInBlock);</span></span><br><span class="line">		  <span class="comment">// 重点： 构建FST 相关的索引</span></span><br><span class="line">          writeBlocks(i + <span class="number">1</span>, prefixTopSize);</span><br><span class="line">          prefixStarts[i] -= prefixTopSize - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (prefixStarts.length &lt; text.length) &#123;</span><br><span class="line">        prefixStarts = ArrayUtil.grow(prefixStarts, text.length);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Init new tail:</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> prefixLength; i &lt; text.length; i++) &#123;</span><br><span class="line">        prefixStarts[i] = pending.size();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      lastTerm.copyBytes(text);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="7">
<li><code>Lucene90BlockTreeTermsWriter.TermsWriter.writeBlocks</code></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">writeBlocks</span><span class="params">(<span class="type">int</span> prefixLength, <span class="type">int</span> count)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">assert</span> count &gt; <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// if (DEBUG2) &#123;</span></span><br><span class="line">      <span class="comment">//  BytesRef br = new BytesRef(lastTerm.bytes());</span></span><br><span class="line">      <span class="comment">//  br.length = prefixLength;</span></span><br><span class="line">      <span class="comment">//  System.out.println(&quot;writeBlocks: seg=&quot; + segment + &quot; prefix=&quot; + brToString(br) + &quot; count=&quot;</span></span><br><span class="line">      <span class="comment">// + count);</span></span><br><span class="line">      <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// Root block better write all remaining pending entries:</span></span><br><span class="line">      <span class="keyword">assert</span> prefixLength &gt; <span class="number">0</span> || count == pending.size();</span><br><span class="line"></span><br><span class="line">      <span class="type">int</span> <span class="variable">lastSuffixLeadLabel</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// True if we saw at least one term in this block (we record if a block</span></span><br><span class="line">      <span class="comment">// only points to sub-blocks in the terms index so we can avoid seeking</span></span><br><span class="line">      <span class="comment">// to it when we are looking for a term):</span></span><br><span class="line">      <span class="type">boolean</span> <span class="variable">hasTerms</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">      <span class="type">boolean</span> <span class="variable">hasSubBlocks</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">      <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> pending.size() - count;</span><br><span class="line">      <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> pending.size();</span><br><span class="line">      <span class="type">int</span> <span class="variable">nextBlockStart</span> <span class="operator">=</span> start;</span><br><span class="line">      <span class="type">int</span> <span class="variable">nextFloorLeadLabel</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; end; i++) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">PendingEntry</span> <span class="variable">ent</span> <span class="operator">=</span> pending.get(i);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> suffixLeadLabel;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ent.isTerm) &#123;</span><br><span class="line">          <span class="type">PendingTerm</span> <span class="variable">term</span> <span class="operator">=</span> (PendingTerm) ent;</span><br><span class="line">          <span class="keyword">if</span> (term.termBytes.length == prefixLength) &#123;</span><br><span class="line">            <span class="comment">// Suffix is 0, i.e. prefix &#x27;foo&#x27; and term is</span></span><br><span class="line">            <span class="comment">// &#x27;foo&#x27; so the term has empty string suffix</span></span><br><span class="line">            <span class="comment">// in this block</span></span><br><span class="line">            <span class="keyword">assert</span> lastSuffixLeadLabel == -<span class="number">1</span></span><br><span class="line">                : <span class="string">&quot;i=&quot;</span> + i + <span class="string">&quot; lastSuffixLeadLabel=&quot;</span> + lastSuffixLeadLabel;</span><br><span class="line">            suffixLeadLabel = -<span class="number">1</span>;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            suffixLeadLabel = term.termBytes[prefixLength] &amp; <span class="number">0xff</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="type">PendingBlock</span> <span class="variable">block</span> <span class="operator">=</span> (PendingBlock) ent;</span><br><span class="line">          <span class="keyword">assert</span> block.prefix.length &gt; prefixLength;</span><br><span class="line">          suffixLeadLabel = block.prefix.bytes[block.prefix.offset + prefixLength] &amp; <span class="number">0xff</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// if (DEBUG) System.out.println(&quot;  i=&quot; + i + &quot; ent=&quot; + ent + &quot; suffixLeadLabel=&quot; +</span></span><br><span class="line">        <span class="comment">// suffixLeadLabel);</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (suffixLeadLabel != lastSuffixLeadLabel) &#123;</span><br><span class="line">          <span class="type">int</span> <span class="variable">itemsInBlock</span> <span class="operator">=</span> i - nextBlockStart;</span><br><span class="line">          <span class="keyword">if</span> (itemsInBlock &gt;= minItemsInBlock &amp;&amp; end - nextBlockStart &gt; maxItemsInBlock) &#123;</span><br><span class="line">            <span class="comment">// The count is too large for one block, so we must break it into &quot;floor&quot; blocks, where</span></span><br><span class="line">            <span class="comment">// we record</span></span><br><span class="line">            <span class="comment">// the leading label of the suffix of the first term in each floor block, so at search</span></span><br><span class="line">            <span class="comment">// time we can</span></span><br><span class="line">            <span class="comment">// jump to the right floor block.  We just use a naive greedy segmenter here: make a new</span></span><br><span class="line">            <span class="comment">// floor</span></span><br><span class="line">            <span class="comment">// block as soon as we have at least minItemsInBlock.  This is not always best: it often</span></span><br><span class="line">            <span class="comment">// produces</span></span><br><span class="line">            <span class="comment">// a too-small block as the final block:</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">isFloor</span> <span class="operator">=</span> itemsInBlock &lt; count;</span><br><span class="line">            newBlocks.add(</span><br><span class="line">                writeBlock(</span><br><span class="line">                    prefixLength,</span><br><span class="line">                    isFloor,</span><br><span class="line">                    nextFloorLeadLabel,</span><br><span class="line">                    nextBlockStart,</span><br><span class="line">                    i,</span><br><span class="line">                    hasTerms,</span><br><span class="line">                    hasSubBlocks));</span><br><span class="line"></span><br><span class="line">            hasTerms = <span class="literal">false</span>;</span><br><span class="line">            hasSubBlocks = <span class="literal">false</span>;</span><br><span class="line">            nextFloorLeadLabel = suffixLeadLabel;</span><br><span class="line">            nextBlockStart = i;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          lastSuffixLeadLabel = suffixLeadLabel;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ent.isTerm) &#123;</span><br><span class="line">          hasTerms = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          hasSubBlocks = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Write last block, if any:</span></span><br><span class="line">      <span class="keyword">if</span> (nextBlockStart &lt; end) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">itemsInBlock</span> <span class="operator">=</span> end - nextBlockStart;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isFloor</span> <span class="operator">=</span> itemsInBlock &lt; count;</span><br><span class="line">        newBlocks.add(</span><br><span class="line">            writeBlock(</span><br><span class="line">                prefixLength,</span><br><span class="line">                isFloor,</span><br><span class="line">                nextFloorLeadLabel,</span><br><span class="line">                nextBlockStart,</span><br><span class="line">                end,</span><br><span class="line">                hasTerms,</span><br><span class="line">                hasSubBlocks));</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">assert</span> newBlocks.isEmpty() == <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">      <span class="type">PendingBlock</span> <span class="variable">firstBlock</span> <span class="operator">=</span> newBlocks.get(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">assert</span> firstBlock.isFloor || newBlocks.size() == <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	  <span class="comment">// <span class="doctag">NOTE:</span> 每个block生成fst的index</span></span><br><span class="line">      firstBlock.compileIndex(newBlocks, scratchBytes, scratchIntsRef);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Remove slice from the top of the pending stack, that we just wrote:</span></span><br><span class="line">      pending.subList(pending.size() - count, pending.size()).clear();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Append new block</span></span><br><span class="line">      pending.add(firstBlock);</span><br><span class="line"></span><br><span class="line">      newBlocks.clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="8">
<li><code>Lucene90BlockTreeTermsWriter.TermsWriter.writeBlock</code><br>PendingBlock中记录了对应的在<code>.tim</code>文件中的位置(startFP), 后续会被FST索引到对应的value里</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> PendingBlock <span class="title function_">writeBlock</span><span class="params">(</span></span><br><span class="line"><span class="params">        <span class="type">int</span> prefixLength,</span></span><br><span class="line"><span class="params">        <span class="type">boolean</span> isFloor,</span></span><br><span class="line"><span class="params">        <span class="type">int</span> floorLeadLabel,</span></span><br><span class="line"><span class="params">        <span class="type">int</span> start,</span></span><br><span class="line"><span class="params">        <span class="type">int</span> end,</span></span><br><span class="line"><span class="params">        <span class="type">boolean</span> hasTerms,</span></span><br><span class="line"><span class="params">        <span class="type">boolean</span> hasSubBlocks)</span></span><br><span class="line">        <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">	<span class="comment">// ....</span></span><br><span class="line">	<span class="comment">// </span></span><br><span class="line">	<span class="keyword">if</span> (isLeafBlock) &#123;</span><br><span class="line">		subIndices = <span class="literal">null</span>;</span><br><span class="line">        <span class="type">StatsWriter</span> <span class="variable">statsWriter</span> <span class="operator">=</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">StatsWriter</span>(<span class="built_in">this</span>.statsWriter, fieldInfo.getIndexOptions() != IndexOptions.DOCS);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; end; i++) &#123;</span><br><span class="line">          <span class="type">PendingEntry</span> <span class="variable">ent</span> <span class="operator">=</span> pending.get(i);</span><br><span class="line">          <span class="keyword">assert</span> ent.isTerm : <span class="string">&quot;i=&quot;</span> + i;</span><br><span class="line"></span><br><span class="line">          <span class="type">PendingTerm</span> <span class="variable">term</span> <span class="operator">=</span> (PendingTerm) ent;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">assert</span> StringHelper.startsWith(term.termBytes, prefix) : term + <span class="string">&quot; prefix=&quot;</span> + prefix;</span><br><span class="line">          <span class="type">BlockTermState</span> <span class="variable">state</span> <span class="operator">=</span> term.state;</span><br><span class="line">          <span class="keyword">final</span> <span class="type">int</span> <span class="variable">suffix</span> <span class="operator">=</span> term.termBytes.length - prefixLength;</span><br><span class="line">          <span class="comment">// if (DEBUG2) &#123;</span></span><br><span class="line">          <span class="comment">//  BytesRef suffixBytes = new BytesRef(suffix);</span></span><br><span class="line">          <span class="comment">//  System.arraycopy(term.termBytes, prefixLength, suffixBytes.bytes, 0, suffix);</span></span><br><span class="line">          <span class="comment">//  suffixBytes.length = suffix;</span></span><br><span class="line">          <span class="comment">//  System.out.println(&quot;    write term suffix=&quot; + brToString(suffixBytes));</span></span><br><span class="line">          <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">          <span class="comment">// For leaf block we write suffix straight</span></span><br><span class="line">          suffixLengthsWriter.writeVInt(suffix);</span><br><span class="line">          suffixWriter.append(term.termBytes, prefixLength, suffix);</span><br><span class="line">          <span class="keyword">assert</span> floorLeadLabel == -<span class="number">1</span> || (term.termBytes[prefixLength] &amp; <span class="number">0xff</span>) &gt;= floorLeadLabel;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// Write term stats, to separate byte[] blob:</span></span><br><span class="line">          statsWriter.add(state.docFreq, state.totalTermFreq);</span><br><span class="line"></span><br><span class="line">          <span class="comment">// Write term meta data</span></span><br><span class="line">          postingsWriter.encodeTerm(metaWriter, fieldInfo, state, absolute);</span><br><span class="line">          absolute = <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		 <span class="comment">// Block has at least one prefix term or a sub block:</span></span><br><span class="line">        subIndices = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">StatsWriter</span> <span class="variable">statsWriter</span> <span class="operator">=</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">StatsWriter</span>(<span class="built_in">this</span>.statsWriter, fieldInfo.getIndexOptions() != IndexOptions.DOCS);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; end; i++) &#123;</span><br><span class="line">          <span class="type">PendingEntry</span> <span class="variable">ent</span> <span class="operator">=</span> pending.get(i);</span><br><span class="line">          <span class="keyword">if</span> (ent.isTerm) &#123;</span><br><span class="line">            <span class="type">PendingTerm</span> <span class="variable">term</span> <span class="operator">=</span> (PendingTerm) ent;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">assert</span> StringHelper.startsWith(term.termBytes, prefix) : term + <span class="string">&quot; prefix=&quot;</span> + prefix;</span><br><span class="line">            <span class="type">BlockTermState</span> <span class="variable">state</span> <span class="operator">=</span> term.state;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">suffix</span> <span class="operator">=</span> term.termBytes.length - prefixLength;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// For non-leaf block we borrow 1 bit to record</span></span><br><span class="line">            <span class="comment">// if entry is term or sub-block, and 1 bit to record if</span></span><br><span class="line">            <span class="comment">// it&#x27;s a prefix term.  Terms cannot be larger than ~32 KB</span></span><br><span class="line">            <span class="comment">// so we won&#x27;t run out of bits:</span></span><br><span class="line"></span><br><span class="line">            suffixLengthsWriter.writeVInt(suffix &lt;&lt; <span class="number">1</span>);</span><br><span class="line">            suffixWriter.append(term.termBytes, prefixLength, suffix);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Write term stats, to separate byte[] blob:</span></span><br><span class="line">            statsWriter.add(state.docFreq, state.totalTermFreq);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> now that terms dict &quot;sees&quot; these longs,</span></span><br><span class="line">            <span class="comment">// we can explore better column-stride encodings</span></span><br><span class="line">            <span class="comment">// to encode all long[0]s for this block at</span></span><br><span class="line">            <span class="comment">// once, all long[1]s, etc., e.g. using</span></span><br><span class="line">            <span class="comment">// Simple64.  Alternatively, we could interleave</span></span><br><span class="line">            <span class="comment">// stats + meta ... no reason to have them</span></span><br><span class="line">            <span class="comment">// separate anymore:</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// Write term meta data</span></span><br><span class="line">            postingsWriter.encodeTerm(metaWriter, fieldInfo, state, absolute);</span><br><span class="line">            absolute = <span class="literal">false</span>;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">PendingBlock</span> <span class="variable">block</span> <span class="operator">=</span> (PendingBlock) ent;</span><br><span class="line">            <span class="keyword">assert</span> StringHelper.startsWith(block.prefix, prefix);</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">suffix</span> <span class="operator">=</span> block.prefix.length - prefixLength;</span><br><span class="line">            <span class="keyword">assert</span> StringHelper.startsWith(block.prefix, prefix);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">assert</span> suffix &gt; <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// For non-leaf block we borrow 1 bit to record</span></span><br><span class="line">            <span class="comment">// if entry is term or sub-block:f</span></span><br><span class="line">            suffixLengthsWriter.writeVInt((suffix &lt;&lt; <span class="number">1</span>) | <span class="number">1</span>);</span><br><span class="line">            suffixWriter.append(block.prefix.bytes, prefixLength, suffix);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// if (DEBUG2) &#123;</span></span><br><span class="line">            <span class="comment">//  BytesRef suffixBytes = new BytesRef(suffix);</span></span><br><span class="line">            <span class="comment">//  System.arraycopy(block.prefix.bytes, prefixLength, suffixBytes.bytes, 0, suffix);</span></span><br><span class="line">            <span class="comment">//  suffixBytes.length = suffix;</span></span><br><span class="line">            <span class="comment">//  System.out.println(&quot;      write sub-block suffix=&quot; + brToString(suffixBytes) + &quot;</span></span><br><span class="line">            <span class="comment">// subFP=&quot; + block.fp + &quot; subCode=&quot; + (startFP-block.fp) + &quot; floor=&quot; + block.isFloor);</span></span><br><span class="line">            <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">assert</span> floorLeadLabel == -<span class="number">1</span></span><br><span class="line">                    || (block.prefix.bytes[prefixLength] &amp; <span class="number">0xff</span>) &gt;= floorLeadLabel</span><br><span class="line">                : <span class="string">&quot;floorLeadLabel=&quot;</span></span><br><span class="line">                    + floorLeadLabel</span><br><span class="line">                    + <span class="string">&quot; suffixLead=&quot;</span></span><br><span class="line">                    + (block.prefix.bytes[prefixLength] &amp; <span class="number">0xff</span>);</span><br><span class="line">            <span class="keyword">assert</span> block.fp &lt; startFP;</span><br><span class="line"></span><br><span class="line">            suffixLengthsWriter.writeVLong(startFP - block.fp);</span><br><span class="line">            subIndices.add(block.index);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        statsWriter.finish();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">assert</span> subIndices.size() != <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">	<span class="comment">// Write term meta data byte[] blob</span></span><br><span class="line">	termsOut.writeVInt((<span class="type">int</span>) metaWriter.size());</span><br><span class="line">	<span class="comment">// 写入到`tim`文件</span></span><br><span class="line">	metaWriter.copyTo(termsOut);</span><br><span class="line">	metaWriter.reset();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="9">
<li><code>Lucene90PostingWriter.encodeTerm</code></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里的DataOutput 指的是ByteBuffersDataOutput, 一个内存结构, 这里记录了每个Term 倒排索引对应的文件位置相关, 最终会被写入`.tim`文件</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">encodeTerm</span><span class="params">(</span></span><br><span class="line"><span class="params">      DataOutput out, FieldInfo fieldInfo, BlockTermState _state, <span class="type">boolean</span> absolute)</span></span><br><span class="line">      <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">IntBlockTermState</span> <span class="variable">state</span> <span class="operator">=</span> (IntBlockTermState) _state;</span><br><span class="line">    <span class="keyword">if</span> (absolute) &#123;</span><br><span class="line">      lastState = emptyState;</span><br><span class="line">      <span class="keyword">assert</span> lastState.docStartFP == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (lastState.singletonDocID != -<span class="number">1</span></span><br><span class="line">        &amp;&amp; state.singletonDocID != -<span class="number">1</span></span><br><span class="line">        &amp;&amp; state.docStartFP == lastState.docStartFP) &#123;</span><br><span class="line">      <span class="comment">// With runs of rare values such as ID fields, the increment of pointers in the docs file is</span></span><br><span class="line">      <span class="comment">// often 0.</span></span><br><span class="line">      <span class="comment">// Furthermore some ID schemes like auto-increment IDs or Flake IDs are monotonic, so we</span></span><br><span class="line">      <span class="comment">// encode the delta</span></span><br><span class="line">      <span class="comment">// between consecutive doc IDs to save space.</span></span><br><span class="line">      <span class="keyword">final</span> <span class="type">long</span> <span class="variable">delta</span> <span class="operator">=</span> (<span class="type">long</span>) state.singletonDocID - lastState.singletonDocID;</span><br><span class="line">      out.writeVLong((BitUtil.zigZagEncode(delta) &lt;&lt; <span class="number">1</span>) | <span class="number">0x01</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      out.writeVLong((state.docStartFP - lastState.docStartFP) &lt;&lt; <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">if</span> (state.singletonDocID != -<span class="number">1</span>) &#123;</span><br><span class="line">        out.writeVInt(state.singletonDocID);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (writePositions) &#123;</span><br><span class="line">      out.writeVLong(state.posStartFP - lastState.posStartFP);</span><br><span class="line">      <span class="keyword">if</span> (writePayloads || writeOffsets) &#123;</span><br><span class="line">        out.writeVLong(state.payStartFP - lastState.payStartFP);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (writePositions) &#123;</span><br><span class="line">      <span class="keyword">if</span> (state.lastPosBlockOffset != -<span class="number">1</span>) &#123;</span><br><span class="line">        out.writeVLong(state.lastPosBlockOffset);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (state.skipOffset != -<span class="number">1</span>) &#123;</span><br><span class="line">      out.writeVLong(state.skipOffset);</span><br><span class="line">    &#125;</span><br><span class="line">    lastState = state;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<ol start="10">
<li><code>Lucene90BlockTreeTermsWriter.TermsWriter.finish</code></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">finish</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">     <span class="keyword">if</span> (numTerms &gt; <span class="number">0</span>) &#123;</span><br><span class="line">       <span class="comment">// if (DEBUG) System.out.println(&quot;BTTW: finish prefixStarts=&quot; +</span></span><br><span class="line">       <span class="comment">// Arrays.toString(prefixStarts));</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">// Add empty term to force closing of all final blocks:</span></span><br><span class="line">       pushTerm(<span class="keyword">new</span> <span class="title class_">BytesRef</span>());</span><br><span class="line"></span><br><span class="line">       <span class="comment">// <span class="doctag">TODO:</span> if pending.size() is already 1 with a non-zero prefix length</span></span><br><span class="line">       <span class="comment">// we can save writing a &quot;degenerate&quot; root block, but we have to</span></span><br><span class="line">       <span class="comment">// fix all the places that assume the root block&#x27;s prefix is the empty string:</span></span><br><span class="line">       pushTerm(<span class="keyword">new</span> <span class="title class_">BytesRef</span>());</span><br><span class="line">	<span class="comment">// 这里完成将所有Term生成FST的索引, pending.get(0)是root的block，其索引包含了整个pending的Terms</span></span><br><span class="line">       writeBlocks(<span class="number">0</span>, pending.size());</span><br><span class="line"></span><br><span class="line">       <span class="comment">// We better have one final &quot;root&quot; block:</span></span><br><span class="line">       <span class="keyword">assert</span> pending.size() == <span class="number">1</span> &amp;&amp; !pending.get(<span class="number">0</span>).isTerm</span><br><span class="line">           : <span class="string">&quot;pending.size()=&quot;</span> + pending.size() + <span class="string">&quot; pending=&quot;</span> + pending;</span><br><span class="line">       <span class="keyword">final</span> <span class="type">PendingBlock</span> <span class="variable">root</span> <span class="operator">=</span> (PendingBlock) pending.get(<span class="number">0</span>);</span><br><span class="line">       <span class="keyword">assert</span> root.prefix.length == <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">final</span> <span class="type">BytesRef</span> <span class="variable">rootCode</span> <span class="operator">=</span> root.index.getEmptyOutput();</span><br><span class="line">       <span class="keyword">assert</span> rootCode != <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">       <span class="type">ByteBuffersDataOutput</span> <span class="variable">metaOut</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteBuffersDataOutput</span>();</span><br><span class="line">       fields.add(metaOut);</span><br><span class="line"></span><br><span class="line">       metaOut.writeVInt(fieldInfo.number);</span><br><span class="line">       metaOut.writeVLong(numTerms);</span><br><span class="line">       metaOut.writeVInt(rootCode.length);</span><br><span class="line">       metaOut.writeBytes(rootCode.bytes, rootCode.offset, rootCode.length);</span><br><span class="line">       <span class="keyword">assert</span> fieldInfo.getIndexOptions() != IndexOptions.NONE;</span><br><span class="line">       <span class="keyword">if</span> (fieldInfo.getIndexOptions() != IndexOptions.DOCS) &#123;</span><br><span class="line">         metaOut.writeVLong(sumTotalTermFreq);</span><br><span class="line">       &#125;</span><br><span class="line">       metaOut.writeVLong(sumDocFreq);</span><br><span class="line">       metaOut.writeVInt(docsSeen.cardinality());</span><br><span class="line">       writeBytesRef(metaOut, <span class="keyword">new</span> <span class="title class_">BytesRef</span>(firstPendingTerm.termBytes));</span><br><span class="line">       writeBytesRef(metaOut, <span class="keyword">new</span> <span class="title class_">BytesRef</span>(lastPendingTerm.termBytes));</span><br><span class="line">       metaOut.writeVLong(indexOut.getFilePointer());</span><br><span class="line">       <span class="comment">// Write FST to index</span></span><br><span class="line">	<span class="comment">// 这里的indexOut就是&quot;.tip&quot;</span></span><br><span class="line">       root.index.save(metaOut, indexOut);</span><br><span class="line">       <span class="comment">// System.out.println(&quot;  write FST &quot; + indexStartFP + &quot; field=&quot; + fieldInfo.name);</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">/*</span></span><br><span class="line"><span class="comment">       if (DEBUG) &#123;</span></span><br><span class="line"><span class="comment">         final String dotFileName = segment + &quot;_&quot; + fieldInfo.name + &quot;.dot&quot;;</span></span><br><span class="line"><span class="comment">         Writer w = new OutputStreamWriter(new FileOutputStream(dotFileName));</span></span><br><span class="line"><span class="comment">         Util.toDot(root.index, w, false, false);</span></span><br><span class="line"><span class="comment">         System.out.println(&quot;SAVED to &quot; + dotFileName);</span></span><br><span class="line"><span class="comment">         w.close();</span></span><br><span class="line"><span class="comment">       &#125;</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line"></span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="keyword">assert</span> sumTotalTermFreq == <span class="number">0</span></span><br><span class="line">           || fieldInfo.getIndexOptions() == IndexOptions.DOCS &amp;&amp; sumTotalTermFreq == -<span class="number">1</span>;</span><br><span class="line">       <span class="keyword">assert</span> sumDocFreq == <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">assert</span> docsSeen.cardinality() == <span class="number">0</span>;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Lucene整体倒排索引设计还是非常复杂的，这里仅仅是将内存的数据写入到磁盘就需要这么多步骤，同时Lucene保持了很好的抽象，不同格式的索引数据只要涉及实现对应的接口即可，通过codec的方式嵌入到引擎中.</p>
<p>我的问题是如何评估这些设计对性能的影响，FST的涉及需要如此复杂吗，只是为了定位Term对应的倒排表位置，有没有其他可以使用的数据结构呢, 在后续的学习过程中还是要多加深入了解和思考，希望能得到更好的答案.</p>
	  

	  <div>
  		<center>
		  <div class="pagination">
<ul class="pagination">
	
	
	
	
	
	
		
			
			
		
	
		
			
			
			
		
			
		
	
		
			
		
	
		
			
		
	
		
			
		
	
		
			
		
	
		
			
		
	
		
			
		
	
		
			
		
	
	
	
		<li class="prev disabled"><a><i class="fa fa-arrow-circle-o-left"></i>prev</a></li>
	
	<li><a href="/"><i class="fa fa-archive"></i>Home</a></li>
	
		<li class="next"><a href="/2024/07/26/java%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/" class="alignright next">next<i class="fa fa-arrow-circle-o-right"></i></a></li>
	
</ul>
</div>

		</center>
	  </div>
	  
	</div> <!-- col-md-9/col-md-12 -->
	
  </div><!-- row -->

	</div>
  </div>
  <div class="container-narrow">
	<footer> <p>
  &copy; 2024 skyitachi
  
      with help from <a href="http://zespia.tw/hexo/" target="_blank">Hexo</a> and <a href="http://getbootstrap.com/" target="_blank">Twitter Bootstrap</a>. Theme by <a href="http://github.com/wzpan/hexo-theme-wixo/">Wixo</a>.    
</p> </footer>
  </div> <!-- container-narrow -->
  
<a id="gotop" href="#">   
  <span>▲</span> 
</a>

<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/bootstrap.min.js"></script>
<script src="/js/jquery.tableofcontents.min.js"></script>
<script src="/js/tocgenerator.min.js"></script>
<script src="/js/main.js"></script>
<script src="/js/search.js"></script> 




<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>



   <script type="text/javascript">      
     var search_path = "search.xml";
	 if (search_path.length == 0) {
	 	search_path = "search.xml";
	 }
	 var path = "/" + search_path;
     searchFunc(path, 'local-search-input', 'local-search-result');
   </script>


</body>
</html>
