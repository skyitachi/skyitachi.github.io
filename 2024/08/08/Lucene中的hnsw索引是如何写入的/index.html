<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Lucene中的HNSW索引是如何写入的 | skyitachi&#39;s blog</title>
  <meta name="author" content="skyitachi">
  
  <meta name="description" content="一定要有输出">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="Lucene中的HNSW索引是如何写入的"/>
  <meta property="og:site_name" content="skyitachi&#39;s blog"/>

  
    <meta property="og:image" content=""/>
  

  
    <link rel="alternative" href="/atom.xml" title="skyitachi&#39;s blog" type="application/atom+xml">
  
  
    <link href="/favicon.png" rel="icon">
  
  
  <link rel="stylesheet" href="/css/bootstrap.min.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/font-awesome.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/highlight.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/google-fonts.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/responsive.css" media="screen" type="text/css">  
  <link rel="stylesheet" href="/css/sidenav.css" media="screen" type="text/css">  
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->

  <script src="/js/jquery-2.0.3.min.js"></script>

  <!-- analytics -->
  

<meta name="generator" content="Hexo 7.1.1"></head>

<body id="body" data-spy="scroll" data-target=".toc">
  <div class="container" id="container">
	<div class="content">
	  <div class="page-header">		
  <h1><a class="brand" href="/">skyitachi&#39;s blog</a><span class="split"></span><span class="title">Lucene中的HNSW索引是如何写入的</span><span class="date" id="title-date"><i class="fa fa-clock-o"></i> 2024-08-08</span></h1>
</div>		

<div class="row page">
  <!-- cols -->	
  
  

  
	<div class="col-md-12">
	  

	  <!-- content -->
	  <h1 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h1><ul>
<li>梳理IndexWriter.addDocuments 和 IndexWriter.commit的调用栈</li>
<li>梳理向量索引在Lucene中是如何被存储的主要调用路径，包括如何原始向量如何保存到内存和文件，HNSW索引的构建以及如何持久化的</li>
<li>Lucene在处理Segment Merge的过程中是如何处理HNSW索引的</li>
</ul>
<h1 id="调用栈"><a href="#调用栈" class="headerlink" title="调用栈"></a>调用栈</h1><p><img src="/../../imgs/lucene_addDocuments_and_commit.svg" alt="stack"></p>
<h2 id="调用栈对应的示例"><a href="#调用栈对应的示例" class="headerlink" title="调用栈对应的示例"></a>调用栈对应的示例</h2><p>对应的Lucene版本: releases&#x2F;lucene&#x2F;9.9.0</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Path</span> <span class="variable">docPath</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;data/lucene_knn_demo&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (Files.exists(docPath)) &#123;</span><br><span class="line">	<span class="type">String</span> <span class="variable">absPath</span> <span class="operator">=</span> docPath.toAbsolutePath().toString();</span><br><span class="line">	<span class="type">File</span> <span class="variable">directory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(absPath);</span><br><span class="line">	FileUtils.deleteDirectory(directory);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">Directory</span> <span class="variable">directory</span> <span class="operator">=</span> FSDirectory.open(docPath);</span><br><span class="line"><span class="type">IndexWriterConfig</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IndexWriterConfig</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">FileOutputStream</span> <span class="variable">output</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;lucene_knn.log&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">InfoStream</span> <span class="variable">customInfoStream</span> <span class="operator">=</span>  <span class="keyword">new</span> <span class="title class_">PrintStreamInfoStream</span>(<span class="keyword">new</span> <span class="title class_">PrintStream</span>(output));</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;IW Component is enabled: &quot;</span> + customInfoStream.isEnabled(<span class="string">&quot;IW&quot;</span>));</span><br><span class="line">config.setInfoStream(customInfoStream);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">config.setUseCompoundFile(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">IndexWriter</span> <span class="variable">indexWriter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IndexWriter</span>(directory, config);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">10000</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">dim</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line">List&lt;Document&gt; docs = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">	<span class="type">Document</span> <span class="variable">doc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Document</span>();</span><br><span class="line">	doc.add(<span class="keyword">new</span> <span class="title class_">KeywordField</span>(<span class="string">&quot;id&quot;</span>, Integer.toString(i), Field.Store.YES));</span><br><span class="line">	doc.add(<span class="keyword">new</span> <span class="title class_">KnnFloatVectorField</span>(<span class="string">&quot;fvecs&quot;</span>, generateFVector(dim)));</span><br><span class="line">	docs.add(doc);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">indexWriter.addDocuments(docs);</span><br><span class="line">indexWriter.commit();</span><br><span class="line"></span><br><span class="line">System.out.printf(<span class="string">&quot;%d vectors consumes: %d ms\n&quot;</span>, count, System.currentTimeMillis() - start);</span><br><span class="line">start = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line"><span class="comment">//        indexWriter.forceMerge(1);</span></span><br><span class="line"><span class="comment">//        System.out.printf(&quot;forceMerge consumes: %d ms\n&quot;, System.currentTimeMillis() - start);</span></span><br><span class="line"></span><br><span class="line">indexWriter.close();</span><br></pre></td></tr></table></figure>

<h1 id="Lucene如何在内存中存储向量的"><a href="#Lucene如何在内存中存储向量的" class="headerlink" title="Lucene如何在内存中存储向量的"></a>Lucene如何在内存中存储向量的</h1><p>向量相关的分为两个部分，一个是原始向量，一个是向量索引</p>
<h2 id="内存中向量的存储"><a href="#内存中向量的存储" class="headerlink" title="内存中向量的存储"></a>内存中向量的存储</h2><h3 id="原始向量"><a href="#原始向量" class="headerlink" title="原始向量"></a>原始向量</h3><p>从调用链路上看，<code>indexChain.indexVectorValue</code> 涉及到了向量相关的存储，根据向量类型的(Float32或者Byte), 本文例子中的使用Float32数组，最终会调用<code>Lucene99FlatVectorsWriter.FieldWriter.addValue</code>, 下面详细分析一下源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addValue</span><span class="params">(<span class="type">int</span> docID, T vectorValue)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">	<span class="keyword">if</span> (docID == lastDocID) &#123;</span><br><span class="line">	<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(</span><br><span class="line">		<span class="string">&quot;VectorValuesField \&quot;&quot;</span></span><br><span class="line">			+ fieldInfo.name</span><br><span class="line">			+ <span class="string">&quot;\&quot; appears more than once in this document (only one value is allowed per field)&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">assert</span> docID &gt; lastDocID;</span><br><span class="line">	<span class="comment">// 首先从IndexableField里的VectorValues复制一份原始向量</span></span><br><span class="line">	<span class="type">T</span> <span class="variable">copy</span> <span class="operator">=</span> copyValue(vectorValue);</span><br><span class="line">	docsWithField.add(docID);</span><br><span class="line">	<span class="comment">// vectors 是List&lt;T&gt; 对象，说明原始向量在内存中直接存入到一个List中</span></span><br><span class="line">	vectors.add(copy);</span><br><span class="line">	lastDocID = docID;</span><br><span class="line">	<span class="keyword">if</span> (indexingDelegate != <span class="literal">null</span>) &#123;</span><br><span class="line">		<span class="comment">// 这里就是索引相关的计算</span></span><br><span class="line">		indexingDelegate.addValue(docID, copy);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><p>内存中HNSW索引的构建的入口是<code>indexingDelegate.addValue</code>, 在本文中<code>indexingDelegate</code>就是<code>Lucene99HnswVectorsWriter.FieldWriter</code>, 下面简要分析一下其源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addValue</span><span class="params">(<span class="type">int</span> docID, T vectorValue)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">	<span class="keyword">if</span> (docID == lastDocID) &#123;</span><br><span class="line">	<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(</span><br><span class="line">		<span class="string">&quot;VectorValuesField \&quot;&quot;</span></span><br><span class="line">			+ fieldInfo.name</span><br><span class="line">			+ <span class="string">&quot;\&quot; appears more than once in this document (only one value is allowed per field)&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">assert</span> docID &gt; lastDocID;</span><br><span class="line">	<span class="comment">// 原始向量又被存储了一次</span></span><br><span class="line">	vectors.add(vectorValue);</span><br><span class="line">	docsWithField.add(docID);</span><br><span class="line">	<span class="comment">// 构建索引</span></span><br><span class="line">	hnswGraphBuilder.addGraphNode(node);</span><br><span class="line">	node++;</span><br><span class="line">	lastDocID = docID;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>HNSW索引是如何在内存中表示的，Lucene使用了<code>OnHeapHnswGraph</code>表示了索引相关信息的存储（主要是节点之间的连接信息）.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 省略了其他一些字段</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">OnHeapHnswGraph</span> <span class="keyword">extends</span> <span class="title class_">HnswGraph</span> <span class="keyword">implements</span> <span class="title class_">Accountable</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> AtomicReference&lt;EntryNode&gt; entryNode; <span class="comment">// 表示了HNSW中整个索引的entryPoint</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// the internal graph representation where the first dimension is node id and second dimension is</span></span><br><span class="line">  <span class="comment">// level</span></span><br><span class="line">  <span class="comment">// e.g. graph[1][2] is all the neighbours of node 1 at level 2</span></span><br><span class="line">  <span class="comment">// 索引中节点的邻接信息</span></span><br><span class="line">  <span class="keyword">private</span> NeighborArray[][] graph;</span><br><span class="line"></span><br><span class="line">  OnHeapHnswGraph(<span class="type">int</span> M, <span class="type">int</span> numNodes) &#123;</span><br><span class="line">    <span class="built_in">this</span>.entryNode = <span class="keyword">new</span> <span class="title class_">AtomicReference</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">EntryNode</span>(-<span class="number">1</span>, <span class="number">1</span>));</span><br><span class="line">    <span class="comment">// Neighbours&#x27; size on upper levels (nsize) and level 0 (nsize0)</span></span><br><span class="line">    <span class="comment">// We allocate extra space for neighbours, but then prune them to keep allowed maximum</span></span><br><span class="line">    <span class="built_in">this</span>.nsize = M + <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">this</span>.nsize0 = (M * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">    noGrowth = numNodes != -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (noGrowth == <span class="literal">false</span>) &#123;</span><br><span class="line">      numNodes = INIT_SIZE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.graph = <span class="keyword">new</span> <span class="title class_">NeighborArray</span>[numNodes][];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="文件中向量的存储"><a href="#文件中向量的存储" class="headerlink" title="文件中向量的存储"></a>文件中向量的存储</h2><p>向量相关的索引文件涉及四种</p>
<ul>
<li><code>*.vec</code> 存储原始向量</li>
<li><code>*.vemf</code> 原始向量的meta文件</li>
<li><code>*.vex</code> 向量索引文件, Lucene中目前用的HNSW索引</li>
<li><code>*.vem</code> 向量索引文件的meta文件</li>
</ul>
<ol>
<li>向量相关的文件写入（flush）是由<code>Lucene99HnswVectorsWriter.flush</code>实现的</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">flush</span><span class="params">(<span class="type">int</span> maxDoc, Sorter.DocMap sortMap)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">	<span class="comment">// 写入原始向量</span></span><br><span class="line">	flatVectorWriter.flush(maxDoc, sortMap);</span><br><span class="line">	<span class="keyword">for</span> (FieldWriter&lt;?&gt; field : fields) &#123;</span><br><span class="line">		<span class="keyword">if</span> (sortMap == <span class="literal">null</span>) &#123;</span><br><span class="line">			writeField(field);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			writeSortingField(field, sortMap);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>原始向量的写入 <code>Lucene99FlatVectorsWriter.flush</code></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">flush</span><span class="params">(<span class="type">int</span> maxDoc, Sorter.DocMap sortMap)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">	<span class="keyword">for</span> (FieldWriter&lt;?&gt; field : fields) &#123;</span><br><span class="line">		<span class="keyword">if</span> (sortMap == <span class="literal">null</span>) &#123;</span><br><span class="line">			writeField(field, maxDoc);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			writeSortingField(field, maxDoc, sortMap);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">writeField</span><span class="params">(FieldWriter&lt;?&gt; fieldData, <span class="type">int</span> maxDoc)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// write vector values</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">vectorDataOffset</span> <span class="operator">=</span> vectorData.alignFilePointer(Float.BYTES);</span><br><span class="line">    <span class="keyword">switch</span> (fieldData.fieldInfo.getVectorEncoding()) &#123;</span><br><span class="line">      <span class="keyword">case</span> BYTE:</span><br><span class="line">        writeByteVectors(fieldData);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> FLOAT32:</span><br><span class="line">		<span class="comment">// 写入到原始向量文件里</span></span><br><span class="line">        writeFloat32Vectors(fieldData);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">long</span> <span class="variable">vectorDataLength</span> <span class="operator">=</span> vectorData.getFilePointer() - vectorDataOffset;</span><br><span class="line"></span><br><span class="line">    writeMeta(</span><br><span class="line">        fieldData.fieldInfo, maxDoc, vectorDataOffset, vectorDataLength, fieldData.docsWithField);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">writeFloat32Vectors</span><span class="params">(FieldWriter&lt;?&gt; fieldData)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span></span><br><span class="line">        ByteBuffer.allocate(fieldData.dim * Float.BYTES).order(ByteOrder.LITTLE_ENDIAN);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 将之前存在内存中的vector的list写入到vectorData对应的文件里</span></span><br><span class="line">    <span class="keyword">for</span> (Object v : fieldData.vectors) &#123;</span><br><span class="line">      buffer.asFloatBuffer().put((<span class="type">float</span>[]) v);</span><br><span class="line">      vectorData.writeBytes(buffer.array(), buffer.array().length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>向量索引相关的写入</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 每个字段对应向量索引的写入</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">writeField</span><span class="params">(FieldWriter&lt;?&gt; fieldData)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">	<span class="comment">// write graph</span></span><br><span class="line">	<span class="type">long</span> <span class="variable">vectorIndexOffset</span> <span class="operator">=</span> vectorIndex.getFilePointer();</span><br><span class="line">	<span class="type">OnHeapHnswGraph</span> <span class="variable">graph</span> <span class="operator">=</span> fieldData.getGraph();</span><br><span class="line">	<span class="type">int</span>[][] graphLevelNodeOffsets = writeGraph(graph);</span><br><span class="line">	<span class="comment">// 向量索引的长度</span></span><br><span class="line">	<span class="type">long</span> <span class="variable">vectorIndexLength</span> <span class="operator">=</span> vectorIndex.getFilePointer() - vectorIndexOffset;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// graphLevelNodeOffsets 经过编码后会写入到vectorIndexOutput中，而不是meta文件中</span></span><br><span class="line">	writeMeta(</span><br><span class="line">		fieldData.fieldInfo,</span><br><span class="line">		vectorIndexOffset,</span><br><span class="line">		vectorIndexLength,</span><br><span class="line">		fieldData.docsWithField.cardinality(),</span><br><span class="line">		graph,</span><br><span class="line">		graphLevelNodeOffsets);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// hnsw节点连接信息的写入</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span>[][] writeGraph(OnHeapHnswGraph graph) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">	<span class="keyword">if</span> (graph == <span class="literal">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">	<span class="comment">// write vectors&#x27; neighbours on each level into the vectorIndex file</span></span><br><span class="line">	<span class="type">int</span> <span class="variable">countOnLevel0</span> <span class="operator">=</span> graph.size();</span><br><span class="line">	<span class="type">int</span>[][] offsets = <span class="keyword">new</span> <span class="title class_">int</span>[graph.numLevels()][];</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">level</span> <span class="operator">=</span> <span class="number">0</span>; level &lt; graph.numLevels(); level++) &#123;</span><br><span class="line">		<span class="comment">// graph.getNodesOnLevel获取到每个level出现的node数组</span></span><br><span class="line">		<span class="type">int</span>[] sortedNodes = NodesIterator.getSortedNodes(graph.getNodesOnLevel(level));</span><br><span class="line">		offsets[level] = <span class="keyword">new</span> <span class="title class_">int</span>[sortedNodes.length];</span><br><span class="line">		<span class="type">int</span> <span class="variable">nodeOffsetId</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> node : sortedNodes) &#123;</span><br><span class="line">			<span class="comment">// 根据node大小获取该node在level层级的节点连接信息</span></span><br><span class="line">			<span class="type">NeighborArray</span> <span class="variable">neighbors</span> <span class="operator">=</span> graph.getNeighbors(level, node);</span><br><span class="line">			<span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> neighbors.size();</span><br><span class="line">			<span class="comment">// Write size in VInt as the neighbors list is typically small</span></span><br><span class="line">			<span class="type">long</span> <span class="variable">offsetStart</span> <span class="operator">=</span> vectorIndex.getFilePointer();</span><br><span class="line">			<span class="comment">// 写入这个节点对应的连接数</span></span><br><span class="line">			vectorIndex.writeVInt(size);</span><br><span class="line">			<span class="comment">// Destructively modify; it&#x27;s ok we are discarding it after this</span></span><br><span class="line">			<span class="type">int</span>[] nnodes = neighbors.node();</span><br><span class="line">			<span class="comment">// 根据node大小做升序排序，方便后面做差值压缩编码</span></span><br><span class="line">			Arrays.sort(nnodes, <span class="number">0</span>, size);</span><br><span class="line">			<span class="comment">// Now that we have sorted, do delta encoding to minimize the required bits to store the</span></span><br><span class="line">			<span class="comment">// information</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> size - <span class="number">1</span>; i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">				<span class="keyword">assert</span> nnodes[i] &lt; countOnLevel0 : <span class="string">&quot;node too large: &quot;</span> + nnodes[i] + <span class="string">&quot;&gt;=&quot;</span> + countOnLevel0;</span><br><span class="line">				nnodes[i] -= nnodes[i - <span class="number">1</span>];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 顺序写入经过差值压缩后的编码，nnodes[0]是原值</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">				vectorIndex.writeVInt(nnodes[i]);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 将这个节点的连接信息的长度记录到offset表中</span></span><br><span class="line">			offsets[level][nodeOffsetId++] =</span><br><span class="line">				Math.toIntExact(vectorIndex.getFilePointer() - offsetStart);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> offsets;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 图索引meta信息的写入</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">writeMeta</span><span class="params">(</span></span><br><span class="line"><span class="params">      FieldInfo field,</span></span><br><span class="line"><span class="params">      <span class="type">long</span> vectorIndexOffset,</span></span><br><span class="line"><span class="params">      <span class="type">long</span> vectorIndexLength,</span></span><br><span class="line"><span class="params">      <span class="type">int</span> count,</span></span><br><span class="line"><span class="params">      HnswGraph graph,</span></span><br><span class="line"><span class="params">      <span class="type">int</span>[][] graphLevelNodeOffsets)</span></span><br><span class="line">      <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    meta.writeInt(field.number);</span><br><span class="line">	<span class="comment">// 向量的编码FLOAT or BYTES</span></span><br><span class="line">    meta.writeInt(field.getVectorEncoding().ordinal());</span><br><span class="line">	<span class="comment">// 向量距离的计算方式</span></span><br><span class="line">    meta.writeInt(field.getVectorSimilarityFunction().ordinal());</span><br><span class="line">	<span class="comment">// 向量索引的开始位置</span></span><br><span class="line">    meta.writeVLong(vectorIndexOffset);</span><br><span class="line">	<span class="comment">// 向量索引的总长度</span></span><br><span class="line">    meta.writeVLong(vectorIndexLength);</span><br><span class="line">	<span class="comment">// 向量的维度</span></span><br><span class="line">    meta.writeVInt(field.getVectorDimension());</span><br><span class="line">	<span class="comment">// 向量的数量</span></span><br><span class="line">    meta.writeInt(count);</span><br><span class="line">    meta.writeVInt(M);</span><br><span class="line">    <span class="comment">// write graph nodes on each level</span></span><br><span class="line">    <span class="keyword">if</span> (graph == <span class="literal">null</span>) &#123;</span><br><span class="line">      meta.writeVInt(<span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="comment">// HNSW索引的层级</span></span><br><span class="line">      meta.writeVInt(graph.numLevels());</span><br><span class="line">      <span class="type">long</span> <span class="variable">valueCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">level</span> <span class="operator">=</span> <span class="number">0</span>; level &lt; graph.numLevels(); level++) &#123;</span><br><span class="line">		<span class="comment">// 获取每个层级的节点</span></span><br><span class="line">        <span class="type">NodesIterator</span> <span class="variable">nodesOnLevel</span> <span class="operator">=</span> graph.getNodesOnLevel(level);</span><br><span class="line">        valueCount += nodesOnLevel.size();</span><br><span class="line">        <span class="keyword">if</span> (level &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		  <span class="comment">// 非level0 的才需要写入meta</span></span><br><span class="line">          <span class="type">int</span>[] nol = <span class="keyword">new</span> <span class="title class_">int</span>[nodesOnLevel.size()];</span><br><span class="line">          <span class="type">int</span> <span class="variable">numberConsumed</span> <span class="operator">=</span> nodesOnLevel.consume(nol);</span><br><span class="line">		  <span class="comment">// 方便后面差值编码</span></span><br><span class="line">          Arrays.sort(nol);</span><br><span class="line">          <span class="keyword">assert</span> numberConsumed == nodesOnLevel.size();</span><br><span class="line">		  <span class="comment">// 写入该层级的节点数</span></span><br><span class="line">          meta.writeVInt(nol.length); <span class="comment">// number of nodes on a level</span></span><br><span class="line">          <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> nodesOnLevel.size() - <span class="number">1</span>; i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">            nol[i] -= nol[i - <span class="number">1</span>];</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">for</span> (<span class="type">int</span> n : nol) &#123;</span><br><span class="line">            <span class="keyword">assert</span> n &gt;= <span class="number">0</span> : <span class="string">&quot;delta encoding for nodes failed; expected nodes to be sorted&quot;</span>;</span><br><span class="line">			<span class="comment">// 写入该层级的节点压缩编码</span></span><br><span class="line">            meta.writeVInt(n);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">assert</span> nodesOnLevel.size() == count : <span class="string">&quot;Level 0 expects to have all nodes&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> vectorIndex.getFilePointer();</span><br><span class="line">	  <span class="comment">// 记录vectorIndex当前的文件位置（已经写完graph的连接信息的位置）</span></span><br><span class="line">      meta.writeLong(start);</span><br><span class="line">      meta.writeVInt(DIRECT_MONOTONIC_BLOCK_SHIFT);</span><br><span class="line">	  <span class="comment">// graphLevelNodeOffsets的压缩编码, valueCount是说有level的总连接点的数量</span></span><br><span class="line">	  <span class="comment">// graphLevelNodeOffsets写入的也是VectorIndex</span></span><br><span class="line">      <span class="keyword">final</span> <span class="type">DirectMonotonicWriter</span> <span class="variable">memoryOffsetsWriter</span> <span class="operator">=</span></span><br><span class="line">          DirectMonotonicWriter.getInstance(</span><br><span class="line">              meta, vectorIndex, valueCount, DIRECT_MONOTONIC_BLOCK_SHIFT);</span><br><span class="line">      <span class="type">long</span> <span class="variable">cumulativeOffsetSum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span>[] levelOffsets : graphLevelNodeOffsets) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> v : levelOffsets) &#123;</span><br><span class="line">          memoryOffsetsWriter.add(cumulativeOffsetSum);</span><br><span class="line">          cumulativeOffsetSum += v;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      memoryOffsetsWriter.finish();</span><br><span class="line">      meta.writeLong(vectorIndex.getFilePointer() - start);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ol>
<li>Lucene中对整个向量相关的存储整体是分成两部分（原始向量和HNSW向量索引）.</li>
<li>在存储向量的索引过程中整体分成两个步骤<ul>
<li>第一步存储各个层级节点的连接信息（graph），通过对连接节点的排序，存储差值对连接信息进行了压缩，在写入节点信息的过程过程中，会生成offset表，表示了每个层级中节点对应的连接信息的offset</li>
<li>第二步存储第一步生成的offset表，利用了DirectMonotonicWriter 进行了压缩处理</li>
</ul>
</li>
<li>整体可以看到，Lucene并没有存储索引的原始信息，而是经过一系列精巧的压缩处理，减少了磁盘占用，后面的文章中会深入探讨这种压缩处理的利弊</li>
</ol>
<h1 id="Lucene在Merge的过程中如何处理HNSW索引的"><a href="#Lucene在Merge的过程中如何处理HNSW索引的" class="headerlink" title="Lucene在Merge的过程中如何处理HNSW索引的"></a>Lucene在Merge的过程中如何处理HNSW索引的</h1><p>上文介绍的内容都是Lucene在生成一个Segment的过程中对向量及其索引的计算和存储，在实际的系统中，比如Elasticsearch一般都会有多个Lucene Segment的生成，Lucene本身也会对多个小Segment进行Merge, 我们需要知道在merge的过程中Lucene是如何处理向量相关的索引的</p>
<p>本文使用<code>IndexWriter.forceMerge(1)</code>触发merge操作，得到下文的调用栈</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">mergeOneField</span><span class="params">(FieldInfo fieldInfo, MergeState mergeState)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">CloseableRandomVectorScorerSupplier</span> <span class="variable">scorerSupplier</span> <span class="operator">=</span></span><br><span class="line">        flatVectorWriter.mergeOneFieldToIndex(fieldInfo, mergeState);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="type">long</span> <span class="variable">vectorIndexOffset</span> <span class="operator">=</span> vectorIndex.getFilePointer();</span><br><span class="line">      <span class="comment">// build the graph using the temporary vector data</span></span><br><span class="line">      <span class="comment">// we use Lucene99HnswVectorsReader.DenseOffHeapVectorValues for the graph construction</span></span><br><span class="line">      <span class="comment">// doesn&#x27;t need to know docIds</span></span><br><span class="line">      <span class="comment">// <span class="doctag">TODO:</span> separate random access vector values from DocIdSetIterator?</span></span><br><span class="line">      <span class="type">OnHeapHnswGraph</span> <span class="variable">graph</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">      <span class="type">int</span>[][] vectorIndexNodeOffsets = <span class="literal">null</span>;</span><br><span class="line">      <span class="keyword">if</span> (scorerSupplier.totalVectorCount() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// build graph</span></span><br><span class="line">		<span class="comment">// Merger是IncrementalHnswGraphMerger</span></span><br><span class="line">        <span class="type">HnswGraphMerger</span> <span class="variable">merger</span> <span class="operator">=</span> createGraphMerger(fieldInfo, scorerSupplier);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; mergeState.liveDocs.length; i++) &#123;</span><br><span class="line">		  <span class="comment">// 这里会选出节点数最大的graph，作为merge过程中初始的graph以减少图的构建</span></span><br><span class="line">          merger.addReader(</span><br><span class="line">              mergeState.knnVectorsReaders[i], mergeState.docMaps[i], mergeState.liveDocs[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> DocIdSetIterator mergedVectorIterator;</span><br><span class="line">        <span class="keyword">switch</span> (fieldInfo.getVectorEncoding()) &#123;</span><br><span class="line">          <span class="keyword">case</span> BYTE:</span><br><span class="line">            mergedVectorIterator =</span><br><span class="line">                KnnVectorsWriter.MergedVectorValues.mergeByteVectorValues(fieldInfo, mergeState);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> FLOAT32:</span><br><span class="line">			 <span class="comment">// 获取每个Segment对应的原始向量，使用 OffHeapFloatVectorValues.load 获取每个原始向量</span></span><br><span class="line">            mergedVectorIterator =</span><br><span class="line">                KnnVectorsWriter.MergedVectorValues.mergeFloatVectorValues(fieldInfo, mergeState);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(</span><br><span class="line">                <span class="string">&quot;Unsupported vector encoding: &quot;</span> + fieldInfo.getVectorEncoding());</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// 多个Segment中的HNSW graph合并成一个OnHeapHnswGraph</span></span><br><span class="line">        graph =</span><br><span class="line">            merger.merge(</span><br><span class="line">                mergedVectorIterator,</span><br><span class="line">                segmentWriteState.infoStream,</span><br><span class="line">                scorerSupplier.totalVectorCount());</span><br><span class="line">		<span class="comment">// 这里的写入和上文中的处理是一致的</span></span><br><span class="line">        vectorIndexNodeOffsets = writeGraph(graph);</span><br><span class="line">      &#125;</span><br><span class="line">	  <span class="comment">// 这里同上文也是一致的</span></span><br><span class="line">      <span class="type">long</span> <span class="variable">vectorIndexLength</span> <span class="operator">=</span> vectorIndex.getFilePointer() - vectorIndexOffset;</span><br><span class="line">      writeMeta(</span><br><span class="line">          fieldInfo,</span><br><span class="line">          vectorIndexOffset,</span><br><span class="line">          vectorIndexLength,</span><br><span class="line">          scorerSupplier.totalVectorCount(),</span><br><span class="line">          graph,</span><br><span class="line">          vectorIndexNodeOffsets);</span><br><span class="line">      success = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (success) &#123;</span><br><span class="line">        IOUtils.close(scorerSupplier);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        IOUtils.closeWhileHandlingException(scorerSupplier);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 选出最大的graph 作为初始graph</span></span><br><span class="line"><span class="keyword">public</span> IncrementalHnswGraphMerger <span class="title function_">addReader</span><span class="params">(</span></span><br><span class="line"><span class="params">      KnnVectorsReader reader, MergeState.DocMap docMap, Bits liveDocs)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">KnnVectorsReader</span> <span class="variable">currKnnVectorsReader</span> <span class="operator">=</span> reader;</span><br><span class="line">    <span class="keyword">if</span> (reader <span class="keyword">instanceof</span> PerFieldKnnVectorsFormat.FieldsReader) &#123;</span><br><span class="line">      currKnnVectorsReader =</span><br><span class="line">          ((PerFieldKnnVectorsFormat.FieldsReader) reader).getFieldReader(fieldInfo.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!(currKnnVectorsReader <span class="keyword">instanceof</span> HnswGraphProvider) || !noDeletes(liveDocs)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">candidateVectorCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">switch</span> (fieldInfo.getVectorEncoding()) &#123;</span><br><span class="line">      <span class="keyword">case</span> BYTE:</span><br><span class="line">        <span class="type">ByteVectorValues</span> <span class="variable">byteVectorValues</span> <span class="operator">=</span></span><br><span class="line">            currKnnVectorsReader.getByteVectorValues(fieldInfo.name);</span><br><span class="line">        <span class="keyword">if</span> (byteVectorValues == <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        candidateVectorCount = byteVectorValues.size();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> FLOAT32:</span><br><span class="line">        <span class="type">FloatVectorValues</span> <span class="variable">vectorValues</span> <span class="operator">=</span> currKnnVectorsReader.getFloatVectorValues(fieldInfo.name);</span><br><span class="line">        <span class="keyword">if</span> (vectorValues == <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        candidateVectorCount = vectorValues.size();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(</span><br><span class="line">            <span class="string">&quot;Unexpected vector encoding: &quot;</span> + fieldInfo.getVectorEncoding());</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 选取最大节点数（向量数）的graph作为初始化的graph，这里使用initReader代替，后续使用initReader读取graph的时候就以这个graph作为初始graph</span></span><br><span class="line">    <span class="keyword">if</span> (candidateVectorCount &gt; initGraphSize) &#123;</span><br><span class="line">      initReader = currKnnVectorsReader;</span><br><span class="line">      initDocMap = docMap;</span><br><span class="line">      initGraphSize = candidateVectorCount;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理merge的入口</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> OnHeapHnswGraph <span class="title function_">merge</span><span class="params">(</span></span><br><span class="line"><span class="params">      DocIdSetIterator mergedVectorIterator, InfoStream infoStream, <span class="type">int</span> maxOrd)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">	<span class="comment">// 创建 InitializedHnswGraphBuilder 对象, 同时会将最大的初始化graph load进内存变成`OnHeapHnswGraph`</span></span><br><span class="line">    <span class="type">HnswBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> createBuilder(mergedVectorIterator, maxOrd);</span><br><span class="line">    builder.setInfoStream(infoStream);</span><br><span class="line">    <span class="keyword">return</span> builder.build(maxOrd);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化graph的 init过程</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> OnHeapHnswGraph <span class="title function_">initGraph</span><span class="params">(</span></span><br><span class="line"><span class="params">      <span class="type">int</span> M, HnswGraph initializerGraph, <span class="type">int</span>[] newOrdMap, <span class="type">int</span> totalNumberOfVectors)</span></span><br><span class="line">      <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">	<span class="comment">// 用新的总向量数量和代替之前的节点数</span></span><br><span class="line">    <span class="type">OnHeapHnswGraph</span> <span class="variable">hnsw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OnHeapHnswGraph</span>(M, totalNumberOfVectors);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">level</span> <span class="operator">=</span> initializerGraph.numLevels() - <span class="number">1</span>; level &gt;= <span class="number">0</span>; level--) &#123;</span><br><span class="line">      HnswGraph.<span class="type">NodesIterator</span> <span class="variable">it</span> <span class="operator">=</span> initializerGraph.getNodesOnLevel(level);</span><br><span class="line">      <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">oldOrd</span> <span class="operator">=</span> it.nextInt();</span><br><span class="line">        <span class="type">int</span> <span class="variable">newOrd</span> <span class="operator">=</span> newOrdMap[oldOrd];</span><br><span class="line">        hnsw.addNode(level, newOrd);</span><br><span class="line">        hnsw.trySetNewEntryNode(newOrd, level);</span><br><span class="line">        <span class="type">NeighborArray</span> <span class="variable">newNeighbors</span> <span class="operator">=</span> hnsw.getNeighbors(level, newOrd);</span><br><span class="line">        initializerGraph.seek(level, oldOrd);</span><br><span class="line">		<span class="comment">// 直接复制之前的连接信息</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">oldNeighbor</span> <span class="operator">=</span> initializerGraph.nextNeighbor();</span><br><span class="line">            oldNeighbor != NO_MORE_DOCS;</span><br><span class="line">            oldNeighbor = initializerGraph.nextNeighbor()) &#123;</span><br><span class="line">          <span class="type">int</span> <span class="variable">newNeighbor</span> <span class="operator">=</span> newOrdMap[oldNeighbor];</span><br><span class="line">          <span class="comment">// we will compute these scores later when we need to pop out the non-diverse nodes</span></span><br><span class="line">          newNeighbors.addOutOfOrder(newNeighbor, Float.NaN);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hnsw;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// merge过程中处理Vector相关的代码</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">addVectors</span><span class="params">(<span class="type">int</span> minOrd, <span class="type">int</span> maxOrd)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.nanoTime(), t = start;</span><br><span class="line">    <span class="keyword">if</span> (infoStream.isEnabled(HNSW_COMPONENT)) &#123;</span><br><span class="line">      infoStream.message(HNSW_COMPONENT, <span class="string">&quot;addVectors [&quot;</span> + minOrd + <span class="string">&quot; &quot;</span> + maxOrd + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">node</span> <span class="operator">=</span> minOrd; node &lt; maxOrd; node++) &#123;</span><br><span class="line">		<span class="comment">// 添加新的node到graph中</span></span><br><span class="line">      addGraphNode(node);</span><br><span class="line">      <span class="keyword">if</span> ((node % <span class="number">10000</span> == <span class="number">0</span>) &amp;&amp; infoStream.isEnabled(HNSW_COMPONENT)) &#123;</span><br><span class="line">        t = printGraphBuildStatus(node, start, t);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// 实际的addGraphNode 调用，`InitializedHnswGraphBuilder.addGraphNode`</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addGraphNode</span><span class="params">(<span class="type">int</span> node)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">	<span class="comment">// merge的时候会选出节点数最多的索引作为初始的graph, 初始graph的所有信息都是构建好的，所以就不要添加了</span></span><br><span class="line">    <span class="keyword">if</span> (initializedNodes.get(node)) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 向当前的graph中添加节点，执行标准hnsw构建流程</span></span><br><span class="line">    <span class="built_in">super</span>.addGraphNode(node);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><ul>
<li>merge过程中，核心点是选出一个最大的graph作为初始化graph，然后将其他segment的hsnw graph 写入到这个初始化graph中（省去了一些计算）,不过由于其他segment的graph的节点仍然需要重新计算, 导致merge的cpu成本也比较高</li>
<li>merge过程中，所有的向量都会被读取到<code>OnHeapHnswGraph</code>中，所以内存压力比较高</li>
<li>对于HNSW 索引来说，merge一个成本高昂的操作</li>
</ul>
	  

	  <div>
  		<center>
		  <div class="pagination">
<ul class="pagination">
	
	
	
	
	
	
		
			
			
		
	
		
			
			
			
		
			
		
	
		
			
		
	
		
			
		
	
		
			
		
	
		
			
		
	
		
			
		
	
		
			
		
	
		
			
		
	
		
			
		
	
		
			
		
	
	
	
		<li class="prev disabled"><a><i class="fa fa-arrow-circle-o-left"></i>prev</a></li>
	
	<li><a href="/"><i class="fa fa-archive"></i>Home</a></li>
	
		<li class="next"><a href="/2024/08/04/Lucene%E4%B8%ADTerm%E7%9B%B8%E5%85%B3%E7%9A%84%E5%80%92%E6%8E%92%E6%96%87%E4%BB%B6%E6%98%AF%E5%A6%82%E4%BD%95%E7%94%9F%E6%88%90%E7%9A%84/" class="alignright next">next<i class="fa fa-arrow-circle-o-right"></i></a></li>
	
</ul>
</div>

		</center>
	  </div>
	  
	</div> <!-- col-md-9/col-md-12 -->
	
  </div><!-- row -->

	</div>
  </div>
  <div class="container-narrow">
	<footer> <p>
  &copy; 2024 skyitachi
  
      with help from <a href="http://zespia.tw/hexo/" target="_blank">Hexo</a> and <a href="http://getbootstrap.com/" target="_blank">Twitter Bootstrap</a>. Theme by <a href="http://github.com/wzpan/hexo-theme-wixo/">Wixo</a>.    
</p> </footer>
  </div> <!-- container-narrow -->
  
<a id="gotop" href="#">   
  <span>▲</span> 
</a>

<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/bootstrap.min.js"></script>
<script src="/js/jquery.tableofcontents.min.js"></script>
<script src="/js/tocgenerator.min.js"></script>
<script src="/js/main.js"></script>
<script src="/js/search.js"></script> 




<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>



   <script type="text/javascript">      
     var search_path = "search.xml";
	 if (search_path.length == 0) {
	 	search_path = "search.xml";
	 }
	 var path = "/" + search_path;
     searchFunc(path, 'local-search-input', 'local-search-result');
   </script>


</body>
</html>
